CREATE OR REPLACE PACKAGE BODY SMR_ORDER_RCV_SQL AS
-- Module Name: SMR_ORDER_RCV_SQL
-- Description: This package is a custom version of the base RMS ORDER_RCV_SQL
--
-- Modification History
-- Version Date      Developer   Issue    Description
-- ======= ========= =========== ======== =========================================
-- 1.00                                   Oracle Retail initial version
-- 1.01    20-Jul-11 P.Dinsdale  ENH 38   OLR initial version.
-- 1.02    10-Feb-12 P.Dinsdale           Applied patch 12564615, 13029695, 13040041, 13252641
                                          --Did not apply patch 13015122 as that is for
                                          --receiver unit adjustments, and this form is only
                                          --for receipts, not adjustments.
                                          --Did not apply patch 13252641 as it fixes an issue
                                          --with 13015122, which was not applied.
-- 1.03                                   Fixed unit cost in ordloc
--------------------------------------------------------------------------------

-------------------------------------------------------------------------------
--                        Structure for BULK DML                             --
-------------------------------------------------------------------------------

--- Global cache for sup_data insert
TYPE sup_data_dept_TBL        is table of SUP_DATA.DEPT%TYPE        INDEX BY BINARY_INTEGER;
TYPE sup_data_supplier_TBL    is table of SUP_DATA.SUPPLIER%TYPE    INDEX BY BINARY_INTEGER;
TYPE sup_data_day_date_TBL    is table of SUP_DATA.DAY_DATE%TYPE    INDEX BY BINARY_INTEGER;
TYPE sup_data_tran_type_TBL   is table of SUP_DATA.TRAN_TYPE%TYPE   INDEX BY BINARY_INTEGER;
TYPE sup_data_amount_TBL      is table of SUP_DATA.AMOUNT%TYPE      INDEX BY BINARY_INTEGER;
P_sup_data_dept               sup_data_dept_TBL;
P_sup_data_supplier           sup_data_supplier_TBL;
P_sup_data_day_date           sup_data_day_date_TBL;
P_sup_data_tran_type          sup_data_tran_type_TBL;
P_sup_data_amount             sup_data_amount_TBL;
P_sup_data_size               NUMBER  := 0;

-- The prefix 'SIM' will be used for ASN numbers generated by SIM.
-- SIM will generate ASN numbers when it does not have the supplier's ASN number.
---
LP_sim_asn_prefix           VARCHAR2(3) := 'SIM';
LP_shipment_to_process      SHIPMENT.SHIPMENT%TYPE;
LP_prev_shipment            SHIPMENT.SHIPMENT%TYPE := NULL;
LP_tsf_no                   TSFHEAD.TSF_NO%TYPE    := NULL;
LP_create_tsf               VARCHAR2(1)            := 'Y';
LP_online_dsd_ind           VARCHAR2(1) := 'N';

-- For catch weight fixed weight Simple Items the Default values should be taken
-- as nominal weight if input weight and weight uom passed as null
LP_update_shipsku_weight    VARCHAR2(1) := 'N';
L_deposit_complex_ind       VARCHAR2(1) := 'N'; --OLR V1.02 Inserted patch 13029695
-------------------------------------------------------------------------------
--                        PRIVATE FUNCTION PROTOTYPES                        --
-------------------------------------------------------------------------------

FUNCTION VALIDATE_INPUT(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                        I_item_rec        IN OUT   ITEM_RCV_RECORD,
                        I_comp_items      IN OUT   COMP_ITEM_ARRAY,
                        I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION ITEM_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN OUT   ITEM_RCV_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION GET_SYSTEM_OPTIONS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION ORD_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                   I_item_rec        IN OUT   ITEM_RCV_RECORD,
                   I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION GET_ORD_INFO(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                      I_order_no        IN       ORDHEAD.ORDER_NO%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION APPT_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN       ITEM_RCV_RECORD,
                    I_values          IN       COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION SHIP_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN OUT   ITEM_RCV_RECORD,
                    I_values          IN       COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION GET_SHIP_INFO(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE,
                       I_item_rec      IN OUT ITEM_RCV_RECORD,
                       I_input_qty     IN ordloc.qty_ordered%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION ON_ORDER(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                  I_item_rec        IN OUT   ITEM_RCV_RECORD,
                  I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION Insert_Update_SHIPSKU(O_error_message     IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                               I_item_rec          IN OUT   ITEM_RCV_RECORD,
                               I_values            IN OUT   COST_RETAIL_QTY_RECORD,
                               I_update_qty_only   IN       VARCHAR2)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION UPDATE_INVC_MATCH_WKSHT(O_error_message    IN OUT  RTK_ERRORS.RTK_TEXT%TYPE,
                                 I_item_rec         IN OUT  ITEM_RCV_RECORD,
                                 I_values           IN OUT  COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION LOAD_COMPS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN OUT   ITEM_RCV_RECORD,
                    I_comp_items      IN OUT   COMP_ITEM_ARRAY,
                    I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION UPDATE_ALLOC(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                      I_alloc_no        IN       ALLOC_DETAIL.ALLOC_NO%TYPE,
                      I_destination     IN       ALLOC_DETAIL.TO_LOC%TYPE,
                      I_input_qty       IN       ALLOC_DETAIL.PO_RCVD_QTY%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION ALC_PROCESSING(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                        I_item_rec        IN OUT   ITEM_RCV_RECORD,
                        I_comp_items      IN       COMP_ITEM_ARRAY,
                        I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION BACK_OUT_ALC(O_error_message     IN OUT   VARCHAR2,
                      I_item_rec          IN       ITEM_RCV_RECORD,
                      I_values            IN       COST_RETAIL_QTY_RECORD,
                      I_comp_item         IN       ITEM_MASTER.ITEM%TYPE,
                      I_unit_cost_prim    IN       ORDLOC.UNIT_COST%TYPE,
                      I_ol_qty_received   IN       ORDLOC.QTY_RECEIVED%TYPE,
                      I_pack_cost_loc     IN       ITEM_SUPP_COUNTRY.UNIT_COST%TYPE,
                      I_comp_cost_loc     IN       ITEM_SUPP_COUNTRY.UNIT_COST%TYPE,
                      I_comp_qty          IN       ORDLOC.QTY_RECEIVED%TYPE,
                      I_dept              IN       DEPS.DEPT%TYPE,
                      I_class             IN       CLASS.CLASS%TYPE,
                      I_subclass          IN       SUBCLASS.SUBCLASS%TYPE,
                      I_alc_status        IN       ALC_HEAD.STATUS%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION GET_ELC_TOTAL_LOC(O_error_message    IN OUT   VARCHAR2,
                           O_elc_loc          IN OUT   ITEM_LOC.UNIT_RETAIL%TYPE,
                           I_item_rec         IN       ITEM_RCV_RECORD,
                           I_values           IN       COST_RETAIL_QTY_RECORD,
                           I_item             IN       ITEM_MASTER.ITEM%TYPE,
                           I_comp_item        IN       ITEM_MASTER.ITEM%TYPE,
                           I_unit_cost_ord    IN       ITEM_LOC_SOH.UNIT_COST%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION PACK_LEVEL_UPDATES(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                            I_values          IN OUT   COST_RETAIL_QTY_RECORD,
                            I_item_rec        IN       ITEM_RCV_RECORD,
                            I_weight          IN       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE,
                            I_weight_uom      IN       UOM_CLASS.UOM%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION SET_AV_COST_OTB_COST(O_error_message        IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                              IO_values              IN OUT   COST_RETAIL_QTY_RECORD,
                              I_pack_no              IN       ITEM_MASTER.ITEM%TYPE,
                              I_item                 IN       ITEM_MASTER.ITEM%TYPE,
                              I_comp_item            IN       ITEM_MASTER.ITEM%TYPE,
                              I_comp_unit_cost_loc   IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                              I_item_rec             IN       ITEM_RCV_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION UPDATE_ITEM_STOCK(O_error_message           IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                           O_neg_soh_ac              IN OUT   ITEM_LOC_SOH.UNIT_COST%TYPE,
                           O_neg_soh                 IN OUT   ITEM_LOC_SOH.STOCK_ON_HAND%TYPE,
                           I_item                    IN       ITEM_MASTER.ITEM%TYPE,
                           I_comp_ind                IN       VARCHAR,
                           I_loc                     IN       ITEM_LOC.LOC%TYPE,
                           I_qty                     IN       ITEM_LOC_SOH.STOCK_ON_HAND%TYPE,
                           I_weight                  IN       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE,
                           I_weight_uom              IN       UOM_CLASS.UOM%TYPE,
                           I_av_cost_loc             IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                           I_total_cost_loc          IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                           I_tran_date               IN       DATE,
                           I_tran_type               IN       VARCHAR2,
                           I_upd_unit_cost           IN       VARCHAR2,
                           I_stock_count_processed   IN       BOOLEAN,
                           I_new_ordloc_ind          IN       VARCHAR2,
                           I_receive_as_type         IN       ITEM_LOC.RECEIVE_AS_TYPE%TYPE,
                           I_inv_status              IN       INV_STATUS_QTY.INV_STATUS%TYPE,
                           I_loc_type                IN       ITEM_LOC_SOH.LOC_TYPE%TYPE,
                           I_order_no                IN       ORDHEAD.ORDER_NO%TYPE,
                           I_unit_retail_loc         IN       ORDLOC.UNIT_RETAIL%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION STOCKLEDGER_INFO(O_error_message           IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                          I_neg_soh_ac              IN OUT   TRAN_DATA.TOTAL_COST%TYPE,
                          I_neg_soh                 IN       TRAN_DATA.UNITS%TYPE,
                          I_total_cost_loc          IN OUT   TRAN_DATA.TOTAL_COST%TYPE,
                          I_item                    IN       TRAN_DATA.ITEM%TYPE,
                          I_pack_ind                IN       ITEM_MASTER.PACK_IND%TYPE,
                          I_receive_as_type         IN       ITEM_LOC.RECEIVE_AS_TYPE%TYPE,
                          I_dept                    IN       TRAN_DATA.DEPT%TYPE,
                          I_class                   IN       TRAN_DATA.CLASS%TYPE,
                          I_subclass                IN       TRAN_DATA.SUBCLASS%TYPE,
                          I_tran_date               IN       DATE,
                          I_tran_type               IN       VARCHAR2,
                          I_receipt_qty             IN       TRAN_DATA.UNITS%TYPE,
                          I_total_retail_loc        IN       TRAN_DATA.TOTAL_RETAIL%TYPE,
                          I_shipment                IN       SHIPMENT.SHIPMENT%TYPE,
                          I_order_no                IN       ORDHEAD.ORDER_NO%TYPE,
                          I_stock_count_processed   IN       BOOLEAN,
                          I_snapshot_cost           IN       ORDLOC.UNIT_COST%TYPE,
                          I_snapshot_retail         IN       ORDLOC.UNIT_RETAIL%TYPE,
                          I_loc                     IN       ITEM_LOC.LOC%TYPE,
                          I_loc_type                IN       ITEM_LOC.LOC_TYPE%TYPE,
                          I_ref_pack_no             IN       TRAN_DATA.REF_PACK_NO%TYPE,
                          I_total_cost_excl_elc     IN       TRAN_DATA.TOTAL_COST_EXCL_ELC%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION SUP_DATA_INSERTS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                          I_supplier        IN       SUPS.SUPPLIER%TYPE,
                          I_dept            IN       DEPS.DEPT%TYPE,
                          I_tran_date       IN       DATE,
                          I_cost_prim       IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                          I_retail_prim     IN       ITEM_LOC.UNIT_RETAIL%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION FLUSH_SUP_DATA_CACHE(O_error_message  IN OUT  RTK_ERRORS.RTK_TEXT%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION UPD_INV_STATUS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                        I_item            IN       ITEM_MASTER.ITEM%TYPE,
                        I_inv_status      IN       SHIPSKU.INV_STATUS%TYPE,
                        I_qty             IN       ITEM_LOC_SOH.STOCK_ON_HAND%TYPE,
                        I_total_cost      IN       ORDLOC.UNIT_COST%TYPE     DEFAULT NULL,
                        I_total_retail    IN       ORDLOC.UNIT_RETAIL%TYPE   DEFAULT NULL,
                        I_loc             IN       ITEM_LOC.LOC%TYPE,
                        I_loc_type        IN       ITEM_LOC.LOC_TYPE%TYPE,
                        I_tran_date       IN       PERIOD.VDATE%TYPE,
                        I_order_no        IN       ORDHEAD.ORDER_NO%TYPE     DEFAULT NULL)

RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION CHECK_AGAINST_CONTRACT(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                                I_values          IN OUT   COST_RETAIL_QTY_RECORD,
                                I_item_rec        IN       ITEM_RCV_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION INVC_PROCESSING(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                         I_values          IN       COST_RETAIL_QTY_RECORD,
                         I_item_rec        IN       ITEM_RCV_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION IB_LINK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                 I_item_rec        IN       ITEM_RCV_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION OPEN_ORDER(O_error_message   IN OUT   VARCHAR2,
                    I_order_no        IN       ORDHEAD.ORDER_NO%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION CONTAINER_ITEM_CHECK(O_error_message      IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                              I_container_item_rec IN OUT   ITEM_RCV_RECORD,
                              I_container_values   IN OUT   COST_RETAIL_QTY_RECORD,
                              I_container_item     IN       ITEM_MASTER.ITEM%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION UPDATE_SHIPSKU_WEIGHT(O_error_message      IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                               I_shipment           IN       SHIPSKU.SHIPMENT%TYPE,
                               I_item               IN       SHIPSKU.ITEM%TYPE,
                               I_carton             IN       SHIPSKU.CARTON%TYPE,
                               I_inv_status         IN       SHIPSKU.INV_STATUS%TYPE,
                               I_weight             IN       SHIPSKU.WEIGHT_EXPECTED%TYPE,
                               I_weight_uom         IN       SHIPSKU.WEIGHT_EXPECTED_UOM%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
--OLR V1.02 Insert START patch 12564615
FUNCTION INSERT_UPDATE_SHIPSKU_LOC(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE,
                                   I_item_rec      IN OUT ITEM_RCV_RECORD,
                                   I_values        IN OUT COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION ADD_ORD_SHIPMENT_TO_QUEUE(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE,
                                   I_order_no IN ORDHEAD.ORDER_NO%TYPE,
                                   I_shipment IN SHIPSKU.SHIPMENT%TYPE)
RETURN BOOLEAN;
-------------------------------------------------------------------------------
FUNCTION PROCESS_REALLOC_ALC_FOR_QUEUE(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE)
RETURN BOOLEAN;

   RETURN BOOLEAN;
-------------------------------------------------------------------------------
--OLR V1.02 Insert END patch 12564615
-------------------------------------------------------------------------------
--                             PUBLIC FUNCTIONS                              --
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--OLR V1.02 Insert START patch 13029695
FUNCTION GET_COMPLEX_ADJ_COST(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE,
                              IO_adj_value    IN OUT ORDLOC.UNIT_COST%TYPE,
                              I_pack_no       IN     ITEM_MASTER.ITEM%TYPE,
                              I_comp_item     IN     ITEM_MASTER.ITEM%TYPE,
                              I_item_loc      IN     ITEM_LOC.LOC%TYPE,
                              I_item_supplier IN     ITEM_SUPPLIER.SUPPLIER%TYPE)
RETURN BOOLEAN IS

   L_function VARCHAR2(40) := 'SMR_ORDER_RCV_SQL.GET_COMPLEX_ADJ_COST';
   L_content_exists VARCHAR2(1) := 'N';
   L_comp_item ITEM_MASTER.ITEM%TYPE;
   L_deposit_type ITEM_MASTER.DEPOSIT_ITEM_TYPE%TYPE;
   L_unit_cost ITEM_SUPP_COUNTRY_LOC.UNIT_COST%TYPE;
   L_adj_cost ITEM_SUPP_COUNTRY_LOC.UNIT_COST%TYPE;

   cursor C_COMP_DETAILS is
   SELECT im.item,im.deposit_item_type,i.unit_cost
     FROM item_master im,
          item_supp_country_loc i
    WHERE i.item = I_comp_item
      AND i.item = im.item
      AND i.loc = I_item_loc
      AND i.supplier = I_item_supplier;

   cursor C_ADJUST_COST is
   SELECT sum(i.unit_cost)
     FROM packitem pi,
          item_supp_country_loc i,
          item_master im
    WHERE pi.pack_no = I_pack_no
      AND pi.item = i.item
      AND pi.item = im.item
      AND i.loc = I_item_loc
      AND i.supplier = I_item_supplier
      AND im.deposit_item_type IN ('A','Z');

BEGIN

   open C_COMP_DETAILS;
   fetch C_COMP_DETAILS into L_comp_item,
                             L_deposit_type,
                             L_unit_cost;
   close C_COMP_DETAILS;

   if L_deposit_type in ('A','Z') then
      IO_adj_value := L_unit_cost;
   else
      open C_ADJUST_COST;
      fetch C_ADJUST_COST into L_adj_cost;
      close C_ADJUST_COST;

      IO_adj_value := IO_adj_value - L_adj_cost;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END GET_COMPLEX_ADJ_COST;
-------------------------------------------------------------------------------
--OLR V1.02 Insert END patch 13029695

FUNCTION INIT_PO_ASN_LOC_GROUP(O_error_message   IN OUT  RTK_ERRORS.RTK_TEXT%TYPE)

return BOOLEAN IS

   L_function   VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.INIT_PO_ASN_LOC_GROUP';

   cursor C_VDATE is
      select vdate
        from period;

BEGIN

   LP_header_lookup_record := NULL;

   open C_VDATE;
   fetch C_VDATE into LP_vdate;
   close C_VDATE;

   --- This is a new message, clear out the cached OTB info.
   LP_rib_otb_tbl := "RIB_OTB_TBL"(NULL);
   LP_rib_otb_tbl.DELETE;

   if STKLEDGR_SQL.INIT_TRAN_DATA_INSERT(O_error_message) = FALSE then
      return FALSE;
   end if;

   P_sup_data_size := 0;

   --OLR V1.02 Insert START
   -- Clear the Queue
   LP_ord_shipment_tbl.DELETE;
   --OLR V1.02 Insert END

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END INIT_PO_ASN_LOC_GROUP;

-------------------------------------------------------------------------------


FUNCTION FINISH_PO_ASN_LOC_GROUP(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                                 O_rib_otb_tbl     IN OUT   "RIB_OTB_TBL")
return BOOLEAN IS

   L_function   VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.FINISH_PO_ASN_LOC_GROUP';

BEGIN

   O_rib_otb_tbl := LP_rib_otb_tbl;

   if STKLEDGR_SQL.FLUSH_TRAN_DATA_INSERT(O_error_message) = FALSE then
      return FALSE;
   end if;

   if FLUSH_SUP_DATA_CACHE(O_error_message) = FALSE then
      return FALSE;
   end if;

   --OLR V1.02 Insert START
   if PROCESS_REALLOC_ALC_FOR_QUEUE(O_error_message) = FALSE then
      return FALSE;
   end if;
   --OLR V1.02 Insert END

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END FINISH_PO_ASN_LOC_GROUP;

-------------------------------------------------------------------------------

FUNCTION PO_LINE_ITEM_ONLINE(O_error_message    IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                             I_loc              IN       ITEM_LOC.LOC%TYPE,
                             I_order_no         IN       ORDHEAD.ORDER_NO%TYPE,
                             I_item             IN       ITEM_MASTER.ITEM%TYPE,
                             I_qty              IN       TRAN_DATA.UNITS%TYPE,
                             I_tran_type        IN       VARCHAR2,
                             I_tran_date        IN       DATE,
                             I_receipt_number   IN       SHIPMENT.EXT_REF_NO_IN%TYPE,
                             I_asn              IN       SHIPMENT.ASN%TYPE,
                             I_appt             IN       APPT_HEAD.APPT%TYPE,
                             I_carton           IN       SHIPSKU.CARTON%TYPE,
                             I_distro_type      IN       VARCHAR2,
                             I_distro_number    IN       ALLOC_HEADER.ALLOC_NO%TYPE,
                             I_destination      IN       ALLOC_DETAIL.TO_LOC%TYPE,
                             I_disp             IN       INV_STATUS_CODES.INV_STATUS_CODE%TYPE,
                             I_unit_cost        IN       ORDLOC.UNIT_COST%TYPE,
                             I_online_ind       IN       VARCHAR2)
RETURN BOOLEAN IS

   L_function          VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.PO_LINE_ITEM_ONLINE';

   L_rib_otb_tbl       "RIB_OTB_TBL"     := NULL;
   L_rib_otbdesc_rec   "RIB_OTBDesc_REC" := NULL;
   L_message_type      VARCHAR2(20)    := NULL;
   L_status_code       VARCHAR2(1)     := NULL;

BEGIN

   --- clear out any leftover OTB info/cache DML
   if SMR_ORDER_RCV_SQL.INIT_PO_ASN_LOC_GROUP(O_error_message) = FALSE then
      return FALSE;
   end if;
   if PO_LINE_ITEM(O_error_message,
                   I_loc,
                   I_order_no,
                   I_item,
                   I_qty,
                   I_tran_type,
                   I_tran_date,
                   TO_CHAR(I_receipt_number),
                   I_asn,
                   I_appt,
                   I_carton,
                   I_distro_type,
                   I_distro_number,
                   I_destination,
                   I_disp,
                   I_unit_cost,
                   I_qty,        --- I_shipped_qty
                   NULL,         --- I_weight
                   NULL,         --- I_weight_uom
                   I_online_ind) = FALSE then
       return FALSE;
    end if;

   if SMR_ORDER_RCV_SQL.FINISH_PO_ASN_LOC_GROUP(O_error_message,
                                            L_rib_otb_tbl) = FALSE then
      return FALSE;
   end if;

   L_rib_otbdesc_rec := "RIB_OTBDesc_REC"(0, L_rib_otb_tbl);

   RMSSUB_OTBMOD.CONSUME(L_status_code,
                         O_error_message,
                         L_rib_otbdesc_rec,
                         L_message_type);
   if L_status_code != API_CODES.SUCCESS then
      return FALSE;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END;

-------------------------------------------------------------------------------

FUNCTION PO_LINE_ITEM_ONLINE(O_error_message    IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                             I_loc              IN       ITEM_LOC.LOC%TYPE,
                             I_order_no         IN       ORDHEAD.ORDER_NO%TYPE,
                             I_item             IN       ITEM_MASTER.ITEM%TYPE,
                             I_qty              IN       TRAN_DATA.UNITS%TYPE,
                             I_tran_type        IN       VARCHAR2,
                             I_tran_date        IN       DATE,
                             I_receipt_number   IN       SHIPMENT.EXT_REF_NO_IN%TYPE,
                             I_asn              IN       SHIPMENT.ASN%TYPE,
                             I_appt             IN       APPT_HEAD.APPT%TYPE,
                             I_carton           IN       SHIPSKU.CARTON%TYPE,
                             I_distro_type      IN       VARCHAR2,
                             I_distro_number    IN       ALLOC_HEADER.ALLOC_NO%TYPE,
                             I_destination      IN       ALLOC_DETAIL.TO_LOC%TYPE,
                             I_disp             IN       INV_STATUS_CODES.INV_STATUS_CODE%TYPE,
                             I_unit_cost        IN       ORDLOC.UNIT_COST%TYPE,
                             I_online_ind       IN       VARCHAR2,
                             --
                             I_shipment         IN       SHIPMENT.SHIPMENT%TYPE)
RETURN BOOLEAN IS

   L_function          VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.PO_LINE_ITEM_ONLINE';

BEGIN

   if I_shipment is not null then
      LP_shipment_to_process := I_shipment;
   else
      LP_shipment_to_process := null;
   end if;

   --

   if PO_LINE_ITEM_ONLINE(O_error_message,
                          I_loc,
                          I_order_no,
                          I_item,
                          I_qty,
                          I_tran_type,
                          I_tran_date,
                          I_receipt_number,
                          I_asn,
                          I_appt,
                          I_carton,
                          I_distro_type,
                          I_distro_number,
                          I_destination,
                          I_disp,
                          I_unit_cost,
                          I_online_ind) = FALSE then
      LP_shipment_to_process := null;
      return FALSE;
   end if;

   LP_shipment_to_process := null;
   return TRUE;

EXCEPTION
   when OTHERS then
      LP_shipment_to_process := null;
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END;

-------------------------------------------------------------------------------

FUNCTION PO_LINE_ITEM(O_error_message    IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                      I_loc              IN       ITEM_LOC.LOC%TYPE,
                      I_order_no         IN       ORDHEAD.ORDER_NO%TYPE,
                      I_item             IN       ITEM_MASTER.ITEM%TYPE,
                      I_qty              IN       TRAN_DATA.UNITS%TYPE,
                      I_tran_type        IN       VARCHAR2,
                      I_tran_date        IN       DATE,
                      I_receipt_number   IN       SHIPMENT.EXT_REF_NO_IN%TYPE,
                      I_asn              IN       SHIPMENT.ASN%TYPE,
                      I_appt             IN       APPT_HEAD.APPT%TYPE,
                      I_carton           IN       SHIPSKU.CARTON%TYPE,
                      I_distro_type      IN       VARCHAR2,
                      I_distro_number    IN       ALLOC_HEADER.ALLOC_NO%TYPE,
                      I_destination      IN       ALLOC_DETAIL.TO_LOC%TYPE,
                      I_disp             IN       INV_STATUS_CODES.INV_STATUS_CODE%TYPE,
                      I_unit_cost        IN       ORDLOC.UNIT_COST%TYPE,
                      I_shipped_qty      IN       SHIPSKU.QTY_EXPECTED%TYPE,
                      I_weight           IN       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE,
                      I_weight_uom       IN       UOM_CLASS.UOM%TYPE,
                      I_online_ind       IN       VARCHAR2)
RETURN BOOLEAN IS

   L_function       VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.PO_LINE_ITEM';

   L_loc            ITEM_LOC.LOC%TYPE               := NULL;
   L_qty            ITEM_LOC_SOH.STOCK_ON_HAND%TYPE := 0;
   L_pwh_on_order   VARCHAR2(1)                     := 'N';
   L_min_cost       ORDLOC_INVC_COST.UNIT_COST%TYPE;
   L_max_cost       ORDLOC_INVC_COST.UNIT_COST%TYPE;
   L_item           ITEM_MASTER.ITEM%TYPE           := NULL;

   L_dist_table     DISTRIBUTION_SQL.DIST_TABLE_TYPE;
      --> Table returned from distribution call with locations and quantities
   L_dist_weight    ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE;
   L_exists         VARCHAR2(1);
   L_item_tbl       CREATE_ORD_TSF_SQL.ITEM_TBL_TSF;
   L_chrgs          item_loc.unit_retail%TYPE := 0;

   cursor C_ALLOC_WH is
      select ah.wh
        from alloc_header ah,
             wh w
       where ah.alloc_no   = I_distro_number
         and ah.order_no   = I_order_no
         and ah.item       = I_item
         and ah.wh         = w.wh
         and w.physical_wh = I_loc;

   cursor C_PWH_ON_ORDER is
      select 'Y'
        from ordloc o,
             wh w
       where o.order_no     = I_order_no
         and o.item         = I_item
         and w.physical_wh  = I_loc
         and o.location     = w.wh;

   cursor C_CHECK_ITEM_EXISTS is
      select im1.item
        from item_master im1,
             item_master im2
       where (im2.item       = I_item and
              im2.item_level = im2.tran_level and
              im1.item       = im2.item)
          or (im2.item       = I_item and
              im2.item_level = im2.tran_level + 1 and
              im1.item       = im2.item_parent);

BEGIN
   --- Check for NULL values

   if I_loc is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_loc',
                                            'NULL',
                                            'NOT_NULL ');
      return FALSE;
   elsif I_order_no is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_order_no',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_item is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_item',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_qty is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_qty',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_tran_type is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_tran_type',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_tran_date is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_tran_date',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   end if;

   -- Reset global variables, otherwise they remain static for entire session
   LP_deals_exist      := FALSE;
   LP_deals_shipment   := NULL;
   LP_shipment         := NULL;
   LP_tran_item        := NULL;
   LP_inv_status       := NULL;
   LP_total_weight     := NULL;
   LP_total_weight_uom := NULL;
   LP_update_shipsku_weight := 'N';

   --- Get info from system_options table if it hasn't already been fetched
   if LP_so_not_done then
      if SMR_ORDER_RCV_SQL.GET_SYSTEM_OPTIONS(O_error_message) = FALSE then
         return FALSE;
      end if;
   end if;
   if ITEM_ATTRIB_SQL.CONTENTS_ITEM_EXISTS(O_error_message,
                                           L_exists,
                                           I_item) = FALSE then
      return FALSE;
   end if;

   if L_exists = 'Y' then
      O_error_message := SQL_LIB.CREATE_MSG('SA_CANT_USE_DEPOSIT_CONTR',
                                             NULL,
                                             NULL,
                                             NULL);
      return FALSE;
   end if;

   --- If the location is different than that of the previous line
   --- item received in this session then fetch location currency.
   --- Otherwise, use the currency that was previously fetched.
   if I_loc != NVL(LP_last_loc,-1) then

      --- Get loc type (which also validates location)
      if LOCATION_ATTRIB_SQL.GET_TYPE(O_error_message,
                                      LP_loc_type,
                                      I_loc) = FALSE then
         return FALSE;
      end if;
      if CURRENCY_SQL.GET_CURR_LOC(O_error_message,
                                   I_loc,
                                   LP_loc_type,
                                   NULL,
                                   LP_loc_currency) = FALSE then
         return FALSE;
      end if;
      --- Save this location for the next comparison
      LP_last_loc := I_loc;

   end if;

   if LP_so_multichannel_ind = 'Y' and LP_loc_type = 'W' and I_distro_type = 'A' then
      --- MC with allocations

      --- Check if this is a good alloc/order/item/loc combo
      SQL_LIB.SET_MARK('OPEN','C_ALLOC_WH','ALLOC_HEADER/WH','alloc_no:'||to_char(I_distro_number)||
                       ' order_no:'||to_char(I_order_no)||' item:'||I_item||' physical_wh:'||to_char(I_loc));
      open C_ALLOC_WH;
      fetch C_ALLOC_WH into L_loc;
      close C_ALLOC_WH;

      if L_loc is NOT NULL then
         --- Good combo so receive the line item
         if SMR_ORDER_RCV_SQL.RCV_LINE_ITEM(O_error_message,
                                        I_loc,             -- phy_loc
                                        L_loc,
                                        LP_loc_type,
                                        I_order_no,
                                        I_item,
                                        I_qty,
                                        I_tran_type,
                                        I_tran_date,
                                        I_receipt_number,
                                        I_asn,
                                        I_appt,
                                        I_carton,
                                        I_distro_type,
                                        I_distro_number,
                                        I_destination,
                                        I_disp,
                                        I_unit_cost,
                                        I_shipped_qty,
                                        NULL,
                                        NULL,
                                        I_online_ind) = FALSE then
            return FALSE;
         end if;

      else -- Bad combo, error out

         O_error_message := SQL_LIB.CREATE_MSG('INV_ALLOC_ORDER_ITEM_LOC',
                                               null,
                                               I_order_no||'-'||I_loc,
                                               I_distro_number||'-'||I_item);

         return FALSE;

      end if; -- L_loc is NOT NULL


   elsif LP_so_multichannel_ind = 'Y' and LP_loc_type = 'W' then
      --- MC w/out allocations, call distribution package
      --- Check if item exists and get tran level item if it is a ref item, else get the item itself.

      SQL_LIB.SET_MARK('OPEN',
                       'C_CHECK_ITEM_EXISTS',
                       'ITEM_MASTER',
                       NULL);
      open C_CHECK_ITEM_EXISTS;

      SQL_LIB.SET_MARK('FETCH',
                       'C_CHECK_ITEM_EXISTS',
                       'ITEM_MASTER',
                       NULL);
      fetch C_CHECK_ITEM_EXISTS into L_item;

      SQL_LIB.SET_MARK('CLOSE',
                       'C_CHECK_ITEM_EXISTS',
                       'ITEM_MASTER',
                       NULL);
      close C_CHECK_ITEM_EXISTS;

      --- Check if wh exist on order
      SQL_LIB.SET_MARK('OPEN',
                       'C_PWH_ON_ORDER',
                       'ORDLOC/WH',
                       'order_no:'||to_char(I_order_no)||' item:'||I_item||' physical_wh:'||to_char(I_loc));
      open C_PWH_ON_ORDER;

      SQL_LIB.SET_MARK('FETCH',
                       'C_PWH_ON_ORDER',
                       'ORDLOC/WH',
                       'order_no:'||to_char(I_order_no)||' item:'||I_item||' physical_wh:'||to_char(I_loc));
      fetch C_PWH_ON_ORDER into L_pwh_on_order;

      SQL_LIB.SET_MARK('CLOSE',
                       'C_PWH_ON_ORDER',
                       'ORDLOC/WH',
                       'order_no:'||to_char(I_order_no)||' item:'||I_item||' physical_wh:'||to_char(I_loc));
      close C_PWH_ON_ORDER;

      -- Determine if deals exist for order/item/loc. If so, set program level ind
      -- so we can bypass call to invoice matching logic until all vwhs have been processed.
      if REC_COST_ADJ_SQL.CHECK_DEALS(O_error_message,
                                      L_min_cost,
                                      L_max_cost,
                                      I_order_no,
                                      L_item,
                                      I_loc) = FALSE then
         return FALSE;
      end if;
      ---
      if  (L_min_cost is not NULL)
      and (L_max_cost is not NULL)
      and (L_min_cost != L_max_cost) then
         LP_deals_exist := TRUE;
      end if;


      --- Call distribution package and retrieve L_dist_table.  Distribution will handle the
      --- case when no ordloc records exits as long as this is not an adjustment.
      if DISTRIBUTION_SQL.DISTRIBUTE(O_error_message,
                                     L_dist_table,          -- O_dist_tab: results table returned by distribution
                                     L_item,                -- L_item
                                     I_loc,                 -- I_loc: phy_loc
                                     I_qty,                 -- I_qty
                                     'ORDRCV',              -- I_CMI: calling module indicator
                                     NULL,                  -- I_inv_status
                                     NULL,                  -- I_to_loc_type,
                                     NULL,                  -- I_to_loc,
                                     I_order_no,            -- I_order_no
                                     NULL,                  -- I_shipment
                                     NULL) = FALSE then     -- I_seq_no
         return FALSE;
      end if;

      --- If no records returned on distribution table then error out
      if L_dist_table.exists(1) = FALSE then
         O_error_message := SQL_LIB.CREATE_MSG('INV_DISTRIBUTION', NULL, NULL, NULL);
         return FALSE;
      end if;

      --- For a catch-weight item only weight adjustment done in RWMS, Quantity will be zero.
      if I_qty = 0 and I_tran_type = 'A' then
         L_loc := L_dist_table(1).wh;
         L_qty := L_dist_table(1).dist_qty;
         L_dist_weight := I_weight;

         if L_qty > 0 or L_dist_weight > 0 then --OLR V1.02 Inserted

            if SMR_ORDER_RCV_SQL.RCV_LINE_ITEM(O_error_message,
                                           I_loc,             -- physical loc
                                           L_loc,             -- virtual loc
                                           LP_loc_type,
                                           I_order_no,
                                           I_item,
                                           L_qty,
                                           I_tran_type,
                                           I_tran_date,
                                           I_receipt_number,
                                           I_asn,
                                           I_appt,
                                           I_carton,
                                           I_distro_type,
                                           I_distro_number,
                                           I_destination,
                                           I_disp,
                                           I_unit_cost,
                                           I_shipped_qty,
                                           L_dist_weight,
                                           I_weight_uom,
                                           I_online_ind) = FALSE then
               return FALSE;
            end if;
         end if;  --OLR V1.02 Inserted

      else

         --- Loop through dist table, get loc/qty, then receive line item
         for i in L_dist_table.first .. L_dist_table.last LOOP
            --
            L_loc := L_dist_table(i).wh;
            L_qty := L_dist_table(i).dist_qty;

            L_dist_weight := I_weight/I_qty * L_qty;

            L_item_tbl(1).item      := I_item;
            L_item_tbl(1).need_date := I_tran_date;
            L_item_tbl(1).to_loc    := L_loc;
            L_item_tbl(1).need_qty  := L_qty;

            if CREATE_ORD_TSF_SQL.CREATE_TSF_IMP_EXP (O_error_message,
                                                     LP_tsf_no,
                                                     LP_create_tsf,
                                                     I_order_no,
                                                     L_item_tbl,
                                                     L_chrgs) = FALSE then
               return FALSE;
            end if;

            if SMR_ORDER_RCV_SQL.RCV_LINE_ITEM(O_error_message,
                                           I_loc,             -- physical loc
                                           L_loc,             -- virtual loc
                                           LP_loc_type,
                                           I_order_no,
                                           I_item,
                                           L_qty,
                                           I_tran_type,
                                           I_tran_date,
                                           I_receipt_number,
                                           I_asn,
                                           I_appt,
                                           I_carton,
                                           I_distro_type,
                                           I_distro_number,
                                           I_destination,
                                           I_disp,
                                           I_unit_cost,
                                           I_shipped_qty,
                                           L_dist_weight,
                                           I_weight_uom,
                                           I_online_ind,
                                           L_chrgs) = FALSE then
               return FALSE;
            end if;

         end LOOP;
         LP_create_tsf := 'N';
      end if;

      --- If deals exist for this order/item/loc then invoice matching logic was skipped in
      --- ON_ORDER function until all vwhs were processed
      if LP_deals_exist = TRUE and I_qty != 0 then
         if INVC_SQL.UPDATE_INVOICE(O_error_message,
                                    I_order_no,
                                    I_item,
                                    I_loc,
                                    LP_deals_shipment,
                                    I_carton,
                                    I_qty) = FALSE then
            return FALSE;
         end if;
      end if;

   else -- Its a store or MC is off

      L_item_tbl(1).item      := I_item;
      L_item_tbl(1).need_date := I_tran_date;
      L_item_tbl(1).to_loc    := I_loc;
      L_item_tbl(1).need_qty  := I_qty;

      if CREATE_ORD_TSF_SQL.CREATE_TSF_IMP_EXP (O_error_message,
                                               LP_tsf_no,
                                               LP_create_tsf,
                                               I_order_no,
                                               L_item_tbl,
                                               L_chrgs) = FALSE then
         return FALSE;
      end if;

      if SMR_ORDER_RCV_SQL.RCV_LINE_ITEM(O_error_message,
                                     I_loc,
                                     I_loc,
                                     LP_loc_type,
                                     I_order_no,
                                     I_item,
                                     I_qty,
                                     I_tran_type,
                                     I_tran_date,
                                     I_receipt_number,
                                     I_asn,
                                     I_appt,
                                     I_carton,
                                     I_distro_type,
                                     I_distro_number,
                                     I_destination,
                                     I_disp,
                                     I_unit_cost,
                                     I_shipped_qty,
                                     I_weight,
                                     I_weight_uom,
                                     I_online_ind,
                                     L_chrgs) = FALSE then
         return FALSE;
      end if;
   end if;

   -- update the weight info on shipsku table if required
   if LP_update_shipsku_weight = 'Y' then
      if SMR_ORDER_RCV_SQL.UPDATE_SHIPSKU_WEIGHT(O_error_message,
                                             LP_shipment,
                                             LP_tran_item,
                                             I_carton,
                                             LP_inv_status,
                                             LP_total_weight,
                                             LP_total_weight_uom) = FALSE then
         return FALSE;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END PO_LINE_ITEM;

-------------------------------------------------------------------------------
FUNCTION RCV_LINE_ITEM(O_error_message    IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                       I_phy_loc          IN       ITEM_LOC.LOC%TYPE,
                       I_loc              IN       ITEM_LOC.LOC%TYPE,
                       I_loc_type         IN       ITEM_LOC.LOC_TYPE%TYPE,
                       I_order_no         IN       ORDHEAD.ORDER_NO%TYPE,
                       I_item             IN       ITEM_MASTER.ITEM%TYPE,
                       I_qty              IN       TRAN_DATA.UNITS%TYPE,
                       I_tran_type        IN       VARCHAR2,               --> ADJ FLAG
                       I_tran_date        IN       DATE,
                       I_receipt_number   IN       SHIPMENT.EXT_REF_NO_IN%TYPE,
                       I_asn              IN       SHIPMENT.ASN%TYPE,
                       I_appt             IN       APPT_HEAD.APPT%TYPE,
                       I_carton           IN       SHIPSKU.CARTON%TYPE,
                       I_distro_type      IN       VARCHAR2,
                       I_distro_number    IN       TSFHEAD.TSF_NO%TYPE,
                       I_destination      IN       ALLOC_DETAIL.TO_LOC%TYPE,
                       I_disp             IN       INV_STATUS_CODES.INV_STATUS_CODE%TYPE,
                       I_unit_cost        IN       ORDLOC.UNIT_COST%TYPE,
                       I_shipped_qty      IN       SHIPSKU.QTY_EXPECTED%TYPE,
                       I_weight           IN       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE,
                       I_weight_uom       IN       UOM_CLASS.UOM%TYPE,
                       I_online_ind       IN       VARCHAR2,
                       I_upd_chrgs        IN       ITEM_EXP_DETAIL.EST_EXP_VALUE%TYPE default 0)
RETURN BOOLEAN IS

   L_function             VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.RCV_LINE_ITEM';

   L_item_rec             ITEM_RCV_RECORD;
   L_comp_items           COMP_ITEM_ARRAY;
   L_values               COST_RETAIL_QTY_RECORD;
   L_container_item_rec   ITEM_MASTER%ROWTYPE;

   L_total_cost_loc       TRAN_DATA.TOTAL_COST%TYPE;
   L_total_cost_location  TRAN_DATA.TOTAL_COST%TYPE := NULL;
   L_cycle_count          STAKE_HEAD.CYCLE_COUNT%TYPE;
   i                      BINARY_INTEGER := 0;
   L_curr_over_qty        ORDLOC.QTY_ORDERED%TYPE;
   L_new_over_qty         ORDLOC.QTY_ORDERED%TYPE;
   --- For catch weight items only
   L_weight               ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE   := NULL;  -- weight
   L_weight_uom           ITEM_SUPP_COUNTRY.COST_UOM%TYPE    := NULL;  -- weight UOM
   L_rcv_qty              TRAN_DATA.UNITS%TYPE;
   L_catchweight_pack_qty  NUMBER;
   L_receipt_date         SHIPMENT.RECEIVE_DATE%TYPE         := I_tran_date;
   L_total_cost_excl_elc  TRAN_DATA.TOTAL_COST_EXCL_ELC%TYPE;
   L_total_retail           TRAN_DATA.TOTAL_RETAIL%TYPE;
   L_average_weight_new     ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE;

   L_nominal_weight       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE   := NULL;
   L_nominal_weight_uom   ITEM_SUPP_COUNTRY.COST_UOM%TYPE    := NULL;

   L_backpost_rca_rua_ind UNIT_OPTIONS.BACKPOST_RCA_RUA_IND%TYPE;
   L_adj_complex_cost     TRAN_DATA.TOTAL_COST_EXCL_ELC%TYPE;  --OLR V1.02 Inserted patch 13029695

   cursor C_UNIT_OPTIONS is
       select NVL(backpost_rca_rua_ind,'N')
         from unit_options;

BEGIN
   --- Check for NULL values in required input
   if I_phy_loc is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_phy_loc',
                                            'NULL',
                                            'NOT_NULL ');
      return FALSE;
   elsif I_loc is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_loc',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_order_no is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_order_no',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_item is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_item',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_qty is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_qty',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_tran_type is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_tran_type',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_tran_date is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_tran_date',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_online_ind is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM',
                                            'I_online_ind',
                                            'NULL',
                                            'NOT NULL');
      return FALSE;
   elsif I_weight is NULL and I_weight_uom is NOT NULL then
      O_error_message := SQL_LIB.CREATE_MSG('WGT_WGTUOM_REQUIRED',
                                            NULL,
                                            NULL,
                                            NULL);
      return FALSE;
   elsif I_weight_uom is NULL and I_weight is NOT NULL then
      O_error_message := SQL_LIB.CREATE_MSG('WGT_WGTUOM_REQUIRED',
                                            NULL,
                                            NULL,
                                            NULL);
      return FALSE;
   end if;

   --- Move input variables into the appropriate records
   L_item_rec.phy_loc        := I_phy_loc;
   L_item_rec.loc            := I_loc;
   L_item_rec.loc_type       := I_loc_type;
   L_item_rec.order_no       := I_order_no;
   L_item_rec.input_item     := I_item;
   L_values.input_qty        := I_qty;
   L_item_rec.tran_type      := I_tran_type;
   ---set the tran_date equal to vdate if the adjusment is made on-line
   ---set the tran_date equal to I_tran_date when backpost_rca_rua_ind is 'Y'
   ---and adjustment is made online else use vdate as tran_date
   if I_tran_type = 'A' and I_online_ind = 'Y' then
      open C_UNIT_OPTIONS;
      SQL_LIB.SET_MARK('OPEN',
                        'C_UNIT_OPTIONS',
                        NULL,
                        NULL);
      fetch C_UNIT_OPTIONS into L_backpost_rca_rua_ind;
      SQL_LIB.SET_MARK('FETCH',
                        'C_UNIT_OPTIONS',
                        NULL,
                        NULL);
      close C_UNIT_OPTIONS;
      SQL_LIB.SET_MARK('CLOSE',
                        'C_UNIT_OPTIONS',
                        NULL,
                        NULL);

      if L_backpost_rca_rua_ind = 'Y' then
         L_item_rec.tran_date   := I_tran_date;
      else
         L_item_rec.tran_date   := LP_vdate;
      end if;
   else
      L_item_rec.tran_date   := I_tran_date;
   end if;
   L_item_rec.receipt_no     := I_receipt_number;
   L_item_rec.asn            := I_asn;
   L_item_rec.appt           := I_appt;
   L_item_rec.carton         := I_carton;
   L_item_rec.distro_type    := I_distro_type;
   L_item_rec.distro_number  := I_distro_number;
   L_item_rec.destination    := I_destination;
   L_item_rec.disp           := I_disp;
   L_values.unit_cost_input  := I_unit_cost;
   L_values.shipped_qty      := I_shipped_qty;
   L_values.weight           := I_weight;
   L_values.weight_uom       := I_weight_uom;
   L_item_rec.online_ind     := I_online_ind;

   --- Get info from system_options table.  Since rcv_line_item may
   --- be called directly (rather than from po_line_item), we may
   --- need to call this function here if it hasn't already been called.
   if LP_so_not_done then
      if SMR_ORDER_RCV_SQL.GET_SYSTEM_OPTIONS(O_error_message) = FALSE then
         return FALSE;
      end if;
   end if;

   --- Store the system_options currency code along with the
   --- other currency values for ease of use.
   L_values.prim_currency := LP_so_currency_code;

   --- Validate the input
   if SMR_ORDER_RCV_SQL.VALIDATE_INPUT(O_error_message,
                                   L_item_rec,
                                   L_comp_items,
                                   L_values) = FALSE then
      return FALSE;
   end if;

   --- Calculate the overage: This is the amount that has been received over
   --- the qty initially ordered; it only includes any new overage qty.
   --- The GREATEST function is used so that the curr_over_qty and new_over_qty
   --- will either be a positive number or 0.
   ---    current overage = previously received qty - ordered qty
   ---    new overage     = (previously received qty + input qty) - ordered qty
   ---    overage qty     = new overage - current overage

   L_curr_over_qty := GREATEST((L_values.ol_qty_received - L_values.ol_qty_ordered), 0);

   L_new_over_qty  := GREATEST(((L_values.ol_qty_received + L_values.input_qty) -
                                 L_values.ol_qty_ordered), 0);

   L_values.overage_qty := L_new_over_qty - L_curr_over_qty;


   /* --OLR V1.02 Delete START
   --- If the ALC records have been processed, and the new qty received is
   --- less than the qty ordered, then the ALC value needs to be backed out
   --- of the stock ledger and the ALC records need to be set back to pending
   --- status.  Skip if 'A'uto PO.
   if  (L_item_rec.online_ind != 'A') and
       (L_values.input_qty + L_values.ol_qty_received < L_values.ol_qty_ordered) and
       (LP_so_import_ind = 'Y') and (LP_so_rtm_simplified_ind = 'N') then
      if SMR_ORDER_RCV_SQL.ALC_PROCESSING(O_error_message,
                                          L_item_rec,
                                          L_comp_items,
                                          L_values) = FALSE then
         return FALSE;
      end if;
   end if;
   --OLR V1.02 Delete END*/

   if L_item_rec.pack_ind = 'N' then

      -- Assign unit_cost exclusive of ELC to variable
      -- to update column total_cost_excl_elc in tran_data for tran_code = 20
      L_total_cost_excl_elc := L_values.input_qty * L_values.unit_cost_loc;

      if SMR_ORDER_RCV_SQL.SET_AV_COST_OTB_COST(O_error_message,
                                                L_values,                 -- IO_values record
                                                NULL,                     -- I_pack_no
                                                L_item_rec.item,          -- I_item
                                                NULL,                     -- I_comp_item
                                                NULL,                     -- I_comp_unit_cost_loc
                                                L_item_rec) = FALSE then  -- I_item_rec record
         return FALSE;
      end if;

      -- online_ind can be 'Y','N', or 'A'.
      if (L_item_rec.online_ind != 'A') then    -- 'A' is auto PO
         --- Update otb records

         DECLARE
            L_rib_otb_rec  "RIB_OTB_REC" := NULL;
         BEGIN
            L_rib_otb_rec                          := "RIB_OTB_REC" (NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
            L_rib_otb_rec.po_nbr                   := L_item_rec.order_no;
            L_rib_otb_rec.dept                     := L_item_rec.dept;
            L_rib_otb_rec.class                    := L_item_rec.class;
            L_rib_otb_rec.subclass                 := L_item_rec.subclass;
            L_rib_otb_rec.unit_retail              := L_values.unit_retail_prim;
            L_rib_otb_rec.unit_cost                := L_values.otb_cost_prim;
            L_rib_otb_rec.receipt_qty              := L_values.input_qty;
            L_rib_otb_rec.approved_qty             := L_values.overage_qty;
            LP_rib_otb_tbl.EXTEND;
            LP_rib_otb_tbl(LP_rib_otb_tbl.COUNT)   := L_rib_otb_rec;
         END;
      end if;

      --- Check back posted transactions for processed stock counts.
      --- for online transactions.  Use date passed in from XML for external system transactions.
      if L_receipt_date < LP_vdate then
         if STKCNT_ATTRIB_SQL.STOCK_COUNT_PROCESSED(O_error_message,
                                                    L_values.stock_count_processed,
                                                    L_cycle_count,
                                                    L_values.snapshot_cost,
                                                    L_values.snapshot_retail,
                                                    L_receipt_date,
                                                    L_item_rec.item,
                                                    L_item_rec.loc_type,
                                                    L_item_rec.loc) = FALSE then
            return FALSE;
         end if;
      end if;

      if SMR_ORDER_RCV_SQL.UPDATE_ITEM_STOCK(O_error_message,
                                         L_values.neg_soh_ac,
                                         L_values.negative_soh,
                                         L_item_rec.item,
                                         'N',
                                         L_item_rec.loc,
                                         L_values.input_qty,
                                         NULL,              --- I_weight
                                         NULL,              --- I_weight_uom
                                         L_values.av_cost_loc + I_upd_chrgs,
                                         L_total_cost_loc,  --- NULL except catch weight simple packs
                                         L_item_rec.tran_date,
                                         L_item_rec.tran_type,
                                         L_values.upd_unit_cost,
                                         L_values.stock_count_processed,
                                         L_item_rec.new_ordloc_ind,
                                         L_values.receive_as_type,
                                         L_item_rec.inv_status,
                                         L_item_rec.loc_type,
                                         L_item_rec.order_no,
                                         L_values.unit_retail_loc) = FALSE then
         return FALSE;
      end if;

      L_total_cost_loc := L_values.input_qty * L_values.av_cost_loc;
      if SMR_ORDER_RCV_SQL.STOCKLEDGER_INFO(O_error_message,
                                        L_values.neg_soh_ac,
                                        L_values.negative_soh,
                                        L_total_cost_loc,
                                        L_item_rec.item,
                                        L_item_rec.pack_ind,
                                        L_values.receive_as_type,
                                        L_item_rec.dept,
                                        L_item_rec.class,
                                        L_item_rec.subclass,
                                        L_item_rec.tran_date,
                                        L_item_rec.tran_type,
                                        L_values.input_qty,
                                        L_values.input_qty * L_values.unit_retail_loc,
                                        L_item_rec.ship_no,
                                        L_item_rec.order_no,
                                        L_values.stock_count_processed,
                                        L_values.snapshot_cost,
                                        L_values.snapshot_retail,
                                        L_item_rec.loc,
                                        L_item_rec.loc_type,
                                        NULL,                       -- I_ref_pack_no
                                        L_total_cost_excl_elc) = FALSE then
         return FALSE;
      end if;

      if L_item_rec.tran_type = 'A' then

         if NWP_UPDATE_SQL.UPDATE_NWP_RECORD(O_error_message
                                           , L_item_rec.item        -- component item
                                           , L_item_rec.item        -- component item (as this is not at pack level)
                                           , L_item_rec.loc
                                           , L_item_rec.loc_type
                                           , L_item_rec.order_no
                                           , L_item_rec.ship_no
                                           , L_item_rec.tran_date   -- I_receipt_date
                                           , NULL                   -- I_receipt_quantity (not required for unit adjust)
                                           , NULL                   -- I_receipt_cost (not required for unit adjust)
                                           , NULL                   -- I_cost_adjust_amt (not required for unit adjust)
                                           , ROUND(L_values.input_qty,4)    -- unit adjustment
                                           , NULL                  -- I_ord_currency (not required for unit adjust)
                                           , NULL                  -- I_loc_currency (not required for unit adjust)
                                           , NULL                  -- I_ord_exchange_rate (not required for unit adjust)
                                           , 'PO'                  -- Purchase Order
                                               ) =  FALSE then
            return FALSE;
          end if;
       else -- not an adjustment

          if NWP_UPDATE_SQL.UPDATE_NWP_RECORD(O_error_message
                                           , L_item_rec.item                 -- component item
                                           , L_item_rec.item                 -- component item (as this is not at pack level)
                                           , L_item_rec.loc
                                           , L_item_rec.loc_type
                                           , L_item_rec.order_no
                                           , L_item_rec.ship_no
                                           , L_item_rec.tran_date            -- I_receipt_date
                                           , ROUND(L_values.input_qty,4)     -- I_receipt_quantity
                                           , ROUND(L_values.unit_cost_loc,4) -- I_receipt_cost
                                           , NULL                            -- I_cost_adjust_amt
                                           , NULL                            -- unit adjustment
                                           , L_values.ord_currency           -- I_ord_currency
                                           , L_values.loc_currency           -- I_loc_currency
                                           , L_values.ord_exchange_rate      -- I_ord_exchange_rate
                                           , 'PO'                            -- Purchase Order
                              ) =  FALSE then
                return FALSE;
           end if;
        end if;   -- nwp processing for non pack items

   else -- item is a pack

      if L_item_rec.pack_type = 'V' then

         if LP_so_elc_ind = 'Y' then

            --- If item is a vendor pack and landed cost is used then
            --- get the total landed cost in local currency
            if SMR_ORDER_RCV_SQL.GET_ELC_TOTAL_LOC(O_error_message,                        -- O_error_message
                                               L_values.total_lc_loc,                  -- O_elc_loc
                                               L_item_rec,                             -- I_item_rec
                                               L_values,                               -- I_values
                                               L_item_rec.item,                        -- I_item
                                               NULL,                                   -- I_comp_item
                                               L_values.unit_cost_order) = FALSE then  -- I_unit_cost_ord
               return FALSE;
            end if;

         else -- elc is off

            --- If item is a vendor pack and landed cost is not used
            --- then total landed cost will be the unit cost in local currency.
            L_values.total_lc_loc := L_values.unit_cost_loc;

         end if;  -- LP_so_elc_ind

      end if;  -- pack_type = 'V'

      -- Check for catch weight simple pack: get total weight and total cost.
      -- Since a simple pack catch weight item contains only 1 component item,
      -- the total weight and total cost of the pack is the same as
      -- the total weight and total cost of the component item.
      ---
      -- For fixed weight Simple pack Items the Default values should be taken
      -- as nominal weight if input weight and weight uom passed as null
      ---
      if L_item_rec.catch_weight_ind = 'Y' and
         L_item_rec.simple_pack_ind = 'Y'  then
         if I_weight is NOT NULL and I_weight_uom is NOT NULL then
            L_weight     := I_weight;
            L_weight_uom := I_weight_uom;
            LP_total_weight     := NVL(I_weight,0);
            LP_total_weight_uom := I_weight_uom;
         else
            if ITEM_SUPP_COUNTRY_DIM_SQL.GET_NOMINAL_WEIGHT_UOM(O_error_message,
                                                                L_nominal_weight,
                                                                L_nominal_weight_uom,
                                                                L_item_rec.item) = FALSE then
               return FALSE;
            end if;

            LP_update_shipsku_weight := 'Y';
            LP_total_weight          := NVL(LP_total_weight,0) + (L_nominal_weight * L_values.input_qty);
            LP_total_weight_uom      := L_nominal_weight_uom;

            L_weight                 := L_nominal_weight * L_values.input_qty;
            L_weight_uom             := L_nominal_weight_uom;
         end if;

         -- keep track of these global variables for updating shipsku weight info later
         LP_shipment         := L_item_rec.ship_no;
         LP_tran_item        := L_item_rec.item;
         LP_inv_status       := L_item_rec.inv_status;

         --- Get Total cost based on weight
         if CATCH_WEIGHT_SQL.CALC_TOTAL_COST(O_error_message,
                                             L_total_cost_excl_elc,       -- returns weight-based total cost in loc currency
                                             L_item_rec.item,        -- pack
                                             I_loc,
                                             I_loc_type,
                                             L_values.unit_cost_loc, -- pack unit cost in loc currency
                                             L_values.input_qty,     -- pack qty
                                             L_weight,               -- total weight
                                             L_weight_uom) = FALSE then
            return FALSE;
         end if;
         L_catchweight_pack_qty := L_total_cost_excl_elc / L_values.unit_cost_loc;
         L_total_cost_loc := L_values.total_lc_loc * L_catchweight_pack_qty; -- includes ELC
      else
         L_catchweight_pack_qty := L_values.input_qty;
         L_total_cost_loc := NULL;
      end if;

      if SMR_ORDER_RCV_SQL.PACK_LEVEL_UPDATES(O_error_message,
                                          L_values,
                                          L_item_rec,
                                          L_weight,
                                          L_weight_uom) = FALSE then
         return FALSE;
      end if;

      --OLR V1.02 Inserted START patch 13029695
      if PACKITEM_VALIDATE_SQL.CHECK_DEPOSIT_COMPLEX(O_error_message, -- O_error_message
                                                     L_deposit_complex_ind, -- O_deposit_ind
                                                     L_item_rec.item) = FALSE then -- I_pack_no
         return FALSE;
      end if;
      --OLR V1.02 Inserted END patch 13029695

      --- Loop on the pack's comp items
      FOR i IN L_comp_items.FIRST..L_comp_items.LAST LOOP
         if SMR_ORDER_RCV_SQL.SET_AV_COST_OTB_COST(O_error_message,
                                               L_values,                        -- IO_values record
                                               L_item_rec.item,                 -- I_pack_no
                                               NULL,                            -- I_item
                                               L_comp_items(i).item,            -- I_comp_item
                                               L_comp_items(i).unit_cost_loc,   -- I_comp_unit_cost_loc
                                               L_item_rec) = FALSE then         -- I_item_rec
            return FALSE;
         end if;

         if (L_item_rec.online_ind != 'A') then     -- 'A' is auto PO
            --- Update otb records
            DECLARE
               L_rib_otb_rec  "RIB_OTB_REC" := NULL;
            BEGIN
               L_rib_otb_rec                        := "RIB_OTB_REC" (NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
               L_rib_otb_rec.po_nbr                 := L_item_rec.order_no;
               L_rib_otb_rec.dept                   := L_comp_items(i).dept;
               L_rib_otb_rec.class                  := L_comp_items(i).class;
               L_rib_otb_rec.subclass               := L_comp_items(i).subclass;
               L_rib_otb_rec.unit_retail            := L_comp_items(i).unit_retail_prim;
               L_rib_otb_rec.unit_cost              := L_values.otb_cost_prim;
               L_rib_otb_rec.receipt_qty            := L_values.input_qty * L_comp_items(i).qty;
               L_rib_otb_rec.approved_qty           := L_values.overage_qty * L_comp_items(i).qty;
               LP_rib_otb_tbl.EXTEND;
               LP_rib_otb_tbl(LP_rib_otb_tbl.COUNT) := L_rib_otb_rec;
            END;
         end if;

         --- Check back posted transactions for processed stock counts.
         --- for online transactions.  Use date passed in from XML for external system transactions.
         if L_receipt_date < LP_vdate then
            if STKCNT_ATTRIB_SQL.STOCK_COUNT_PROCESSED(O_error_message,
                                                       L_values.stock_count_processed,
                                                       L_cycle_count,
                                                       L_values.snapshot_cost,
                                                       L_values.snapshot_retail,
                                                       L_receipt_date,
                                                       L_comp_items(i).item,
                                                       L_item_rec.loc_type,
                                                       L_item_rec.loc) = FALSE then
               return FALSE;
            end if;
         end if;

         if L_comp_items(i).inventory_ind != 'N' then

            if SMR_ORDER_RCV_SQL.UPDATE_ITEM_STOCK(O_error_message,
                                               L_values.neg_soh_ac,
                                               L_values.negative_soh,
                                               L_comp_items(i).item,
                                               'Y',                                      -- comp_ind
                                               L_item_rec.loc,
                                               L_comp_items(i).qty * L_values.input_qty,
                                               L_weight,
                                               L_weight_uom,
                                               L_values.av_cost_loc,
                                               L_total_cost_loc,                         --- NOT NULL for catch weight packs only
                                               L_item_rec.tran_date,
                                               L_item_rec.tran_type,
                                               L_values.upd_unit_cost,
                                               L_values.stock_count_processed,
                                               L_item_rec.new_ordloc_ind,
                                               L_values.receive_as_type,
                                               L_item_rec.inv_status,
                                               L_item_rec.loc_type,
                                               L_item_rec.order_no,
                                               L_values.unit_retail_loc) = FALSE then
               return FALSE;
            end if;
         end if;
         if L_item_rec.catch_weight_ind = 'Y' and
            L_item_rec.simple_pack_ind = 'Y'  then
            ---
            -- For a simple pack catch weight item, there are two scenarioes:
            -- 1) the component item's standard UOM is weight, then ITEM_LOC_SOH and TRAN_DATA qty should be
            -- updated with the actual weight converted to component item's SUOM.
            -- 2) the component item's standard UOM is Eaches, then ITEM_LOC_SOH and TRAN_DATA qty should be
            -- updated based on v_packsku_qty.
            ---
            -- For catchweight items L_total_cost_location will be null and the cost will be L_total_cost_loc
            L_total_cost_location := L_total_cost_loc;

            if CATCH_WEIGHT_SQL.CALC_COMP_UPDATE_QTY(O_error_message,
                                                     L_rcv_qty,
                                                     L_comp_items(i).item,
                                                     L_values.input_qty * L_comp_items(i).qty,
                                                     L_weight,
                                                     L_weight_uom) = FALSE then
               return FALSE;
            end if;
            --- Retail calculation to calculate retail according to weight
            if CATCH_WEIGHT_SQL.CALC_TOTAL_RETAIL(O_error_message,
                                                  L_comp_items(i).item,
                                                  L_rcv_qty,
                                                  L_comp_items(i).unit_retail_loc,
                                                  L_item_rec.loc,
                                                  L_item_rec.loc_type,
                                                  L_weight,
                                                  L_weight_uom,
                                                  L_total_retail) = FALSE then
               return FALSE;
            end if;

         --- If the item is a simple pack,only then divisor is substituted as 1 to avoid divide by zero error
         elsif L_item_rec.simple_pack_ind = 'Y'  then
               L_rcv_qty := L_values.input_qty * L_comp_items(i).qty;
               L_total_cost_location := L_comp_items(i).qty * L_values.input_qty * L_values.av_cost_loc;
               if L_values.pack_cost_loc = 0 then
                  L_values.pack_cost_loc := 1;
               end if;
               L_total_cost_excl_elc := L_values.input_qty * L_comp_items(i).qty * L_values.unit_cost_loc *
                                        (L_comp_items(i).unit_cost_loc / L_values.pack_cost_loc);
               L_total_retail        := L_rcv_qty * L_comp_items(i).unit_retail_loc;
         else
            L_rcv_qty := L_values.input_qty * L_comp_items(i).qty;
            L_total_cost_location := L_comp_items(i).qty * L_values.input_qty * L_values.av_cost_loc;
            L_total_cost_excl_elc := L_values.input_qty * L_comp_items(i).qty * L_values.unit_cost_loc *
                                     (L_comp_items(i).unit_cost_loc / L_values.pack_cost_loc);

            --OLR V1.02 Inserted START patch 13029695
            if L_deposit_complex_ind = 'Y' then
               L_adj_complex_cost := L_values.unit_cost_loc;

               if SMR_ORDER_RCV_SQL.GET_COMPLEX_ADJ_COST(O_error_message,
                                                     L_adj_complex_cost,
                                                     L_item_rec.item,
                                                     L_comp_items(i).item,
                                                     NVL(L_item_rec.loc,L_item_rec.phy_loc),
                                                     L_item_rec.supplier) = FALSE then
                  return FALSE;
               end if;

               L_total_cost_excl_elc := L_values.input_qty * L_comp_items(i).qty * L_adj_complex_cost;
            end if;
            --OLR V1.02 Inserted END patch 13029695

            L_total_retail        := L_rcv_qty * L_comp_items(i).unit_retail_loc;
         end if;

         if SMR_ORDER_RCV_SQL.STOCKLEDGER_INFO(O_error_message,
                                           L_values.neg_soh_ac,
                                           L_values.negative_soh,
                                           L_total_cost_location,
                                           L_comp_items(i).item,
                                           L_item_rec.pack_ind,
                                           L_values.receive_as_type,
                                           L_comp_items(i).dept,
                                           L_comp_items(i).class,
                                           L_comp_items(i).subclass,
                                           L_item_rec.tran_date,
                                           L_item_rec.tran_type,
                                           L_rcv_qty,
                                           L_total_retail,
                                           L_item_rec.ship_no,
                                           L_item_rec.order_no,
                                           L_values.stock_count_processed,
                                           L_values.snapshot_cost,
                                           L_values.snapshot_retail,
                                           L_item_rec.loc,
                                           L_item_rec.loc_type,
                                           L_item_rec.item,
                                           L_total_cost_excl_elc) = FALSE then
            return FALSE;
         end if;

         if L_item_rec.tran_type = 'A' then

            if Nwp_update_sql.UPDATE_NWP_RECORD(O_error_message
                                              , L_comp_items(i).item   -- component item
                                              , L_item_rec.item        -- pack item
                                              , L_item_rec.loc
                                              , L_item_rec.loc_type
                                              , L_item_rec.order_no
                                              , L_item_rec.ship_no
                                              , L_item_rec.tran_date   -- I_receipt_date
                                              , NULL                   -- I_receipt_quantity (not required for unit adjust)
                                              , NULL                   -- I_receipt_cost (not required for unit adjust)
                                              , NULL                   -- I_cost_adjust_amt (not required for unit adjust)
                                              , ROUND(L_rcv_qty,4)     -- unit adjustment for components
                                              , NULL                   -- I_ord_currency (not required for unit adjust)
                                              , NULL                   -- I_loc_currency (not required for unit adjust)
                                              , NULL                   -- I_ord_exchange_rate (not required for unit adjust)
                                              , 'PO'                   -- Purchase Order
                                                  ) =  FALSE then
               return FALSE;
            end if;
          else -- not an adjustment

             if NWP_UPDATE_SQL.UPDATE_NWP_RECORD ( O_error_message
                                                 , L_comp_items(i).item                               -- component item
                                                 , L_item_rec.item                                    -- pack item
                                                 , L_item_rec.loc
                                                 , L_item_rec.loc_type
                                                 , L_item_rec.order_no
                                                 , L_item_rec.ship_no
                                                 , L_item_rec.tran_date                               -- I_receipt_date
                                                 , ROUND(L_rcv_qty,4)                                 -- I_receipt_quantity
                                                 , ROUND(L_values.av_cost_loc,4)                      -- I_receipt_cost
                                                 , NULL                                               -- I_cost_adjust_amt
                                                 , NULL                                               -- unit adjustment
                                                 , L_values.ord_currency                              -- I_ord_currency
                                                 , L_values.loc_currency                              -- I_loc_currency
                                                 , L_values.ord_exchange_rate                         -- I_ord_exchange_rate
                                                 , 'PO'                                               -- Purchase Order
                                                   ) =  FALSE then
                   return FALSE;
              end if;
           end if;   -- nwp processing for pack items

      END LOOP;

   end if; -- pack ind

   if (L_item_rec.pack_ind = 'Y' and L_item_rec.loc_type = 'W' and L_values.receive_as_type = 'P') then
      --- If receiving into trouble (non-sellable) move the stock to trouble
      if (L_item_rec.inv_status is NOT NULL) and
         (L_item_rec.inv_status != -1) then
         if UPD_INV_STATUS(O_error_message,
                           L_item_rec.item,
                           L_item_rec.inv_status,
                           L_values.input_qty,
                           L_total_cost_loc,                                -- I_total_cost
                           L_values.input_qty * L_values.unit_retail_loc,   -- I_total_retail
                           L_item_rec.loc,
                           L_item_rec.loc_type,
                           L_item_rec.tran_date,
                           L_item_rec.order_no) = FALSE then                -- I_order_no
            return FALSE;
         end if;
      end if;
   end if;

   --- Write records to sup_data table
   if L_item_rec.catch_weight_ind = 'Y' and L_item_rec.simple_pack_ind = 'Y' then
      if SMR_ORDER_RCV_SQL.SUP_DATA_INSERTS(O_error_message,
                                        L_item_rec.supplier,
                                        L_item_rec.dept,
                                        L_item_rec.tran_date,
                                        L_catchweight_pack_qty * L_values.unit_cost_prim,     -- both in primary currency
                                        L_values.input_qty * L_values.unit_retail_prim) = FALSE then
         return FALSE;
      end if;
   else
      if SMR_ORDER_RCV_SQL.SUP_DATA_INSERTS(O_error_message,
                                        L_item_rec.supplier,
                                        L_item_rec.dept,
                                        L_item_rec.tran_date,
                                        L_values.input_qty * L_values.unit_cost_prim,     -- both in primary currency
                                        L_values.input_qty * L_values.unit_retail_prim) = FALSE then
         return FALSE;
      end if;
   end if;

   --- Update contract info if this is not an 'A'uto PO and a contract number exists.
   if L_item_rec.online_ind != 'A' and L_values.cont_no IS NOT NULL then

      if SMR_ORDER_RCV_SQL.CHECK_AGAINST_CONTRACT(O_error_message,
                                              L_values,
                                              L_item_rec) = FALSE then
         return FALSE;
      end if;

   end if;

   --- If not an auto PO then call invoice processing
   if L_item_rec.online_ind != 'A' then
      if SMR_ORDER_RCV_SQL.INVC_PROCESSING(O_error_message,
                                       L_values,
                                       L_item_rec) = FALSE then
         return FALSE;
      end if;
   end if;

   --- Request tickets to be printed if location is a store
   if L_item_rec.loc_type = 'S' then
      if TICKET_SQL.RECEIVE(O_error_message,
                            L_item_rec.order_no,
                            L_item_rec.item,
                            L_item_rec.loc,
                            L_values.input_qty,
                            'N') = FALSE then
         return FALSE;
      end if;
   end if;

   --- Handle investment buy stuff
   if SMR_ORDER_RCV_SQL.IB_LINK(O_error_message,
                            L_item_rec) = FALSE then
      return FALSE;
   end if;

   --- If this is an adjustment to a closed order, set status back to 'A'pproved
   if L_item_rec.tran_type = 'A' then
      if SMR_ORDER_RCV_SQL.OPEN_ORDER(O_error_message,
                                  L_item_rec.order_no) = FALSE then
         return FALSE;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END RCV_LINE_ITEM;

-------------------------------------------------------------------------------

FUNCTION RECEIVE_AUTO_PO(O_error_message   IN OUT   VARCHAR2,
                         I_order_no        IN       SHIPMENT.ORDER_NO%TYPE,
                         I_shipment        IN       SHIPMENT.SHIPMENT%TYPE,
                         I_location        IN       ITEM_LOC.LOC%TYPE,
                         I_tran_date       IN       DATE)
RETURN BOOLEAN IS

   L_function   VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.RECEIVE_AUTO_PO';
   L_exists     BOOLEAN;

   cursor C_SHIPSKU is
      select s.order_no,
             s.asn,
             s.to_loc,
             s.ext_ref_no_in,
             --
             ss.item,
             ss.carton,
             ss.qty_expected,
             ss.weight_expected,
             ss.weight_expected_uom
        from shipment s,
             shipsku ss
       where ss.shipment = s.shipment
         and s.shipment = I_shipment;

BEGIN

   ---  Assumption: The location passed to this function is always a store.
   ---              Thus, there is no multi-channel logic in this function.

   --- Check for NULL values
   if I_order_no is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM','I_order_no','NULL','NOT NULL');
      return FALSE;
   elsif I_shipment is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM','I_shipment','NULL','NOT_NULL ');
      return FALSE;
   elsif I_location is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM','I_location','NULL','NOT_NULL ');
      return FALSE;
   elsif I_tran_date is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INVALID_PARM','I_tran_date','NULL','NOT NULL');
      return FALSE;
   end if;

   --- Validate the location is a store
   if STORE_VALIDATE_SQL.EXIST(O_error_message,
                               I_location,
                               L_exists) = FALSE then
      return FALSE;
   end if;
   ---
   if L_exists = FALSE then
      O_error_message := SQL_LIB.CREATE_MSG('INV_STORE',I_location,NULL,NULL);
      return FALSE;
   end if;

   if INIT_PO_ASN_LOC_GROUP(O_error_message) = FALSE then
      return FALSE;
   end if;

   --- Loop through each item on shipsku and receive
   for rec in C_SHIPSKU LOOP

      if SMR_ORDER_RCV_SQL.PO_LINE_ITEM(O_error_message,
                                    I_location,        -- I_loc
                                    I_order_no,        -- I_order_no
                                    rec.item,          -- I_item
                                    rec.qty_expected,  -- I_qty
                                    'R',               -- I_tran_type = 'R'eceipt
                                    I_tran_date,       -- I_tran_date
                                    rec.ext_ref_no_in, -- I_receipt_number
                                    rec.asn,           -- I_asn
                                    NULL,              -- I_appt
                                    rec.carton,        -- I_carton
                                    NULL,              -- I_distro_type
                                    NULL,              -- I_distro_number
                                    NULL,              -- I_destination
                                    NULL,              -- I_disp
                                    NULL,              -- I_unit_cost
                                    NULL,              -- I_shipped_qty
                                    rec.weight_expected,
                                    rec.weight_expected_uom,
                                    'A') = FALSE then  -- I_online_ind = 'A'uto
         return FALSE;
      end if;

   end LOOP;

   ---  Assumption: OTB logic will never be generated from RECEIVE_AUTO_PO
   if FINISH_PO_ASN_LOC_GROUP(O_error_message,
                              LP_rib_otb_tbl) = FALSE then
      return FALSE;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END RECEIVE_AUTO_PO;



-------------------------------------------------------------------------------
--                                                                           --
--                             PRIVATE FUNCTIONS                             --
--                                                                           --
-------------------------------------------------------------------------------


FUNCTION VALIDATE_INPUT(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                        I_item_rec        IN OUT   ITEM_RCV_RECORD,
                        I_comp_items      IN OUT   COMP_ITEM_ARRAY,
                        I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function    VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.VALIDATE_INPUT';
   L_uom_class   UOM_CLASS.UOM_CLASS%TYPE;

BEGIN

   --- 'R'eceipts and 'A'djustments are the only tran types processed by SMR_ORDER_RCV_SQL
   if (I_item_rec.tran_type not in ('R','A')) then
      O_error_message := SQL_LIB.CREATE_MSG('INV_TRAN_TYPE', NULL, NULL, NULL);
      return FALSE;
   end if;

   --- Negative quantities are only accepted for adjustments, not receipts.
   if  (I_item_rec.tran_type = 'R')
   and (I_values.input_qty <= 0) then
      O_error_message := SQL_LIB.CREATE_MSG('PO_RECEIPT_GT_ZERO,'||I_values.input_qty||','||I_item_rec.item, NULL, NULL, NULL);
      return FALSE;
   end if;
   ---
   if I_values.weight_uom is NOT NULL then
      if not UOM_SQL.GET_CLASS(O_error_message,
                               L_uom_class,
                               UPPER(I_values.weight_uom)) then
         return FALSE;
      end if;

      if L_uom_class != 'MASS' then
         O_error_message := SQL_LIB.CREATE_MSG('INV_WGTUOM_CLASS',
                                               I_values.weight_uom, L_uom_class, NULL);
         return FALSE;
      end if;
   end if;


   --- Save loc_currency in the record with the other currencies for consistency
   I_values.loc_currency := LP_loc_currency;

   --- Validate item and get item_master info
   if SMR_ORDER_RCV_SQL.ITEM_CHECK(O_error_message,
                               I_item_rec) = FALSE then
      return FALSE;
   end if;

   --- Validate order and get info
   if SMR_ORDER_RCV_SQL.ORD_CHECK(O_error_message,
                              I_item_rec,
                              I_values) = FALSE then
      return FALSE;
   end if;

   --- Adjustments must be against approved or closed orders
   if (I_item_rec.tran_type = 'A' and I_item_rec.order_status not in ('A','C')) then
      O_error_message := SQL_LIB.CREATE_MSG('ADJ_ORD_STATUS', NULL, NULL, NULL);
      return FALSE;
   end if;

   --- Receipts must be against approved or closed orders
   if (I_item_rec.tran_type = 'R' and I_item_rec.order_status not in ('A','C')) then
      O_error_message := SQL_LIB.CREATE_MSG('RCPT_ORD_STAT_WS_SUB', NULL, NULL, NULL);
      return FALSE;
   end if;

   --- Check / update appt detail
   if SMR_ORDER_RCV_SQL.APPT_CHECK(O_error_message,
                               I_item_rec,
                               I_values) = FALSE then
      return FALSE;
   end if;

   --- Check shipment, create if needed
   if SMR_ORDER_RCV_SQL.SHIP_CHECK(O_error_message,
                               I_item_rec,
                               I_values) = FALSE then
      return FALSE;
   end if;

   --- If deals exist for this order/item/loc then save this shipment for call
   --- to invoice matching logic after all vwhs are processed
   if LP_deals_exist = TRUE then
      LP_deals_shipment := I_item_rec.ship_no;
   end if;

   --- Make sure item/loc exists on order, add if needed
   if SMR_ORDER_RCV_SQL.ON_ORDER(O_error_message,
                             I_item_rec,
                             I_values) = FALSE then
      return FALSE;
   end if;

   --- If item is a pack, get the component info
   if I_item_rec.pack_ind = 'Y' then
      if SMR_ORDER_RCV_SQL.LOAD_COMPS(O_error_message,
                                  I_item_rec,
                                  I_comp_items,
                                  I_values) = FALSE then
         return FALSE;
      end if;
   end if;

   --- If this is an allocation then update alloc_detail with the receipt qty.
   if LP_so_multichannel_ind = 'Y' and I_item_rec.loc_type = 'W' and I_item_rec.distro_type = 'A' then
      if SMR_ORDER_RCV_SQL.UPDATE_ALLOC(O_error_message,
                                        I_item_rec.distro_number,
                                        I_item_rec.destination,
                                        I_values.input_qty) = FALSE then
         return FALSE;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END VALIDATE_INPUT;

-------------------------------------------------------------------------------

FUNCTION ITEM_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN OUT   ITEM_RCV_RECORD)
RETURN BOOLEAN IS

   L_function     VARCHAR2(60)   := 'SMR_ORDER_RCV_SQL.ITEM_CHECK';
   L_rowid        ROWID          := NULL;
   L_valid_item   BOOLEAN        := FALSE;

   cursor C_ITEM_EXIST is
      select im1.rowid,
             im1.item,
             im1.item_level,
             im1.tran_level,
             im1.diff_1,
             im1.diff_2,
             im1.diff_3,
             im1.diff_4,
             im1.item_parent,
             im1.item_grandparent,
             im1.dept,
             im1.class,
             im1.subclass,
             im1.pack_ind,
             im1.sellable_ind,
             im1.orderable_ind,
             im1.inventory_ind,
             NVL(im1.pack_type, 'N'),   --- N indicates NULL, not a buyer or vendor pack
             im1.standard_uom,
             im1.simple_pack_ind,
             im1.catch_weight_ind,
             im1.deposit_item_type,
             im1.container_item
        from item_master im1,
             item_master im2
       where (im2.item       = I_item_rec.input_item and
              im2.item_level = im2.tran_level and
              im1.item       = im2.item)
          or (im2.item       = I_item_rec.input_item and
              im2.item_level = im2.tran_level + 1 and
              im1.item       = im2.item_parent);

BEGIN

   --- Get item master info for transaction level item which may be
   --- different than the input_item.
   SQL_LIB.SET_MARK('OPEN','C_ITEM_EXIST','ITEM_MASTER','Item:'||I_item_rec.input_item);
   open C_ITEM_EXIST;
   fetch C_ITEM_EXIST into L_rowid,
                           I_item_rec.item,
                           I_item_rec.item_level,
                           I_item_rec.tran_level,
                           I_item_rec.diff_1,
                           I_item_rec.diff_2,
                           I_item_rec.diff_3,
                           I_item_rec.diff_4,
                           I_item_rec.item_parent,
                           I_item_rec.item_grandparent,
                           I_item_rec.dept,
                           I_item_rec.class,
                           I_item_rec.subclass,
                           I_item_rec.pack_ind,
                           I_item_rec.sellable_ind,
                           I_item_rec.orderable_ind,
                           I_item_rec.inventory_ind,
                           I_item_rec.pack_type,
                           I_item_rec.suom,
                           I_item_rec.simple_pack_ind,
                           I_item_rec.catch_weight_ind,
                           I_item_rec.deposit_item_type,
                           I_item_rec.container_item;
   close C_ITEM_EXIST;
   ---
   if L_rowid is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INV_ITEM', NULL, NULL, NULL);
      return FALSE;
   end if;
   ---
   if I_item_rec.orderable_ind = 'Y' and
         I_item_rec.sellable_ind  = 'N' and
         I_item_rec.inventory_ind = 'N' then
         O_error_message := SQL_LIB.CREATE_MSG('NO_NONINVENT_ITEM', NULL, NULL, NULL);
         return FALSE;
   end if;

   --- If not online, then convert disposition to inventory status
   if I_item_rec.disp is NOT NULL  then
      if INVADJ_SQL.GET_INV_STATUS(O_error_message,
                                   I_item_rec.inv_status,
                                   I_item_rec.disp) = FALSE then
         return FALSE;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END ITEM_CHECK;

-------------------------------------------------------------------------------

FUNCTION GET_SYSTEM_OPTIONS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE)
RETURN BOOLEAN IS

   L_function             VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.GET_SYSTEM_OPTIONS';
   L_system_options_rec   SYSTEM_OPTIONS%ROWTYPE;

BEGIN

   if SYSTEM_OPTIONS_SQL.GET_SYSTEM_OPTIONS(O_error_message,
                                            L_system_options_rec) = FALSE then
      return FALSE;
   end if;

   LP_so_multichannel_ind      := L_system_options_rec.multichannel_ind;
   LP_so_std_av_ind            := L_system_options_rec.std_av_ind;
   LP_so_elc_ind               := L_system_options_rec.elc_ind;
   LP_so_import_ind            := L_system_options_rec.import_ind;
   LP_so_currency_code         := L_system_options_rec.currency_code;
   LP_so_ext_invc_match_ind    := L_system_options_rec.ext_invc_match_ind;
   LP_so_rtm_simplified_ind    := L_system_options_rec.rtm_simplified_ind;
   LP_so_mult_set_of_books_ind := L_system_options_rec.multiple_set_of_books_ind;

   LP_so_not_done := FALSE;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END GET_SYSTEM_OPTIONS;

-------------------------------------------------------------------------------

FUNCTION ORD_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                   I_item_rec        IN OUT   ITEM_RCV_RECORD,
                   I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function  VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.ORD_CHECK';

BEGIN

   if I_item_rec.order_no != NVL(LP_header_lookup_record.ord_check_order_no,-1) then

      -- different order, lookup values
      if GET_ORD_INFO(O_error_message,
                      I_item_rec.order_no) = FALSE then
         return FALSE;
      end if;

      LP_header_lookup_record.ord_check_order_no := I_item_rec.order_no;

   end if;

   I_item_rec.order_status       := LP_header_lookup_record.ord_check_order_status;
   I_item_rec.order_orig_ind     := LP_header_lookup_record.ord_check_order_orig_ind;
   I_item_rec.supplier           := LP_header_lookup_record.ord_check_supplier;
   I_values.ord_currency         := LP_header_lookup_record.ord_check_ord_currency;
   I_values.ord_exchange_rate    := LP_header_lookup_record.ord_check_ord_exchange_rate;
   I_item_rec.earliest_ship_date := LP_header_lookup_record.ord_check_earliest_ship_date;
   I_item_rec.latest_ship_date   := LP_header_lookup_record.ord_check_latest_ship_date;
   I_item_rec.import_country_id  := LP_header_lookup_record.ord_check_import_country_id;
   I_values.cont_no              := LP_header_lookup_record.ord_check_cont_no;
   I_item_rec.edi_asn            := LP_header_lookup_record.ord_check_edi_asn;
   I_values.supp_currency        := LP_header_lookup_record.ord_check_supp_currency;
   I_item_rec.settlement_code    := LP_header_lookup_record.ord_check_settlement_code;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END ORD_CHECK;

-------------------------------------------------------------------------------

FUNCTION GET_ORD_INFO(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                      I_order_no        IN       ORDHEAD.ORDER_NO%TYPE)
RETURN BOOLEAN IS

   L_function   VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.GET_ORD_INFO';
   L_rowid      ROWID         := NULL;

   cursor C_ORD_EXIST is
      select oh.rowid,
             oh.status,
             oh.orig_ind,
             oh.supplier,
             oh.currency_code,
             oh.exchange_rate,
             NVL(oh.earliest_ship_date, oh.not_before_date),
             NVL(oh.latest_ship_date, oh.not_after_date),
             oh.import_country_id,
             oh.contract_no,
             s.edi_asn,
             s.currency_code,
             s.settlement_code
        from ordhead oh,
             sups    s
       where oh.order_no = I_order_no
         and oh.supplier = s.supplier;

BEGIN

   --- Get the order and supplier information
   SQL_LIB.SET_MARK('OPEN','C_ORD_EXIST','ORDHEAD','Order_no:'||to_char(I_order_no));
   open C_ORD_EXIST;
   fetch C_ORD_EXIST into L_rowid,
                          LP_header_lookup_record.ord_check_order_status,
                          LP_header_lookup_record.ord_check_order_orig_ind,
                          LP_header_lookup_record.ord_check_supplier,
                          LP_header_lookup_record.ord_check_ord_currency,
                          LP_header_lookup_record.ord_check_ord_exchange_rate,
                          LP_header_lookup_record.ord_check_earliest_ship_date,
                          LP_header_lookup_record.ord_check_latest_ship_date,
                          LP_header_lookup_record.ord_check_import_country_id,
                          LP_header_lookup_record.ord_check_cont_no,
                          LP_header_lookup_record.ord_check_edi_asn,
                          LP_header_lookup_record.ord_check_supp_currency,
                          LP_header_lookup_record.ord_check_settlement_code;
   close C_ORD_EXIST;

   if L_rowid is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INV_ORDER_NO', NULL, NULL, NULL);
      return FALSE;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END GET_ORD_INFO;

-------------------------------------------------------------------------------

FUNCTION APPT_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN       ITEM_RCV_RECORD,
                    I_values          IN       COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function      VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.APPT_CHECK';
   L_rowid         ROWID;
   L_table         VARCHAR2(30);
   L_key1          VARCHAR2(100);
   L_key2          VARCHAR2(100);
   RECORD_LOCKED   EXCEPTION;
   PRAGMA          EXCEPTION_INIT(Record_Locked, -54);

   cursor C_APPT_EXIST is
      select rowid
        from appt_detail
       where doc_type     = 'P'
         and appt         = I_item_rec.appt
         and loc          = I_item_rec.phy_loc
         and doc          = I_item_rec.order_no
         and nvl(asn, -1) = nvl(I_item_rec.asn, -1)
         and (item        = I_item_rec.input_item or
              item        = I_item_rec.item)
        for update nowait;

BEGIN

   L_rowid := NULL;
   L_table := 'APPT_DETAIL';
   L_key1  := TO_CHAR(I_item_rec.appt)||' '||TO_CHAR(I_item_rec.order_no);
   L_key2  := TO_CHAR(I_item_rec.phy_loc)||' '||I_item_rec.item;

   SQL_LIB.SET_MARK('OPEN','C_APPT_EXIST','APPT_DETAIL','Appt:'||to_char(I_item_rec.appt));
   open C_APPT_EXIST;
   fetch C_APPT_EXIST into L_rowid;
   close C_APPT_EXIST;

   if L_rowid is NOT NULL then
      --- Appt exists so update appt detail

      SQL_LIB.SET_MARK('UPDATE',NULL,'APPT_DETAIL','rowid:'||L_rowid);
      update appt_detail ad
         set ad.receipt_no   = I_item_rec.receipt_no,
             ad.qty_received = NVL(ad.qty_received, 0) + I_values.input_qty
       where rowid = L_rowid;

   else
      --- No appt exists (blind receipt), write po to table for batch program to pick up

      SQL_LIB.SET_MARK('INSERT',NULL,'DOC_CLOSE_QUEUE',
                       'Doc:'||to_char(I_item_rec.order_no)||' Doc_type:P');

      insert into doc_close_queue
                 (doc,
                  doc_type )
          values (I_item_rec.order_no,
                  'P');  -- 'P'urchase order

   end if;

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END APPT_CHECK;

-------------------------------------------------------------------------------

FUNCTION SHIP_CHECK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN OUT   ITEM_RCV_RECORD,
                    I_values          IN       COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function   VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.SHIP_CHECK';

   cursor c_shipment_exists is
   select 'Y'
     from shipment
    where nvl(asn,-1) = NVL(I_item_rec.asn,-1)
      and order_no = I_item_rec.order_no
      and to_loc = I_item_rec.phy_loc
      and bill_to_loc = I_item_rec.destination;

   l_shipment_exists varchar2(1);

   cursor c_shipment is
   select shipment
     from shipment
    where nvl(asn,-1) = NVL(I_item_rec.asn,-1)
      and order_no = I_item_rec.order_no
      and to_loc = I_item_rec.phy_loc
      and bill_to_loc = I_item_rec.destination;

BEGIN


   open  c_shipment_exists;
   fetch c_shipment_exists into l_shipment_exists;
   close c_shipment_exists;

   l_shipment_exists := nvl(l_shipment_exists,'N');

   if smr_order_rcv_sql.p_bill_to_loc is null then
      smr_order_rcv_sql.p_bill_to_loc := I_item_rec.destination;
   end if;

   if I_item_rec.destination != smr_order_rcv_sql.p_bill_to_loc then
      --l_shipment_exists := 'N';
      open  c_shipment;
      fetch c_shipment into LP_header_lookup_record.ship_check_ship_no;
      close c_shipment;
   else
      null;
   end if;

   if (I_item_rec.order_no    = LP_header_lookup_record.ship_check_order_no AND
       NVL(I_item_rec.asn,-1) = NVL(LP_header_lookup_record.ship_check_asn, -1) AND
       I_item_rec.phy_loc     = LP_header_lookup_record.ship_check_phy_loc)
       AND  l_shipment_exists = 'Y'
       AND I_item_rec.destination = smr_order_rcv_sql.p_bill_to_loc
       then

       I_item_rec.ship_no     := LP_header_lookup_record.ship_check_ship_no;
       I_item_rec.ship_origin := LP_header_lookup_record.ship_check_ship_origin;

   else

      -- different order, lookup values
      if GET_SHIP_INFO(O_error_message,
                       I_item_rec,
                       I_values.input_qty) = FALSE then
         return FALSE;
      end if;

      LP_header_lookup_record.ship_check_phy_loc     := I_item_rec.phy_loc;
      LP_header_lookup_record.ship_check_asn         := I_item_rec.asn;

      LP_header_lookup_record.ship_check_order_no    := I_item_rec.order_no;
      LP_header_lookup_record.ship_check_ship_no     := I_item_rec.ship_no;
      LP_header_lookup_record.ship_check_ship_origin := I_item_rec.ship_origin;

   end if;

   smr_order_rcv_sql.p_bill_to_loc := I_item_rec.destination;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END SHIP_CHECK;

-------------------------------------------------------------------------------

FUNCTION GET_SHIP_INFO(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE,
                       I_item_rec      IN OUT ITEM_RCV_RECORD,
                       I_input_qty     IN ordloc.qty_ordered%TYPE)
RETURN BOOLEAN IS

   L_function              VARCHAR2(100)  := 'SMR_ORDER_RCV_SQL.GET_SHIP_INFO';
   --
   L_rowid                 ROWID;
   L_parent_shipment       SHIPMENT.SHIPMENT%TYPE;
   L_ship_origin           SHIPMENT.SHIP_ORIGIN%TYPE;

   L_matched_invc_exist_ind VARCHAR2(1) := 'N';

   L_create_new_shipment   VARCHAR2(1) := 'N';
   L_new_shipment          SHIPMENT.SHIPMENT%TYPE;
   --
   L_table                 VARCHAR2(30) := 'shipment';
   L_key1                  VARCHAR2(100) := to_char(I_item_rec.order_no);
   L_key2                  VARCHAR2(100) := to_char(I_item_rec.phy_loc);
   L_final_dest_ind        SUPS.FINAL_DEST_IND%TYPE := 'N';
   L_carton                CARTON.CARTON%TYPE := NULL;
   L_location              SHIPMENT.TO_LOC%TYPE := NULL;
   RECORD_LOCKED           EXCEPTION;
   PRAGMA                  EXCEPTION_INIT(RECORD_LOCKED, -54);
   L_bill_to_loc           SHIPMENT.BILL_TO_LOC%TYPE := NULL;
   L_bill_to_loc_type      SHIPMENT.BILL_TO_LOC_TYPE%TYPE := NULL;
   L_phy_wh                WH.PHYSICAL_WH%TYPE;
   L_real_asn              shipment.asn%type;

   -- if both the receipt_no and ASN are null, then a new shipment should be created
   -- each time the receipt is processed. Hence, do not add the NVL to the ext_ref_no_in
   -- field in the where clause below. It will update the existing record.
   cursor C_PARENT_SHIPMENT is
      select s1.shipment,
             s1.ship_origin,
             s1.rowid
        from shipment s1 --  Murali
       where  not exists (select 'x'
                           from shipment s2,
                                shipsku ss
                          where nvl(ss.carton, -1) = nvl(I_item_rec.carton, -1)
                            and ss.item = I_item_rec.item
                            and ss.shipment = s2.shipment
                            and s2.parent_shipment = s1.shipment)

         and 
             s1.parent_shipment is null
         --
         and ((s1.asn = I_item_rec.asn)
             or (s1.asn is NULL and s1.ext_ref_no_in = I_item_rec.receipt_no)
             or (LP_online_dsd_ind = 'Y' and I_item_rec.asn is NULL and I_item_rec.receipt_no is NULL))
         and s1.to_loc = I_item_rec.phy_loc
         and s1.order_no = I_item_rec.order_no
       --  and s1.bill_to_loc = I_item_rec.destination  
         for update nowait;

   cursor C_CHECK_MATCH is
      select 'Y'
        from shipment shp,
             shipsku sku
       where shp.shipment = sku.shipment
         and shp.shipment = L_parent_shipment
         and sku.item   = I_item_rec.item
         and nvl(sku.carton, -1) = nvl(I_item_rec.carton, -1)
         and ( nvl(sku.qty_matched, 0) > nvl(sku.qty_received, 0) + I_input_qty
              or shp.invc_match_status in ('M','C'));

   cursor C_SHIPMENT is
      select ship_origin,
             rowid
        from shipment
       where ((asn = I_item_rec.asn)
             or (asn is NULL))
         and to_loc = I_item_rec.phy_loc
         and order_no = I_item_rec.order_no
         --
         and shipment = LP_shipment_to_process;

   cursor C_SUPP_IND is
      select final_dest_ind
        from sups
       where supplier = I_item_rec.supplier;

   cursor C_CARTON_DETAILS is
      select carton,
             location,
             loc_type
        from carton
       where nvl(carton,-1) = nvl(I_item_rec.carton, -1);

   cursor C_BILL_TO_LOC is
      select physical_wh
        from wh
       where wh = L_bill_to_loc;

   cursor C_REAL_ASN IS
   SELECT SHIPMENT_ID
     FROM SMR_WH_RECEIVING_DATA ssd  -- murali
    WHERE carton_id = I_item_rec.asn;

   cursor C_REAL_ASN_2 IS
   SELECT SHIPMENT_ID
     FROM SMR_WH_RECEIVING_ERROR sse   -- murali
    WHERE carton_id = I_item_rec.asn;

BEGIN
   ---
   -- If no shipment was found or if a shipment is found, but the item in on an
   -- invoice that has already been matched,
   -- or if ASN exists, we will create/update a shipment based on the PO/ASN combination.
   -- If ASN is null, we will create/update a shipment based on the PO/Receipt number combination.
   -- If ASN is null and receipt_no is null, also create a new shipment for the PO, even if it is a
   -- receipt adjustment. For this scenario, it's valid to have a shipment record with negative qty.
---
   -- Possible values for bill_to_loc is
   -- 1. Final Destination (carton.location). If the receipt is of a XDOC po,
   --    where the goods will be received at Wh and invoice matching will be done at final destination
   --    of the goods (wh/store). ASN from supplier will contain cartons specifying final destination.
   -- 2. Bill_to_loc (ordhead.import_id), Can be a legal entity for an import po which will be receiving
   --    goods from supplier or an invoice matching location specified by user on order creation.
   -- 3. shipment.to_loc. if final destination and bill_to_loc is null then shipment.to_loc will be
   --    invoice matching location.

   SQL_LIB.SET_MARK('OPEN','C_SUPP_IND','SUPS','sups:'||to_char(I_item_rec.supplier));
   open C_SUPP_IND;
   fetch C_SUPP_IND into L_final_dest_ind;
   close C_SUPP_IND;

   if L_final_dest_ind = 'Y' then
      SQL_LIB.SET_MARK('OPEN','C_CARTON_DETAILS','CARTON','carton:'||I_item_rec.carton);
      open C_CARTON_DETAILS;
      fetch C_CARTON_DETAILS into L_carton,
                                  L_location,
                                  L_bill_to_loc_type;
      close C_CARTON_DETAILS;
   end if;

   if L_location IS NULL then
      if I_item_rec.order_no is not NULL then
         if ORDER_SQL.GET_DEFAULT_IMP_EXP(O_error_message,
                                          L_bill_to_loc,
                                          L_bill_to_loc_type,
                                          I_item_rec.order_no) = FALSE then
            return FALSE;
         end if;
     end if;

     if L_bill_to_loc is not NULL then
        if L_bill_to_loc_type = 'S' then
           L_location := L_bill_to_loc;
           L_bill_to_loc_type := L_bill_to_loc_type;
        else
           open C_BILL_TO_LOC;
           fetch C_BILL_TO_LOC into L_phy_wh;
           close C_BILL_TO_LOC;

           L_location := L_phy_wh;
           L_bill_to_loc_type := 'W';
        end if;
     else
        L_location := I_item_rec.phy_loc;
        L_bill_to_loc_type := I_item_rec.loc_type;
     end if;
   end if;
---
   if LP_shipment_to_process is not null then

      L_parent_shipment := LP_shipment_to_process;

      open C_CHECK_MATCH;
      fetch C_CHECK_MATCH into L_matched_invc_exist_ind;
      close C_CHECK_MATCH;

      if L_matched_invc_exist_ind = 'Y' then
         L_create_new_shipment := 'Y';
      end if;

      open C_SHIPMENT;
      fetch C_SHIPMENT into L_ship_origin,
                            L_rowid;
      close C_SHIPMENT;

      if L_rowid is null then
         O_error_message := SQL_LIB.CREATE_MSG('INV_SHIP', NULL, NULL, NULL);
         return FALSE;
      end if;
   else

      open C_PARENT_SHIPMENT;
      fetch C_PARENT_SHIPMENT into L_parent_shipment,
                                   L_ship_origin,
                                   L_rowid;
      close C_PARENT_SHIPMENT;

      if L_parent_shipment is null then
         L_create_new_shipment := 'Y';
      else
         open C_CHECK_MATCH;
         fetch C_CHECK_MATCH into L_matched_invc_exist_ind;
         close C_CHECK_MATCH;

         if L_matched_invc_exist_ind = 'Y' then
            L_create_new_shipment := 'Y';
         end if;
      end if;
   end if;

   if L_create_new_shipment = 'Y' then
      if SHIPMENT_ATTRIB_SQL.NEXT_SHIPMENT(O_error_message,
                                           L_new_shipment) = FALSE then
         return FALSE;
      end if;

      -- 3-System / 4-System ASN
      if I_item_rec.asn is null
      or rtrim(substrb(I_item_rec.asn, 1, 3)) = LP_sim_asn_prefix then
         L_ship_origin := 3;
      else
         L_ship_origin := 4;
      end if;

      L_real_asn := null;

      --get ASN from staging table
      open  C_real_asn;
      fetch C_real_asn into L_real_asn;
      close C_real_asn;

      if L_real_asn is null THEN
         --get ASN from error table
         open  C_real_asn_2;
         fetch C_real_asn_2 into L_real_asn;
         close C_real_asn_2;
      end if;

      insert into shipment(shipment,
                           order_no,
                           bol_no,
                           asn,
                           ship_date,
                           receive_date,
                           est_arr_date,
                           ship_origin,
                           status_code,
                           invc_match_status,
                           invc_match_date,
                           to_loc,
                           to_loc_type,
                           from_loc,
                           from_loc_type,
                           courier,
                           no_boxes,
                           ext_ref_no_in,
                           ext_ref_no_out,
                           comments,
                           parent_shipment,
                           bill_to_loc,
                           bill_to_loc_type)
                    values(L_new_shipment,
                           I_item_rec.order_no,
                           null,
                           I_item_rec.asn,
                           I_item_rec.tran_date,
                           I_item_rec.tran_date,
                           null,
                           L_ship_origin,
                           DECODE(L_ship_origin, 4, 'U', 'R'),
                           'U',
                           null,
                           I_item_rec.phy_loc,
                           I_item_rec.loc_type,
                           null,
                           null,
                           null,
                           null,
                           I_item_rec.receipt_no,
                           null,
                           L_real_asn,
                           L_parent_shipment,
                           L_location,
                           L_bill_to_loc_type);

   else
      update shipment
         set status_code  = DECODE(status_code, 'U', status_code, 'R'),
             receive_date = DECODE(I_item_rec.tran_type, 'R', I_item_rec.tran_date, receive_date),
             bill_to_loc = L_location,
             bill_to_loc_type = L_bill_to_loc_type
       where rowid = L_rowid;
   end if;

   --

   if LP_shipment_to_process is not null and L_create_new_shipment = 'N' then
      I_item_rec.ship_no := LP_shipment_to_process;
   else
      if L_create_new_shipment = 'Y' then
         I_item_rec.ship_no := L_new_shipment;
      else
         I_item_rec.ship_no := L_parent_shipment;
      end if;
   end if;
   I_item_rec.ship_origin := to_char(L_ship_origin);

   --OLR V1.02 Insert START
   -- Check if there is any finalized ALC available for the shipment
   I_item_rec.alc_finalize_ind := 'N' ;
   ---
   if LP_so_elc_ind = 'Y' then
      if ALC_SQL.GET_SHIPMENT_ALC_STATUS (O_error_message,
                                          I_item_rec.alc_finalize_ind,
                                          I_item_rec.ship_no,
                                          I_item_rec.order_no) = FALSE then
         return FALSE;
      end if;
   end if;
   ----
   ----
   ---if ALC is on the then add order and Shipment to the queue
   --- for ALC reallocation
   if LP_so_import_ind = 'Y' and LP_so_rtm_simplified_ind = 'N' then
      if ADD_ORD_SHIPMENT_TO_QUEUE(O_error_message,
                                   I_item_rec.order_no,
                                   I_item_rec.ship_no) = FALSE then
         return FALSE;
      end if;
   end if;
   --OLR V1.02 Insert END

   return TRUE;

EXCEPTION

   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;

   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            to_char(SQLCODE));
      return FALSE;

END GET_SHIP_INFO;

-------------------------------------------------------------------------------

FUNCTION ON_ORDER(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                  I_item_rec        IN OUT   ITEM_RCV_RECORD,
                  I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function              VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.ON_ORDER';
   L_rowid                 ROWID;
   RECORD_LOCKED           EXCEPTION;
   PRAGMA                  EXCEPTION_INIT(Record_Locked, -54);
   L_table                 VARCHAR2(30);
   L_key1                  VARCHAR2(100);
   L_key2                  VARCHAR2(100);

   L_container_item_rec    ITEM_RCV_RECORD;
   L_container_values      COST_RETAIL_QTY_RECORD;

   L_exists                BOOLEAN                       := FALSE;
   L_ref_item              ITEM_MASTER.ITEM%TYPE         := NULL;
   L_origin_country_id     ORDSKU.ORIGIN_COUNTRY_ID%TYPE := NULL;
   L_update_qty_only       VARCHAR2(1)                   := 'Y';
   L_unit_cost_supp_conv   ORDLOC.UNIT_COST%TYPE         := NULL;
   L_cost_source           ORDLOC.COST_SOURCE%TYPE       := 'NORM';
   L_import_id             SUPS_IMP_EXP.IMPORT_ID%TYPE   := NULL;
   L_import_type           SUPS_IMP_EXP.IMPORT_TYPE%TYPE := NULL;

   --- Place holders for pkg call
   L_av_cost               ITEM_LOC_SOH.AV_COST%TYPE;
   L_selling_unit_retail   ITEM_LOC.SELLING_UNIT_RETAIL%TYPE;
   L_selling_uom           ITEM_LOC.SELLING_UOM%TYPE;
   L_unit_cost             ITEM_LOC_SOH.UNIT_COST%TYPE;

   cursor C_LOCK_ORDLOC_QTYS is
      select ol.rowid,
             ol.unit_retail,
             ol.unit_cost,
             ol.qty_ordered,
             nvl(ol.qty_received,0),
             os.origin_country_id,
             os.supp_pack_size
        from ordloc ol,
             ordsku os
       where ol.order_no = I_item_rec.order_no
         and ol.item     = I_item_rec.item
         and ol.location = I_item_rec.loc
         and os.order_no = ol.order_no
         and os.item     = ol.item
         for update of ol.qty_received, ol.last_received nowait;

   cursor C_ITEM_SUPP_COUNTRY is
      select isc.origin_country_id,
             isc.supp_pack_size
        from item_supp_country isc
       where isc.item                = I_item_rec.item
         and isc.supplier            = I_item_rec.supplier
         and isc.primary_country_ind = 'Y';

   cursor C_ITEM_SUPP_COUNTRY_LOC is
      select iscl.unit_cost
        from item_supp_country_loc iscl
       where iscl.item               = I_item_rec.item
         and iscl.supplier           = I_item_rec.supplier
         and iscl.origin_country_id  = L_origin_country_id
         and iscl.loc                = I_item_rec.loc;

   cursor C_ORDSKU_CHECK is
      select origin_country_id
        from ordsku
       where order_no = I_item_rec.order_no
         and item     = I_item_rec.item;

   --OLR V1.03 Insert START
   CURSOR C_ORDER_9401_UNIT_COST IS
   SELECT unit_cost
     from ordloc
    where order_no = I_item_rec.order_no
      and item = I_item_rec.item
      and location = 9401;


   L_9401_unit_cost number;

   --OLR V1.03 Insert END



BEGIN

   --- Get order/item/loc info from ordloc, ordsku
   L_rowid := NULL;
   L_table := 'ORDLOC';
   L_key1  := TO_CHAR(I_item_rec.order_no);
   L_key2  := I_item_rec.item;
   ---
   open C_LOCK_ORDLOC_QTYS;
   fetch C_LOCK_ORDLOC_QTYS into L_rowid,
                                 I_values.unit_retail_loc,      -- local currency
                                 I_values.unit_cost_order,      -- order currency
                                 I_values.ol_qty_ordered,
                                 I_values.ol_qty_received,
                                 I_item_rec.origin_country_id,
                                 I_item_rec.supp_pack_size;
   close C_LOCK_ORDLOC_QTYS;

   if L_rowid is NOT NULL then  -- found ordloc/ordsku record

      I_item_rec.new_ordloc_ind := 'N';

      --- We have to ensure that a negative adjustment does not bring the qty_received
      --- below zero.  Receipts will not be negative.
      if I_values.ol_qty_received + I_values.input_qty < 0 then
         O_error_message := SQL_LIB.CREATE_MSG('ADJUST_GT_QTY_RECEIVED',NULL, NULL, NULL);
         return FALSE;
      end if;

      if I_item_rec.online_ind != 'A' then   -- 'A' is auto PO

         --- If item is on order and allowance is applied at receiving time, call deals package
         if I_item_rec.tran_type = 'R' then
            if not DEAL_SQL.APPLY_ON_RCPT_DEALS(O_error_message,
                                                I_item_rec.order_no,
                                                I_item_rec.item,
                                                I_item_rec.loc) then
               return FALSE;
            end if;
         end if;

         --- Set this flag to 'N'o so the shipsku unit_cost, unit_retail, and status fields
         --- are updated along with the qty_received.
         L_update_qty_only := 'N';

      end if; --- online_ind != 'A'

      --- Insert or update shipsku records.  If this is an adjustment then the unit retail
      --- (local currency) is set to shipsku.unit_retail and no changes are made to shipsku.
      if SMR_ORDER_RCV_SQL.INSERT_UPDATE_SHIPSKU(O_error_message,
                                             I_item_rec,
                                             I_values,
                                             L_update_qty_only) = FALSE then  -- initialized to 'Y', may
         return FALSE;                                                        -- be set to 'N' above
      end if;

       -- update the weight info on shipsku table
      if I_values.weight is NOT NULL then
         if SMR_ORDER_RCV_SQL.UPDATE_SHIPSKU_WEIGHT(O_error_message,
                                                I_item_rec.ship_no,
                                                I_item_rec.item,
                                                I_item_rec.carton,
                                                NULL,
                                                I_values.weight,
                                                I_values.weight_uom) = FALSE then
            return FALSE;
         end if;
      end if;

      --- If SHIPSKU.QTY_RECEIVED is updated, then INVC_MATCH_WKSHT.MATCH_TO_QTY should also be updated
      if SMR_ORDER_RCV_SQL.UPDATE_INVC_MATCH_WKSHT(O_error_message,
                                               I_item_rec,
                                               I_values) = FALSE then
         return FALSE;
      end if;

      --- Update ordloc
      update ordloc
         set qty_received  = NVL(qty_received, 0) + I_values.input_qty,
             last_received = DECODE(I_item_rec.tran_type,
                                    'R', I_values.input_qty,
                                    last_received)
       where rowid = L_rowid;

      --- If no deals exist for this order/item/loc then call invoice matching logic
      if LP_deals_exist = FALSE then
         if INVC_SQL.UPDATE_INVOICE(O_error_message,
                                    I_item_rec.order_no,
                                    I_item_rec.item,
                                    I_item_rec.phy_loc,
                                    I_item_rec.ship_no,
                                    I_item_rec.carton,
                                    I_values.input_qty) = FALSE then
            return FALSE;
         end if;
      end if;

   else --- L_rowid is NULL: ordsku/ordloc not found

      I_item_rec.new_ordloc_ind := 'Y';

      --cannot add new ordloc with negative receipt qty
      if (I_values.input_qty <= 0) then
         O_error_message := SQL_LIB.CREATE_MSG('NEG_VALUE', 'ORDLOC.QTY_ORDERED', NULL, NULL);
         return FALSE;
      end if;
      ---
      if ORDER_SQL.GET_DEFAULT_IMP_EXP(O_error_message,
                                       L_import_id,
                                       L_import_type,
                                       I_item_rec.order_no) = FALSE then
         return FALSE;
      end if;
      ---
      if LP_so_mult_set_of_books_ind = 'Y' and L_import_id is NULL then
         --cannot allow new ordloc when org unit of supplier and location does not match
         --and no importer/exporter attached to the order.
         if SET_OF_BOOKS_SQL.CHECK_SUPP_SINGLE_LOC(O_error_message,
                                                   L_exists,
                                                   I_item_rec.supplier,
                                                   I_item_rec.loc,
                                                   I_item_rec.loc_type) = FALSE then
            return FALSE;
         end if;

         if L_exists = FALSE then
            return FALSE;
         end if;
      end if;
      --- Create new item/loc record if it doesn't exist
      if NEW_ITEM_LOC(O_error_message,
                      I_item_rec.item,             -- I_item
                      I_item_rec.loc,              -- I_location
                      I_item_rec.item_parent,      -- I_item_parent
                      I_item_rec.item_grandparent, -- I_item_grandparent
                      I_item_rec.loc_type,         -- I_loc_type
                      NULL,                        -- I_short_desc
                      I_item_rec.dept,             -- I_dept
                      I_item_rec.class,            -- I_class
                      I_item_rec.subclass,         -- I_subclass
                      I_item_rec.item_level,       -- I_item_level
                      I_item_rec.tran_level,       -- I_tran_level
                      NULL,                        -- I_item_status
                      NULL,                        -- I_zone_group_id
                      NULL,                        -- I_waste_type
                      NULL,                        -- I_daily_waste_pct
                      NULL,                        -- I_sellable_ind
                      NULL,                        -- I_orderable_ind
                      I_item_rec.pack_ind,         -- I_pack_ind
                      I_item_rec.pack_type,        -- I_pack_type
                      NULL,                        -- I_unit_cost_loc
                      NULL,                        -- I_unit_retail_loc
                      NULL,                        -- I_selling_retail_loc
                      NULL,                        -- I_selling_uom
                      NULL,                        -- I_item_loc_status
                      NULL,                        -- I_taxable_ind
                      NULL,                        -- I_ti
                      NULL,                        -- I_hi
                      NULL,                        -- I_store_ord_mult
                      NULL,                        -- I_meas_of_each
                      NULL,                        -- I_meas_of_price
                      NULL,                        -- I_uom_of_price
                      NULL,                        -- I_primary_varient
                      NULL,                        -- I_primary_supp
                      NULL,                        -- I_primary_cntry
                      NULL,                        -- I_local_item_desc
                      NULL,                        -- I_local_short_desc
                      NULL,                        -- I_primary_cost_pack
                      NULL,                        -- I_receive_as_type
                      LP_vdate,                    -- I_date
                      NULL) = FALSE then           -- I_default_to_children
         return FALSE;
      end if;

      --- Check for ordsku record by fetching origin country
      open C_ORDSKU_CHECK;
      fetch C_ORDSKU_CHECK into I_item_rec.origin_country_id;
         if C_ORDSKU_CHECK%NOTFOUND then
            I_item_rec.origin_country_id := NULL;
         end if;
      close C_ORDSKU_CHECK;

      --- Get item/supplier/country info.

      open C_ITEM_SUPP_COUNTRY;
      fetch C_ITEM_SUPP_COUNTRY into L_origin_country_id,
                                     I_item_rec.supp_pack_size;
      close C_ITEM_SUPP_COUNTRY;

      if ( L_origin_country_id is NULL ) then
         O_error_message := SQL_LIB.CREATE_MSG('ITEMSUPP_NO_ITEMSUPPCTRY',
                                                I_item_rec.item,
                                                to_char(I_item_rec.supplier),
                                                NULL);
         return FALSE;
      end if;

      --- Get item/supplier/loc info.

      open C_ITEM_SUPP_COUNTRY_LOC;
      fetch C_ITEM_SUPP_COUNTRY_LOC into I_values.unit_cost_supp;      -- supplier currency
      close C_ITEM_SUPP_COUNTRY_LOC;

      if ( I_values.unit_cost_supp is NULL ) then
         if ITEM_SUPP_COUNTRY_LOC_SQL.CREATE_LOCATION(O_error_message,
                                                      I_item_rec.item,
                                                      I_item_rec.supplier,
                                                      L_origin_country_id,
                                                      I_item_rec.loc) = FALSE then
            return FALSE;
         end if;
         --- Get item/supplier/loc info.

         open C_ITEM_SUPP_COUNTRY_LOC;
         fetch C_ITEM_SUPP_COUNTRY_LOC into I_values.unit_cost_supp;      -- supplier currency
         close C_ITEM_SUPP_COUNTRY_LOC;
      end if;

      --- If origin country is NULL then no ordsku record was found, so create one.
      if I_item_rec.origin_country_id is NULL then

         --- Use the origin country fetched from item_supp_country_loc.
         I_item_rec.origin_country_id := L_origin_country_id;

         --- If a sub tran level item was passed in then use that as the ref_item
         if (I_item_rec.input_item != I_item_rec.item) then
            L_ref_item := I_item_rec.input_item;
         end if;

         --- Create ordsku record
         insert into ordsku(order_no,
                            item,
                            ref_item,
                            origin_country_id,
                            earliest_ship_date,
                            latest_ship_date,
                            supp_pack_size,
                            non_scale_ind)
                     values(I_item_rec.order_no,
                            I_item_rec.item,
                            L_ref_item,
                            I_item_rec.origin_country_id,
                            I_item_rec.earliest_ship_date,
                            I_item_rec.latest_ship_date,
                            I_item_rec.supp_pack_size,
                            'N');

         --- If elc is on then default all assessments
         if LP_so_elc_ind = 'Y' then
            if ORDER_HTS_SQL.DEFAULT_CALC_HTS(O_error_message,
                                              I_item_rec.order_no,
                                              I_item_rec.item,
                                              NULL) = FALSE then
               return FALSE;
            end if;
         end if;

      end if; --- L_ref_item is NULL, no ordsku record

      --- Convert unit cost in supplier currency to order currency
      if CURRENCY_SQL.CONVERT(O_error_message,
                              I_values.unit_cost_supp,
                              I_values.supp_currency,
                              I_values.ord_currency,
                              L_unit_cost_supp_conv,
                              'C',
                              NULL,
                              NULL,
                              NULL,
                              I_values.ord_exchange_rate) = FALSE then
         return FALSE;
      end if;

      --- If cost was not passed in then use supplier's cost
      if I_values.unit_cost_input is NULL then

         I_values.unit_cost_order := L_unit_cost_supp_conv;
      else  --- cost was passed in

         --- Use the inputted unit cost (given in order currency)
         I_values.unit_cost_order := I_values.unit_cost_input;

         --- If the unit cost passed in differs from the supplier's unit cost,
         --- the cost source is manual ('MANL')
         if I_values.unit_cost_order != L_unit_cost_supp_conv then
            L_cost_source := 'MANL';
         end if;
      end if;  -- unit_cost_input is NULL

      --- Get the retail
      if  (I_item_rec.pack_ind = 'Y')
      and (I_item_rec.sellable_ind = 'N') then

         --- Item is a non-sellable pack so we need to build the retail
         if PRICING_ATTRIB_SQL.BUILD_PACK_RETAIL(O_error_message,
                                                 I_values.unit_retail_loc,
                                                 I_item_rec.item,
                                                 I_item_rec.loc_type,
                                                 I_item_rec.loc) = FALSE then
             return FALSE;
          end if;
      else

         --- Not a non-sellable pack so just get the retail (we already
         --- have the unit cost from the supplier or input_cost)
         if ITEMLOC_ATTRIB_SQL.GET_COSTS_AND_RETAILS(O_error_message,
                                                     I_item_rec.item,
                                                     I_item_rec.loc,
                                                     I_item_rec.loc_type,
                                                     L_av_cost,
                                                     L_unit_cost,
                                                     I_values.unit_retail_loc,
                                                     L_selling_unit_retail,
                                                     L_selling_uom) = FALSE then
            return FALSE;
         end if;

      end if;

      I_values.unit_retail_loc := nvl(I_values.unit_retail_loc,0);

      --OLR V1.03 Insert START
      open  C_ORDER_9401_UNIT_COST;
      fetch C_ORDER_9401_UNIT_COST into L_9401_unit_cost;
      close C_ORDER_9401_UNIT_COST;

      if L_9401_unit_cost is not null then
         I_values.unit_cost_order := L_9401_unit_cost;
      end if;
      --OLR V1.03 Insert END

      --- Create ordloc record
      insert into ordloc(order_no,
                         item,
                         location,
                         loc_type,
                         unit_retail,
                         qty_ordered,
                         qty_received,
                         last_received,
                         non_scale_ind,
                         qty_prescaled,
                         unit_cost,
                         unit_cost_init,
                         cost_source)
                  values(I_item_rec.order_no,       -- order_no
                         I_item_rec.item,           -- item
                         I_item_rec.loc,            -- location
                         I_item_rec.loc_type,       -- loc_type
                         I_values.unit_retail_loc,  -- unit_retail, local currency
                         DECODE(I_item_rec.deposit_item_type, LP_container_item_code, I_values.input_qty,0), -- qty_ordered
                         I_values.input_qty,        -- qty_received
                         I_values.input_qty,        -- last_received
                         'N',                       -- non_scale_ind
                         DECODE(I_item_rec.deposit_item_type, LP_container_item_code, I_values.input_qty,0), -- qty_prescaled
                         I_values.unit_cost_order,  -- unit_cost, order currency
                         I_values.unit_cost_order,  -- unit_cost_init, order currency
                         L_cost_source);            -- cost_source

      --- Create ordloc_exp record

      if LP_so_elc_ind = 'Y' then
         if ORDER_EXPENSE_SQL.INSERT_COST_COMP(O_error_message,
                                               I_item_rec.order_no,
                                               I_item_rec.item,
                                               null,
                                               I_item_rec.loc,
                                               I_item_rec.loc_type) = FALSE then
            return FALSE;
         end if;
      end if;

      --- Insert or update shipsku record.  If record exists, only update the qty (not unit_cost/retail)
      if SMR_ORDER_RCV_SQL.INSERT_UPDATE_SHIPSKU(O_error_message,
                                             I_item_rec,
                                             I_values,
                                             'Y') = FALSE then     -- I_update_qty_only = 'Y'
         return FALSE;
      end if;

            -- update the weight info on shipsku table
      if I_values.weight is NOT NULL then
         if SMR_ORDER_RCV_SQL.UPDATE_SHIPSKU_WEIGHT(O_error_message,
                                                I_item_rec.ship_no,
                                                I_item_rec.item,
                                                I_item_rec.carton,
                                                NULL,
                                                I_values.weight,
                                                I_values.weight_uom) = FALSE then
            return FALSE;
         end if;
      end if;
   end if;

   --- Convert unit cost in order currency to primary currency
   if CURRENCY_SQL.CONVERT(O_error_message,
                           I_values.unit_cost_order,
                           I_values.ord_currency,
                           I_values.prim_currency,
                           I_values.unit_cost_prim,
                           'C',
                           NULL,
                           NULL,
                           I_values.ord_exchange_rate,
                           NULL) = FALSE then
      return FALSE;
   end if;

   --- Convert unit cost in order currency to local currency
   if CURRENCY_SQL.CONVERT(O_error_message,
                           I_values.unit_cost_order,
                           I_values.ord_currency,
                           I_values.loc_currency,
                           I_values.unit_cost_loc,
                           'C',
                           NULL,
                           NULL,
                           I_values.ord_exchange_rate,
                           NULL) = FALSE then
      return FALSE;
   end if;

   --- Convert unit retail in local currency to primary currency.
   if CURRENCY_SQL.CONVERT(O_error_message,
                           I_values.unit_retail_loc,
                           I_values.loc_currency,
                           I_values.prim_currency,
                           I_values.unit_retail_prim,
                           'R',
                           NULL,
                           NULL) = FALSE then
      return FALSE;
   end if;
   --- Check to see if item is a contents item
   --- If item is contents item, the matching container item must be processed
   if I_item_rec.deposit_item_type = LP_contents_item_code and
      I_item_rec.container_item is NOT NULL                then

      L_container_item_rec := I_item_rec;
      L_container_values := I_values;

      --- Validate container item and get item_master info
      --- Call ON_ORDER for the container item
      if SMR_ORDER_RCV_SQL.CONTAINER_ITEM_CHECK(O_error_message,
                                            L_container_item_rec,
                                            L_container_values,
                                            I_item_rec.container_item) = FALSE then
         return FALSE;
      end if;

   end if;
   ---
   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END ON_ORDER;

-------------------------------------------------------------------------------

FUNCTION INSERT_UPDATE_SHIPSKU(O_error_message     IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                               I_item_rec          IN OUT   ITEM_RCV_RECORD,
                               I_values            IN OUT   COST_RETAIL_QTY_RECORD,
                               I_update_qty_only   IN       VARCHAR2)
RETURN BOOLEAN IS

   L_function      VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.INSERT_UPDATE_SHIPSKU';
   RECORD_LOCKED   EXCEPTION;
   PRAGMA          EXCEPTION_INIT(Record_Locked, -54);
   L_table         VARCHAR2(30)  := 'SHIPSKU';
   L_key1          VARCHAR2(100) := to_char(I_item_rec.ship_no);
   L_key2          VARCHAR2(100) := I_item_rec.item;

   L_rowid         ROWID                     := NULL;
   L_unit_retail   SHIPSKU.UNIT_RETAIL%TYPE;
   L_exists        BOOLEAN                   := FALSE;
   L_ref_item      ITEM_MASTER.ITEM%TYPE     := NULL;
   L_seq_no        SHIPSKU.SEQ_NO%TYPE;
   L_order_type    ORDHEAD.ORDER_TYPE%TYPE;

   cursor C_LOCK_SHIPSKU is
      select rowid,
             unit_retail,
             seq_no --OLR V1.02 Inserted
        from shipsku
       where shipment           = I_item_rec.ship_no
         and item               = I_item_rec.item
         and NVL(carton,-1)     = NVL(I_item_rec.carton, -1)
         and NVL(inv_status,-1) = NVL(I_item_rec.inv_status,-1)
         for update nowait;

   cursor C_ORDER_TYPE is
     select order_type
       from ordhead
      where order_no =I_item_rec.order_no;

BEGIN

   --- Get unit retail and lock shipsku table for possible update
   SQL_LIB.SET_MARK('OPEN','C_LOCK_SHIPSKU','SHIPSKU','Shipment:'||to_char(I_item_rec.ship_no)||
                    ' Item:'||I_item_rec.item);
   open C_LOCK_SHIPSKU;
   fetch C_LOCK_SHIPSKU into L_rowid,
                             L_unit_retail,
                             L_seq_no; --OLR V1.02 Inserted
   close C_LOCK_SHIPSKU;

   --- Get order type from ordhead
   SQL_LIB.SET_MARK('OPEN','C_ORDER_TYPE','ORDHEAD','Order:'||to_char(I_item_rec.order_no));

   open C_ORDER_TYPE;
   fetch C_ORDER_TYPE into L_order_type;
   close C_ORDER_TYPE;

   --- Update shipsku table
   if L_rowid is NOT NULL then

      --not inserting into shipsku
      I_item_rec.new_shipsku_ind := 'N';

      --- If I_update_qty_only = 'Y'es then do not update unit_cost, unit_retail or status_code
      SQL_LIB.SET_MARK('UPDATE',NULL,'SHIPSKU','rowid:'||L_rowid);
      update shipsku
         set unit_cost    = DECODE(I_update_qty_only,
                                   'Y', unit_cost,
                                   I_values.unit_cost_order),     -- unit_cost, order currency
             unit_retail  = DECODE(I_update_qty_only,
                                   'Y', unit_retail,
                                   I_values.unit_retail_loc),     -- unit_retail, local currency
             status_code  = DECODE(I_update_qty_only,
                                   'Y', status_code,
                                   'A'),
             qty_received = NVL(qty_received, 0) + I_values.input_qty,
             qty_expected = DECODE(L_order_type,
                                   'DSD',(NVL(qty_received, 0) + I_values.input_qty),
                                   NVL(qty_expected,0))
       where rowid = L_rowid;

   else -- L_rowid is NULL, shipsku record does not exist

      --inserting into shipsku
      I_item_rec.new_shipsku_ind := 'Y';

      --- Fetch the next sequence number for insert into shipsku
      if SHIPSKU_ATTRIB_SQL.GET_NEXT_SEQ_NO(O_error_message,
                                            L_seq_no,
                                            I_item_rec.ship_no,
                                            I_item_rec.item) = FALSE then
         return FALSE;
      end if;

      --- If a sub tran level item was passed in then use that as the ref_item
      if (I_item_rec.input_item != I_item_rec.item) then
         L_ref_item := I_item_rec.input_item;
      end if;

      --- Insert into shipsku table
      insert into shipsku(shipment,
                          seq_no,
                          item,
                          distro_no,
                          ref_item,
                          carton,
                          inv_status,
                          status_code,
                          qty_received,
                          unit_cost,
                          unit_retail,
                          qty_expected,
                          actual_receiving_store,
                          match_invc_id)
                   values(I_item_rec.ship_no,       -- shipment
                          L_seq_no,                 -- seq_no
                          I_item_rec.item,          -- item
                          NULL,                     -- distro_no
                          L_ref_item,               -- ref_item
                          I_item_rec.carton,        -- carton
                          NVL(I_item_rec.inv_status, -1),   -- inv_status
                          'A',                      -- status_code
                          I_values.input_qty,       -- qty_received
                          I_values.unit_cost_order, -- unit_cost, order currency
                          I_values.unit_retail_loc, -- unit_retail, local currency
                          I_values.shipped_qty,     -- qty_expected
                          I_item_rec.destination,
                          NULL);                    -- match_invc_id

   end if;

   --OLR V1.02 Insert START
   --
   I_item_rec.ship_seq_no := L_seq_no;
   --
   if LP_so_multichannel_ind = 'Y' and LP_loc_type = 'W' then

      if INSERT_UPDATE_SHIPSKU_LOC (O_error_message,
                                    I_item_rec,
                                    I_values) = FALSE then
         return FALSE;
      end if;
   end if;
   --OLR V1.02 Insert END

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END INSERT_UPDATE_SHIPSKU;
-------------------------------------------------------------------------------
FUNCTION UPDATE_INVC_MATCH_WKSHT(O_error_message    IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                                 I_item_rec         IN OUT   ITEM_RCV_RECORD,
                                 I_values           IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function              VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.UPDATE_INVC_MATCH_WKSHT';
   RECORD_LOCKED           EXCEPTION;
   PRAGMA                  EXCEPTION_INIT(Record_Locked, -54);
   L_table                 VARCHAR2(30)  := 'INVC_MATCH_WKSHT';
   L_key1                  VARCHAR2(100) := to_char(I_item_rec.ship_no);
   L_key2                  VARCHAR2(100) := I_item_rec.item;

   L_rowid                 ROWID                     := NULL;
   L_match_to_cost         INVC_MATCH_WKSHT.MATCH_TO_COST%TYPE;
   L_exists                BOOLEAN                   := FALSE;
   L_ref_item              ITEM_MASTER.ITEM%TYPE     := NULL;


   cursor C_LOCK_INVC_MATCH_WKSHT is
      select rowid,
             match_to_cost
        from invc_match_wksht
       where shipment           = I_item_rec.ship_no
         and item               = I_item_rec.item
         for update nowait;

BEGIN
   --- Get match_to_cost and lock invc_match_wksht table for possible update
   SQL_LIB.SET_MARK('OPEN','C_LOCK_INVC_MATCH_WKSHT','INVC_MATCH_WKSHT','Shipment:'||to_char(I_item_rec.ship_no)||
                    ' Item:'||I_item_rec.item);
   open C_LOCK_INVC_MATCH_WKSHT;
   fetch C_LOCK_INVC_MATCH_WKSHT into L_rowid,
                                      L_match_to_cost;
   close C_LOCK_INVC_MATCH_WKSHT;
   --- Update invc_match_wksht table
   if L_rowid is NOT NULL then

      SQL_LIB.SET_MARK('UPDATE',NULL,'INVC_MATCH_WKSHT','rowid:'||L_rowid);

      update invc_match_wksht
         set match_to_cost = NVL(I_values.unit_cost_order,0),
             match_to_qty  = NVL(match_to_qty, 0) + I_values.input_qty
      where rowid = L_rowid;


   end if;

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END UPDATE_INVC_MATCH_WKSHT;
-------------------------------------------------------------------------------

FUNCTION LOAD_COMPS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                    I_item_rec        IN OUT   ITEM_RCV_RECORD,
                    I_comp_items      IN OUT   COMP_ITEM_ARRAY,
                    I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function         VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.LOAD_COMPS';
   L_comp_av_cost     ITEM_LOC_SOH.AV_COST%TYPE;
   L_selling_retail   ITEM_LOC.SELLING_UNIT_RETAIL%TYPE;
   L_selling_uom      ITEM_LOC.SELLING_UOM%TYPE;

   i BINARY_INTEGER := 1;

   cursor C_ITEMS_IN_PACK  is
      select vpq.item           item,
             vpq.qty            qty,
             im.pack_ind        pack_ind,
             im.dept            dept,
             im.class           class,
             im.subclass        subclass,
             im.inventory_ind   inventory_ind
        from v_packsku_qty vpq,
             item_master   im
       where vpq.pack_no = I_item_rec.item
         and im.item     = vpq.item;

BEGIN

   FOR rec IN C_ITEMS_IN_PACK LOOP

      I_comp_items(i).item           := rec.item;
      I_comp_items(i).qty            := rec.qty;
      I_comp_items(i).pack_ind       := rec.pack_ind;
      I_comp_items(i).dept           := rec.dept;
      I_comp_items(i).class          := rec.class;
      I_comp_items(i).subclass       := rec.subclass;
      I_comp_items(i).inventory_ind  := rec.inventory_ind;

      --- Get unit_cost and unit_retail from item_loc in local currency.
      if ITEMLOC_ATTRIB_SQL.GET_COSTS_AND_RETAILS(O_error_message,
                                                  I_comp_items(i).item,
                                                  I_item_rec.loc,
                                                  I_item_rec.loc_type,
                                                  L_comp_av_cost,
                                                  I_comp_items(i).unit_cost_loc,    -- local currency
                                                  I_comp_items(i).unit_retail_loc,  -- local currency
                                                  L_selling_retail,
                                                  L_selling_uom) = FALSE then
         return FALSE;
      end if;

      --- Convert component retail from local currency to primary currency
      if CURRENCY_SQL.CONVERT(O_error_message,
                              I_comp_items(i).unit_retail_loc,
                              I_values.loc_currency,
                              I_values.prim_currency,
                              I_comp_items(i).unit_retail_prim,
                              'R',
                              NULL,
                              NULL) = FALSE then
         return FALSE;
      end if;

      --- Calculate the total pack cost in local currency:
      --- sum all (component unit item cost * component qty)
      I_values.pack_cost_loc := NVL(I_values.pack_cost_loc,0) +
                               (I_comp_items(i).unit_cost_loc * I_comp_items(i).qty);

      i := i + 1;

   END LOOP;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END LOAD_COMPS;

-------------------------------------------------------------------------------

FUNCTION UPDATE_ALLOC(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                      I_alloc_no        IN       ALLOC_DETAIL.ALLOC_NO%TYPE,
                      I_destination     IN       ALLOC_DETAIL.TO_LOC%TYPE,
                      I_input_qty       IN       ALLOC_DETAIL.PO_RCVD_QTY%TYPE)
RETURN BOOLEAN IS

   L_function     VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.UPDATE_ALLOC';
   RECORD_LOCKED  EXCEPTION;
   PRAGMA         EXCEPTION_INIT(Record_Locked, -54);
   L_table        VARCHAR2(30)  := 'ALLOC_DETAIL';
   L_key1         VARCHAR2(100) := to_char(I_alloc_no);
   L_key2         VARCHAR2(100) := to_char(I_destination);
   L_rowid        ROWID         := NULL;

   cursor C_LOCK_ALLOC_DETAIL is
      select alloc_detail.rowid
        from alloc_detail,
             wh w
       where alloc_no = I_alloc_no
         --
         and to_loc =  nvl(w.wh, I_destination)
         and w.wh (+) = to_loc
         and w.physical_wh (+) = I_destination
         --
         for update of po_rcvd_qty nowait;

BEGIN

   --- Lock the alloc_detail table and update the po received qty.
   SQL_LIB.SET_MARK('OPEN','C_LOCK_ALLOC_DETAIL','ALLOC_DETAIL',
                    'alloc_no:'||to_char(I_alloc_no)||', to_loc:'||to_char(I_destination));
   open C_LOCK_ALLOC_DETAIL;
   fetch C_LOCK_ALLOC_DETAIL into L_rowid;
   close C_LOCK_ALLOC_DETAIL;

   if L_rowid is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('NO_ALLOC_DET',
                                             I_destination,
                                             I_alloc_no,
                                             NULL);
      return FALSE;
   end if;

   SQL_LIB.SET_MARK('UPDATE',NULL,'ALLOC_DETAIL','rowid:'||L_rowid);
   update alloc_detail
      set po_rcvd_qty = NVL(po_rcvd_qty,0) + I_input_qty
    where rowid       = L_rowid;


   return TRUE;


EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END UPDATE_ALLOC;

-------------------------------------------------------------------------------

FUNCTION ALC_PROCESSING(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                        I_item_rec        IN OUT   ITEM_RCV_RECORD,
                        I_comp_items      IN       COMP_ITEM_ARRAY,
                        I_values          IN OUT   COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function         VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.ALC_PROCESSING';

   i                  BINARY_INTEGER := 1;
   L_alc_status       ALC_HEAD.STATUS%TYPE;
   L_unit_cost_loc    ordloc.unit_cost%TYPE;
   L_unit_cost_prim   ordloc.unit_cost%TYPE;

   L_table            VARCHAR2(30);
   L_key1             VARCHAR2(100);
   L_key2             VARCHAR2(100);
   RECORD_LOCKED      EXCEPTION;
   PRAGMA             EXCEPTION_INIT(Record_Locked, -54);

   cursor C_LOCK_ALC_HEAD is
      select status
        from alc_head
       where order_no = I_item_rec.order_no
         and ((I_item_rec.pack_ind  = 'Y' and
               I_item_rec.pack_type = 'B' and
               pack_item            = I_item_rec.item)
          or  (item = I_item_rec.item))
         for update nowait;

BEGIN

   --- Check for the existence of ALC records for the PO/Item/Location that
   --- are in 'Processed - No WAC' or 'Procesed - Updated WAC' status.
   --- If the ALC records have been processed, and the new qty received is
   --- less than the qty ordered, then the ALC value needs to be backed out
   --- of the stock ledger and the ALC records need to be set back to pending
   --- status.  This is done by updating the ledger with the difference
   --- between the ELC value and the ALC value, multiplied by the original qty received.

   L_table := 'ALC_HEAD';
   L_key1  := TO_CHAR(I_item_rec.order_no);
   L_key2  := I_item_rec.item;
   SQL_LIB.SET_MARK('OPEN','C_LOCK_ALC_HEAD','ALC_HEAD','Order_no: '||to_char(I_item_rec.order_no)||
                    ' Item:'||I_item_rec.item);
   open  C_LOCK_ALC_HEAD;
   fetch C_LOCK_ALC_HEAD into L_alc_status;
   close C_LOCK_ALC_HEAD;

   --- If ALC status is not in 'Processed - No WAC' or 'Procesed - Updated WAC'
   --- then we do not continue.
   if L_alc_status NOT in ('PR','PW') or L_alc_status is NULL then
      return TRUE;
   end if;

   if I_item_rec.pack_ind = 'Y' then

      --- If it is a pack then loop through component items
      FOR i IN I_comp_items.FIRST..I_comp_items.LAST LOOP

         --- If the the item is a pack, the cost that will be used to back out ALC
         --- is calculated by:
         ---    taking the component cost times the component qty and multiplying this by the ratio of the
         ---    component item's cost to the total pack cost (the unit cost divided
         ---    by the sum of the costs for all the component items in the pack).
         if I_values.pack_cost_loc = 0 then
            L_unit_cost_loc := 0;
         else
            L_unit_cost_loc := (I_comp_items(i).unit_cost_loc * I_comp_items(i).qty) *
                               (I_values.unit_cost_loc / I_values.pack_cost_loc);
         end if;

         --- Convert cost from local currency to primary currency
         if CURRENCY_SQL.CONVERT(O_error_message,
                                 L_unit_cost_loc,
                                 I_values.loc_currency,
                                 I_values.prim_currency,
                                 L_unit_cost_prim,
                                 'C',
                                 NULL,
                                 NULL) = FALSE then
            return FALSE;
         end if;

         if SMR_ORDER_RCV_SQL.BACK_OUT_ALC(O_error_message,
                                       I_item_rec,
                                       I_values,
                                       I_comp_items(i).item,
                                       L_unit_cost_prim,
                                       I_values.ol_qty_received * I_comp_items(i).qty,
                                       I_values.pack_cost_loc,
                                       I_comp_items(i).unit_cost_loc,
                                       I_comp_items(i).qty,
                                       I_comp_items(i).dept,
                                       I_comp_items(i).class,
                                       I_comp_items(i).subclass,
                                       L_alc_status) = FALSE then
            return FALSE;
         end if;

         --- Set the status back to Pending.
         update alc_head
            set status    = 'P'
          where order_no  = I_item_rec.order_no
            and item      = I_comp_items(i).item
            and pack_item = I_item_rec.item;

      END LOOP;

   else -- not a pack

      if SMR_ORDER_RCV_SQL.BACK_OUT_ALC(O_error_message,
                                    I_item_rec,
                                    I_values,
                                    NULL,
                                    I_values.unit_cost_prim,
                                    I_values.ol_qty_received,
                                    NULL,                     --pack cost loc
                                    NULL,                     --comp cost loc
                                    NULL,                     --comp qty
                                    I_item_rec.dept,
                                    I_item_rec.class,
                                    I_item_rec.subclass,
                                    L_alc_status) = FALSE then
         return FALSE;
      end if;

      --- Set the status back to Pending.
      update alc_head
         set status     = 'P'
       where order_no   = I_item_rec.order_no
         and item       = I_item_rec.item
         and pack_item is NULL;

   end if;

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END ALC_PROCESSING;

-------------------------------------------------------------------------------

FUNCTION BACK_OUT_ALC(O_error_message     IN OUT   VARCHAR2,
                      I_item_rec          IN       ITEM_RCV_RECORD,
                      I_values            IN       COST_RETAIL_QTY_RECORD,
                      I_comp_item         IN       ITEM_MASTER.ITEM%TYPE,
                      I_unit_cost_prim    IN       ORDLOC.UNIT_COST%TYPE,
                      I_ol_qty_received   IN       ORDLOC.QTY_RECEIVED%TYPE,
                      I_pack_cost_loc     IN       ITEM_SUPP_COUNTRY.UNIT_COST%TYPE,
                      I_comp_cost_loc     IN       ITEM_SUPP_COUNTRY.UNIT_COST%TYPE,
                      I_comp_qty          IN       ORDLOC.QTY_RECEIVED%TYPE,
                      I_dept              IN       DEPS.DEPT%TYPE,
                      I_class             IN       CLASS.CLASS%TYPE,
                      I_subclass          IN       SUBCLASS.SUBCLASS%TYPE,
                      I_alc_status        IN       ALC_HEAD.STATUS%TYPE)
RETURN BOOLEAN IS

   L_function           VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.BACK_OUT_ALC';

   L_item               ITEM_MASTER.ITEM%TYPE  := NULL;
   L_comp_item          ITEM_MASTER.ITEM%TYPE  := NULL;
   L_pack_no            ITEM_MASTER.ITEM%TYPE  := NULL;

   L_tran_type          TRAN_DATA.TRAN_CODE%TYPE := 20;

   L_update_with_item   ITEM_MASTER.ITEM%TYPE;
   L_ref_pack_no        ITEM_MASTER.ITEM%TYPE  := NULL;
   L_unit_cost_ord      ORDLOC.UNIT_COST%TYPE;
   L_comp_cost_prim     ORDLOC.UNIT_COST%TYPE;
   L_unit_elc_loc       ORDLOC_EXP.EST_EXP_VALUE%TYPE;
   L_unit_alc_loc       ORDLOC_EXP.EST_EXP_VALUE%TYPE;
   L_unit_alc_prim      ORDLOC_EXP.EST_EXP_VALUE%TYPE;
   L_diff_loc           ORDLOC_EXP.EST_EXP_VALUE%TYPE;

BEGIN

   if I_item_rec.pack_type  = 'B' then
      L_item      := I_comp_item;
      L_comp_item := I_comp_item;
      L_pack_no   := I_item_rec.item;
   else
      L_item := I_item_rec.item;
   end if;

   --- Convert component cost from local currency to primary currency
   if CURRENCY_SQL.CONVERT(O_error_message,
                           I_comp_cost_loc,
                           I_values.loc_currency,
                           I_values.prim_currency,
                           L_comp_cost_prim,
                           'C',
                           NULL,
                           NULL) = FALSE then
      return FALSE;
   end if;

   --- Calculate the total ALC in primary currency
   --- based on the order, item, pack item, and location.
   if ALC_SQL.CALC_ORD_ITEM_LOC_ALC(O_error_message,
                                    L_unit_alc_prim,                         -- primary currency
                                    I_item_rec.order_no,
                                    L_item,
                                    L_pack_no,
                                    I_item_rec.loc,
                                    NVL(L_comp_cost_prim, I_unit_cost_prim), -- primary currency
                                    I_ol_qty_received) = FALSE then
      return FALSE;
   end if;

   --- Convert alc from primary currency to local currency
   if CURRENCY_SQL.CONVERT(O_error_message,
                           L_unit_alc_prim,
                           I_values.prim_currency,
                           I_values.loc_currency,
                           L_unit_alc_loc,
                           'C',
                           NULL,
                           NULL) = FALSE then
      return FALSE;
   end if;

   if I_item_rec.pack_ind = 'Y' and I_item_rec.pack_type = 'B' then
      L_unit_cost_ord := NULL;
   else
      --- Convert unit cost from primary currency to order currency
      if CURRENCY_SQL.CONVERT(O_error_message,
                              I_unit_cost_prim,
                              I_values.prim_currency,
                              I_values.ord_currency,
                              L_unit_cost_ord,
                              'C',
                              NULL,
                              NULL,
                              NULL,
                              I_values.ord_exchange_rate) = FALSE then
         return FALSE;
      end if;
   end if;

   if SMR_ORDER_RCV_SQL.GET_ELC_TOTAL_LOC(O_error_message,
                                      L_unit_elc_loc,                    -- local currency
                                      I_item_rec,
                                      I_values,
                                      NVL(L_pack_no, L_item),
                                      L_comp_item,
                                      L_unit_cost_ord) = FALSE then      -- order currency
      return FALSE;
   end if;

   --- Compute the difference between the elc and the alc and multiply by
   --- the qty received.
   L_diff_loc := (L_unit_elc_loc - L_unit_alc_loc) * I_ol_qty_received;


   if I_item_rec.pack_ind = 'Y' then

      if I_item_rec.pack_type = 'V' then

         --- If the the item is a vendor pack, the cost that will be used in the tran_data
         --- insert is calculated by:
         ---    taking the component cost times the component qty and multiplying this by the ratio of the
         ---    component item's elc/alc diff to the total pack cost (the elc/alc diff divided
         ---    by the sum of the costs for all the component items in the pack).
         if I_pack_cost_loc = 0 then
            L_diff_loc := 0;
         else
            L_diff_loc := (I_comp_cost_loc * I_comp_qty) * (L_diff_loc / I_pack_cost_loc);
         end if;

      end if;

      L_update_with_item := I_comp_item;
      L_ref_pack_no      := I_item_rec.item;

   else

      L_update_with_item := I_item_rec.item;

   end if;

   if STKLEDGR_SQL.BUILD_TRAN_DATA_INSERT(O_error_message,
                                          L_update_with_item,
                                          I_dept,
                                          I_class,
                                          I_subclass,
                                          I_item_rec.loc,
                                          I_item_rec.loc_type,
                                          I_item_rec.tran_date,
                                          L_tran_type,           -- 20: purchases
                                          'A',
                                          0,
                                          L_diff_loc,            -- local currency
                                          0,
                                          I_item_rec.order_no,
                                          I_item_rec.ship_no,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          L_function,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          L_ref_pack_no) = FALSE then -- I_ref_pack_no
      return FALSE;
   end if;

   -- Update the appropriate average cost, if average cost was updated upon ALC Finalization.
   -- The ALC Status must be 'PW' ('Processed - Updated WAC') (WAC - Weighted Average Cost).
   if I_alc_status = 'PW' then
      if I_item_rec.pack_ind = 'N' then
         if ITEMLOC_UPDATE_SQL.UPD_AV_COST_CHANGE_COST(O_error_message,
                                                       I_item_rec.item,
                                                       I_item_rec.loc,
                                                       I_item_rec.loc_type,
                                                       L_unit_alc_loc,
                                                       L_unit_elc_loc,
                                                       I_ol_qty_received,
                                                       NULL,   -- new wac
                                                       NULL,   -- neg_soh_wac_adj_amt
                                                       'Y',
                                                       I_item_rec.order_no) = FALSE then
            return FALSE;
         end if;
      else
         if ITEMLOC_UPDATE_SQL.UPD_AV_COST_CHANGE_COST(O_error_message,
                                                       I_comp_item,
                                                       I_item_rec.loc,
                                                       I_item_rec.loc_type,
                                                       L_unit_alc_loc * I_comp_cost_loc/I_pack_cost_loc,
                                                       L_unit_elc_loc * I_comp_cost_loc/I_pack_cost_loc,
                                                       I_ol_qty_received,
                                                       NULL,   -- new wac
                                                       NULL,   -- neg_soh_wac_adj_amt
                                                       'Y',
                                                       I_item_rec.order_no) = FALSE then
            return FALSE;
         end if;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END BACK_OUT_ALC;

-------------------------------------------------------------------------------

FUNCTION GET_ELC_TOTAL_LOC(O_error_message   IN OUT   VARCHAR2,
                           O_elc_loc         IN OUT   ITEM_LOC.UNIT_RETAIL%TYPE,
                           I_item_rec        IN       ITEM_RCV_RECORD,
                           I_values          IN       COST_RETAIL_QTY_RECORD,
                           I_item            IN       ITEM_MASTER.ITEM%TYPE,
                           I_comp_item       IN       ITEM_MASTER.ITEM%TYPE,
                           I_unit_cost_ord   IN       ITEM_LOC_SOH.UNIT_COST%TYPE)
RETURN BOOLEAN IS

   L_function           VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.GET_ELC_TOTAL_LOC';

   L_elc_prim           ORDLOC_EXP.EST_EXP_VALUE%TYPE;
   L_total_exp          ORDLOC_EXP.EST_EXP_VALUE%TYPE;
   L_currency_exp       CURRENCIES.CURRENCY_CODE%TYPE;
   L_exchange_rate_exp  CURRENCY_RATES.EXCHANGE_RATE%TYPE;
   L_total_dty          ORDLOC_EXP.EST_EXP_VALUE%TYPE;
   L_currency_dty       CURRENCIES.CURRENCY_CODE%TYPE;
   --OLR V1.02 Insert START
   L_item               ITEM_MASTER.ITEM%TYPE;
   L_pack_no            ITEM_MASTER.ITEM%TYPE;
   --OLR V1.02 Insert END

BEGIN

   /* OLR V1.02 Delete START
   if ELC_CALC_SQL.CALC_TOTALS(O_error_message,                 -- O_error_message
                               L_elc_prim,                      -- O_total_elc
                               L_total_exp,                     -- O_total_exp
                               L_currency_exp,                  -- O_exp_currency
                               L_exchange_rate_exp,             -- O_exchange_rate_exp
                               L_total_dty,                     -- O_total_dty
                               L_currency_dty,                  -- O_dty_currency
                               I_item_rec.order_no,             -- I_order_no
                               I_item,                          -- I_item
                               I_comp_item,                     -- I_comp_item
                               NULL,                            -- I_zone_id
                               I_item_rec.loc,                  -- I_location
                               I_item_rec.supplier,             -- I_supplier
                               I_item_rec.origin_country_id,    -- I_origin_country_id
                               I_item_rec.import_country_id,    -- I_import_country_id
                               I_unit_cost_ord) = FALSE then    -- I_cost, in order currency
      return FALSE;
   end if;
   --OLR V1.02 Delete END */

   --OLR V1.02 Insert START
   if LP_so_elc_ind = 'Y' and I_item_rec.alc_finalize_ind = 'Y' then

      -- Identifying component item for a pack item
      if I_comp_item is NULL then
         L_item := I_item;
      else
         L_item := I_comp_item;
      end if;

      -- Identifying pack item
      if I_comp_item is NULL then
         L_pack_no := NULL;
      else
         L_pack_no := I_item;
      end if;

      if ALC_SQL.CALC_TOTALS_FINALIZED(O_error_message,
                                       L_elc_prim,
                                       I_item_rec.order_no,
                                       L_item,
                                       L_pack_no,
                                       I_item_rec.loc,
                                       I_item_rec.supplier,
                                       I_item_rec.origin_country_id,
                                       I_item_rec.import_country_id,
                                       I_item_rec.ship_no,
                                       I_unit_cost_ord) = FALSE then
         return FALSE;
      end if;
   else
      if ELC_CALC_SQL.CALC_TOTALS(O_error_message,              -- O_error_message
                                  L_elc_prim,                   -- O_total_elc
                                  L_total_exp,                  -- O_total_exp
                                  L_currency_exp,               -- O_exp_currency
                                  L_exchange_rate_exp,          -- O_exchange_rate_exp
                                  L_total_dty,                  -- O_total_dty
                                  L_currency_dty,               -- O_dty_currency
                                  I_item_rec.order_no,          -- I_order_no
                                  I_item,                       -- I_item
                                  I_comp_item,                  -- I_comp_item
                                  NULL,                         -- I_zone_id
                                  I_item_rec.loc,               -- I_location
                                  I_item_rec.supplier,          -- I_supplier
                                  I_item_rec.origin_country_id, -- I_origin_country_id
                                  I_item_rec.import_country_id, -- I_import_country_id
                                  I_unit_cost_ord) = FALSE then -- I_cost, in order currency
         return FALSE;
      end if;
   end if;
   --OLR V1.02 Insert END

   --- Convert landed cost in primary currency to local currency
   if CURRENCY_SQL.CONVERT(O_error_message,
                           L_elc_prim,
                           I_values.prim_currency,
                           I_values.loc_currency,
                           O_elc_loc,
                           'C',
                           NULL,
                           NULL) = FALSE then
      return FALSE;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END GET_ELC_TOTAL_LOC;

-------------------------------------------------------------------------------

FUNCTION PACK_LEVEL_UPDATES(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                            I_values          IN OUT   COST_RETAIL_QTY_RECORD,
                            I_item_rec        IN       ITEM_RCV_RECORD,
                            I_weight          IN       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE,
                            I_weight_uom      IN       UOM_CLASS.UOM%TYPE)
RETURN BOOLEAN IS

   L_function             VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.PACK_LEVEL_UPDATES';

   L_rowid                ROWID;
   L_upd_qty              ITEM_LOC_SOH.STOCK_ON_HAND%TYPE := 0;
   L_cycle_count          STAKE_HEAD.CYCLE_COUNT%TYPE;

   L_store                STORE.STORE%TYPE;
   L_wh                   WH.WH%TYPE;

   L_first_received       DATE:=NULL;
   L_last_received        DATE:=NULL;
   L_qty_received         SHIPSKU.QTY_RECEIVED%TYPE:=NULL;
   L_new_average_weight   ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE;

   L_table                VARCHAR2(30);
   L_key1                 VARCHAR2(100);
   L_key2                 VARCHAR2(100);
   RECORD_LOCKED          EXCEPTION;
   PRAGMA                 EXCEPTION_INIT(Record_Locked, -54);

   cursor C_GET_RECEIVE_AS_TYPE is
      select NVL(receive_as_type, 'P')
        from item_loc
       where item = I_item_rec.item
         and loc  = I_item_rec.loc;

   cursor C_LOCK_ITEM_LOC_SOH_PACK is
      select rowid,
             stock_on_hand + in_transit_qty
             + pack_comp_soh
             + pack_comp_intran total_soh,
             average_weight
        from item_loc_soh
       where item = I_item_rec.item
         and loc  = I_item_rec.loc
         for update nowait;

   L_soh_pack_rec   C_LOCK_ITEM_LOC_SOH_PACK%ROWTYPE;

BEGIN

   if I_item_rec.tran_type = 'R' or
      I_item_rec.new_ordloc_ind= 'Y' then

      L_first_received := I_item_rec.tran_date;
      L_last_received  := I_item_rec.tran_date;
      L_qty_received   := I_values.input_qty;

   end if;

   if I_item_rec.loc_type = 'W' then

      SQL_LIB.SET_MARK('OPEN','C_GET_RECEIVE_AS_TYPE','ITEM_LOC', 'Item:'||I_item_rec.item||
                       ' Loc:'||to_char(I_item_rec.loc));
      open C_GET_RECEIVE_AS_TYPE;
      fetch C_GET_RECEIVE_AS_TYPE into I_values.receive_as_type;
      close C_GET_RECEIVE_AS_TYPE;

      if I_values.receive_as_type = 'P' then

         --- If the receipt took place during a stock count that is now closed
         --- special processing is needed.  When the stock count was completed, it
         --- included the stock contained in the receipt currently being processed.
         --- Since RMS didn't know about the receipt, adjustments were made and the
         --- stock_on_hand was updated to reflect the qty in the count that RMS was
         --- not aware of.
         ---
         --- When a receipt comes in under these circumstances we do not want to
         --- update stock_on_hand -- it already has been accounted for.  We do want
         --- to write a adjustment to tran_data.  This tran_data write essentially
         --- reverses the tran_data that was written to explain the stock counts
         --- discrepancy.

         if I_item_rec.tran_date < LP_vdate then
            if STKCNT_ATTRIB_SQL.STOCK_COUNT_PROCESSED(O_error_message,
                                                       I_values.stock_count_processed,
                                                       L_cycle_count,
                                                       I_values.snapshot_cost,
                                                       I_values.snapshot_retail,
                                                       I_item_rec.tran_date,
                                                       I_item_rec.item,
                                                       I_item_rec.loc_type,
                                                       I_item_rec.loc) = FALSE then
               return FALSE;
            end if;
         end if;

         --- If a completed stock count was found, the qty was already accounted
         --- for by the stock count.
         if I_values.stock_count_processed then
            L_upd_qty := 0;
         else
            L_upd_qty := I_values.input_qty;
         end if;

         --- Update item loc soh
         L_rowid := NULL;
         L_table := 'ITEM_LOC_SOH';
         L_key1  := I_item_rec.item;
         L_key2  := to_char(I_item_rec.loc);
         SQL_LIB.SET_MARK('UPDATE',NULL,'ITEM_LOC_SOH', 'Item:'||I_item_rec.item||
                       ' Loc:'||to_char(I_item_rec.loc));
         open C_LOCK_ITEM_LOC_SOH_PACK;
         fetch C_LOCK_ITEM_LOC_SOH_PACK into L_soh_pack_rec;
         close C_LOCK_ITEM_LOC_SOH_PACK;

         if I_item_rec.catch_weight_ind = 'Y' and
            I_item_rec.simple_pack_ind =  'Y' then
            if CATCH_WEIGHT_SQL.CALC_AVERAGE_WEIGHT(O_error_message,
                                                    L_new_average_weight,
                                                    I_item_rec.item,  -- pack
                                                    I_item_rec.loc,
                                                    I_item_rec.loc_type,
                                                    L_soh_pack_rec.total_soh,
                                                    L_soh_pack_rec.average_weight,
                                                    L_upd_qty, -- pack qty
                                                    I_weight,  -- pack weight
                                                    I_weight_uom) = FALSE then
               return FALSE;
            end if;
         end if;
         ---
         update item_loc_soh
            set stock_on_hand        = stock_on_hand + L_upd_qty,
                soh_update_datetime  = SYSDATE,
                last_update_datetime = SYSDATE,
                last_update_id       = LP_user,
                first_received       = NVL(first_received, L_first_received),
                last_received        = NVL(L_last_received, last_received),
                qty_received         = NVL(L_qty_received, qty_received),
                average_weight       = NVL(L_new_average_weight,average_weight)
          where rowid = L_soh_pack_rec.rowid;

         if I_item_rec.loc_type = 'W' then
            L_wh    := I_item_rec.loc;
            L_store := -1;
         else
            L_store := I_item_rec.loc;
            L_wh    := -1;
         end if;
         --- Update the snapshot
         if UPDATE_SNAPSHOT_SQL.EXECUTE(O_error_message,
                                        'RCV',
                                        I_item_rec.item,
                                        L_store,
                                        L_wh,
                                        I_item_rec.tran_date,
                                        LP_vdate,
                                        I_values.input_qty) = FALSE then
            return FALSE;
         end if;

      end if; --receive_as_type is P

   end if; -- loc_type = W

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END PACK_LEVEL_UPDATES;

-------------------------------------------------------------------------------

FUNCTION SET_AV_COST_OTB_COST(O_error_message        IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                              IO_values              IN OUT   COST_RETAIL_QTY_RECORD,
                              I_pack_no              IN       ITEM_MASTER.ITEM%TYPE,
                              I_item                 IN       ITEM_MASTER.ITEM%TYPE,
                              I_comp_item            IN       ITEM_MASTER.ITEM%TYPE,
                              I_comp_unit_cost_loc   IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                              I_item_rec             IN       ITEM_RCV_RECORD)
RETURN BOOLEAN IS

   L_function           VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.SET_AV_COST_OTB_COST';

   --OLR V1.02 Inserted START patch 13040041
   L_simple_pack_qty PACKITEM_BREAKOUT.PACK_ITEM_QTY%TYPE;

   cursor C_GET_SIMPLE_PACK_QTY is
   select vpq.qty
     from v_packsku_qty vpq
    where vpq.pack_no = I_pack_no;
   --OLR V1.02 Inserted START patch 13040041

BEGIN

   if (LP_so_elc_ind = 'Y') then    --- Landed cost is used.

      if (I_item_rec.pack_type != 'V') then   --- Not a vendor pack

         --- If landed cost is used and the item is not a vendor pack, the cost that
         --- will be used to update the average cost of the item (or component item
         --- if the item is a buyer pack) is the total landed cost in the local currency
         if SMR_ORDER_RCV_SQL.GET_ELC_TOTAL_LOC(O_error_message,                        -- O_error_message
                                            IO_values.total_lc_loc,                 -- O_elc_loc
                                            I_item_rec,                             -- I_item_rec
                                            IO_values,                              -- I_values
                                            NVL(I_pack_no, I_item),                 -- I_item
                                            I_comp_item,                            -- I_comp_item
                                            IO_values.unit_cost_order) = FALSE then -- I_unit_cost_ord
            return FALSE;
         end if;

         --- Average cost will be the total landed cost in local currency
         IO_values.av_cost_loc := IO_values.total_lc_loc;

      else --- Vendor pack

         --- If landed cost is used and the the item is a vendor pack, the cost that will be used
         --- to update the average cost of the component item of the vendor pack at the receiving
         --- location is calculated by:
         ---    taking the landed cost of the vendor pack and multiplying this by the ratio of the
         ---    component item's cost to the total pack cost (the cost of the component item divided
         ---    by the sum of the costs for all the component items in the pack).

         if (IO_values.pack_cost_loc = 0) then

            --OLR V1.02 Inserted START patch 13040041
            if I_item_rec.simple_pack_ind = 'Y' then

               open C_GET_SIMPLE_PACK_QTY;
               fetch C_GET_SIMPLE_PACK_QTY into L_simple_pack_qty;
               close C_GET_SIMPLE_PACK_QTY;

               IO_values.av_cost_loc := IO_values.total_lc_loc/L_simple_pack_qty;

            else
            --OLR V1.02 Inserted END patch 13040041
               IO_values.av_cost_loc := 0;

            end if; --OLR V1.02 Inserted patch 13040041

         else
            IO_values.av_cost_loc := IO_values.total_lc_loc * (I_comp_unit_cost_loc / IO_values.pack_cost_loc);
         end if;

      end if;

      --OLR V1.02 Inserted patch 13029695
      if L_deposit_complex_ind = 'Y' then
         IO_values.av_cost_loc := IO_values.total_lc_loc;

         if SMR_ORDER_RCV_SQL.GET_COMPLEX_ADJ_COST(O_error_message,
                                               IO_values.av_cost_loc,
                                               NVL(I_pack_no,I_item),
                                               NVL(I_comp_item,I_item),
                                               NVL(I_item_rec.loc,I_item_rec.phy_loc),
                                               I_item_rec.supplier) = FALSE then
            return FALSE;
         end if;

      end if;
      --OLR V1.02 Inserted patch 13029695


      --- The cost of the item to be used for OTB updates will be the previously calculated
      --- landed cost of the item converted to primary currency.
      if CURRENCY_SQL.CONVERT(O_error_message,
                              IO_values.total_lc_loc,
                              IO_values.loc_currency,
                              IO_values.prim_currency,
                              IO_values.otb_cost_prim,
                              'C',
                              NULL,
                              NULL) = FALSE then
         return FALSE;
      end if;

   else   --- elc_ind = 'N', landed cost is not used

      if (I_item_rec.pack_type = 'N') then

         --- If the item is not a pack, the cost that will be used to update the average cost
         --- of the item is the item's order cost in the local currency.

         IO_values.av_cost_loc := IO_values.unit_cost_loc;

      else

         --- If the item is a pack, the cost that will be used to update the average cost
         --- of the component item of the pack at the receiving location is calculated by:
         ---    taking the order cost of the pack and multiplying this by the ratio of the
         ---    component item's cost to the total pack cost (the cost of the component item divided
         ---    by the sum of the costs for all the component items in the pack).

         if (IO_values.pack_cost_loc = 0) then

            --OLR V1.02 Inserted START patch 13040041
            if I_item_rec.simple_pack_ind = 'Y' then
               open C_GET_SIMPLE_PACK_QTY;
               fetch C_GET_SIMPLE_PACK_QTY into L_simple_pack_qty;
               close C_GET_SIMPLE_PACK_QTY;
               IO_values.av_cost_loc := IO_values.unit_cost_loc/L_simple_pack_qty;
            else
            --OLR V1.02 Inserted END patch 13040041

               IO_values.av_cost_loc := 0;

            end if; --OLR V1.02 Inserted START patch 13040041

         else
            IO_values.av_cost_loc := IO_values.unit_cost_loc * (I_comp_unit_cost_loc / IO_values.pack_cost_loc);
         end if;

      end if;   --- if (I_item_rec.pack_type = 'B')

      --OLR V1.02 Inserted patch 13029695
      if L_deposit_complex_ind = 'Y' then
         IO_values.av_cost_loc := IO_values.unit_cost_loc;

         if SMR_ORDER_RCV_SQL.GET_COMPLEX_ADJ_COST(O_error_message,
                                               IO_values.av_cost_loc,
                                               NVL(I_pack_no,I_item),
                                               NVL(I_comp_item,I_item),
                                               NVL(I_item_rec.loc,I_item_rec.phy_loc),
                                               I_item_rec.supplier) = FALSE then
            return FALSE;
         end if;

      end if;
      --OLR V1.02 Inserted patch 13029695

      --- The cost of the item to be used for OTB updates will be the previously calculated
      --- unit cost of the item in the primary currency.
      IO_values.otb_cost_prim := IO_values.unit_cost_prim;

   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END SET_AV_COST_OTB_COST;

-------------------------------------------------------------------------------

FUNCTION UPDATE_ITEM_STOCK(O_error_message           IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                           O_neg_soh_ac              IN OUT   ITEM_LOC_SOH.UNIT_COST%TYPE,
                           O_neg_soh                 IN OUT   ITEM_LOC_SOH.STOCK_ON_HAND%TYPE,
                           I_item                    IN       ITEM_MASTER.ITEM%TYPE,
                           I_comp_ind                IN       VARCHAR,
                           I_loc                     IN       ITEM_LOC.LOC%TYPE,
                           I_qty                     IN       ITEM_LOC_SOH.STOCK_ON_HAND%TYPE,
                           I_weight                  IN       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE,
                           I_weight_uom              IN       UOM_CLASS.UOM%TYPE,
                           I_av_cost_loc             IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                           I_total_cost_loc          IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                           I_tran_date               IN       DATE,
                           I_tran_type               IN       VARCHAR2,
                           I_upd_unit_cost           IN       VARCHAR2,
                           I_stock_count_processed   IN       BOOLEAN,
                           I_new_ordloc_ind          IN       VARCHAR2,
                           I_receive_as_type         IN       ITEM_LOC.RECEIVE_AS_TYPE%TYPE,
                           I_inv_status              IN       INV_STATUS_QTY.INV_STATUS%TYPE,
                           I_loc_type                IN       ITEM_LOC_SOH.LOC_TYPE%TYPE,
                           I_order_no                IN       ORDHEAD.ORDER_NO%TYPE,
                           I_unit_retail_loc         IN       ORDLOC.UNIT_RETAIL%TYPE)
RETURN BOOLEAN IS

   L_function         VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.UPDATE_ITEM_STOCK';

   L_stock_on_hand    ITEM_LOC_SOH.STOCK_ON_HAND%TYPE := 0;
   L_av_cost          ITEM_LOC_SOH.AV_COST%TYPE       := 0;
   L_upd_qty          ITEM_LOC_SOH.STOCK_ON_HAND%TYPE := 0;
   L_soh_curr         ITEM_LOC_SOH.STOCK_ON_HAND%TYPE := 0;
   L_av_cost_curr     ITEM_LOC_SOH.AV_COST%TYPE       := 0;
   L_qty              ITEM_LOC_SOH.STOCK_ON_HAND%TYPE := 0;
   L_var              ITEM_LOC_SOH.STOCK_ON_HAND%TYPE := 0;

   L_first_received   DATE:=NULL;
   L_last_received    DATE:=NULL;
   L_qty_received         SHIPSKU.QTY_RECEIVED%TYPE       :=NULL;

   L_rowid            ROWID                           := NULL;
   L_table            VARCHAR2(30);
   L_key1             VARCHAR2(100);
   L_key2             VARCHAR2(100);
   RECORD_LOCKED      EXCEPTION;
   PRAGMA             EXCEPTION_INIT(Record_Locked, -54);
   L_average_weight_new   ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE;
   L_av_weight            ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE;
   L_wac_recalc_adj_ind   UNIT_OPTIONS.WAC_RECALC_ADJ_IND%TYPE;
   L_recalc_ind           BOOLEAN DEFAULT NULL;

   cursor C_STOCK is
      select rowid,
             stock_on_hand + pack_comp_soh + in_transit_qty + pack_comp_intran,
             av_cost,
             average_weight
        from item_loc_soh
       where item = I_item
         and loc  = I_loc
         for update nowait;

   cursor C_UNIT_OPTIONS is
      select wac_recalc_adj_ind
        from unit_options;

BEGIN

   --- If this is not an adjustment then update item_loc_soh 'received' fields
   if I_tran_type != 'A' or
      I_new_ordloc_ind = 'Y' then

      L_first_received := I_tran_date;
      L_last_received  := I_tran_date;
      L_qty_received   := I_qty;

   end if;

   L_table := 'ITEM_LOC_SOH';
   L_key1  := I_item;
   L_key2  := to_char(I_loc);
   SQL_LIB.SET_MARK('OPEN','C_STOCK','ITEM_LOC_SOH', 'Item:'||I_item||' Loc:'||to_char(I_loc));
   open C_STOCK;
   fetch C_STOCK into L_rowid,
                      L_stock_on_hand,
                      L_av_cost,
                      L_av_weight;
   close C_STOCK;

   L_soh_curr := L_stock_on_hand;
   L_av_cost_curr := L_av_cost;
   O_neg_soh := 0;

   SQL_LIB.SET_MARK('OPEN',
                    'C_UNIT_OPTIONS',
                    'UNIT_OPTIONS',
                    NULL);
   open C_UNIT_OPTIONS;
   SQL_LIB.SET_MARK('FETCH',
                    'C_UNIT_OPTIONS',
                    'UNIT_OPTIONS',
                    NULL);
   fetch C_UNIT_OPTIONS into L_wac_recalc_adj_ind;
   SQL_LIB.SET_MARK('CLOSE',
                    'C_UNIT_OPTIONS',
                    'UNIT_OPTIONS',
                    NULL);
   close C_UNIT_OPTIONS;

   --- If the stock on hand is negative then set output parameter so we
   --- can account for the average cost with a tran_data insert
   if L_stock_on_hand < 0 then
      O_neg_soh := L_stock_on_hand;
   end if;

   if L_wac_recalc_adj_ind = 'Y' then
      L_recalc_ind := TRUE;
   else
      L_recalc_ind := FALSE;
   end if;

      --- Calculate qty base on weight if necessary for catch weight items
      if I_weight     is NOT NULL and
         I_weight_uom is NOT NULL then
         if CATCH_WEIGHT_SQL.CALC_COMP_UPDATE_QTY(O_error_message,
                                                  L_qty,
                                                  I_item,
                                                  I_qty,
                                                  I_weight,
                                                  I_weight_uom) = FALSE then
            return FALSE;
         end if;
         --- calculate average weight
         if CATCH_WEIGHT_SQL.CALC_AVERAGE_WEIGHT(O_error_message,
                                                 L_average_weight_new,
                                                 I_item,
                                                 I_loc,
                                                 I_loc_type,
                                                 L_stock_on_hand,
                                                 L_av_weight, --need average weight from item loc soh
                                                 I_qty,
                                                 I_weight,
                                                 I_weight_uom,
                                                 L_recalc_ind) = FALSE then
            return FALSE;
      end if;
   else
      L_qty := I_qty;
   end if;

   --- If a completed stock count was found, don't include the received qty (which
   --- already is in stock_on_hand) in the average cost calculation.
   if I_stock_count_processed then
      L_stock_on_hand := L_stock_on_hand - L_qty;
      L_upd_qty := 0;
   else
      L_upd_qty := L_qty;
   end if;

   --- Calculate average cost when receiving items.  When subtracting items
   --- (L_qty < 0) we don't change the average cost.

            if STKLEDGR_ACCTING_SQL.WAC_CALC_QTY_CHANGE(O_error_message,
                                                        L_av_cost_curr,
                                                        O_neg_soh_ac,
                                                        L_av_cost,
                                                        L_stock_on_hand,
                                                        I_av_cost_loc,
                                                        L_qty,
                                                        I_total_cost_loc,
                                                        L_recalc_ind) = FALSE then
               return FALSE;
            end if;

   SQL_LIB.SET_MARK('UPDATE',NULL,'ITEM_LOC_SOH', 'rowid:'||L_rowid);
   update item_loc_soh
      set av_cost              = ROUND(L_av_cost_curr, 4),
          average_weight       = NVL(L_average_weight_new, average_weight),
          stock_on_hand        = DECODE(I_comp_ind,
                                        'Y', DECODE(I_receive_as_type,
                                                    'P', stock_on_hand,
                                                    stock_on_hand + L_upd_qty),
                                        stock_on_hand + L_upd_qty),
          soh_update_datetime  = DECODE(I_comp_ind,
                                        'Y', DECODE(I_receive_as_type,
                                                    'P', soh_update_datetime,
                                                    SYSDATE),
                                        SYSDATE),
          pack_comp_soh        = DECODE(I_comp_ind,
                                        'Y', DECODE(I_receive_as_type,
                                                    'P', pack_comp_soh + L_upd_qty,
                                                    pack_comp_soh),
                                        pack_comp_soh),
          last_update_datetime = SYSDATE,
          last_update_id       = LP_user,
          first_received       = NVL(first_received, L_first_received),
          last_received        = NVL(L_last_received, last_received),
          qty_received         = NVL(L_qty_received, qty_received)
    where rowid = L_rowid;

    if (I_comp_ind = 'N' or I_loc_type = 'S' or I_receive_as_type = 'E') then
      --- If receiving into trouble (non-sellable) move the stock to trouble
      if (I_inv_status is NOT NULL) and
         (I_inv_status != -1) then
         if UPD_INV_STATUS(O_error_message,
                           I_item,
                           I_inv_status,
                           I_qty,
                           I_total_cost_loc,                    -- I_total_cost
                           I_qty * I_unit_retail_loc,           -- I_total_retail
                           I_loc,
                           I_loc_type,
                           I_tran_date,
                           I_order_no) = FALSE then
            return FALSE;
         end if;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END UPDATE_ITEM_STOCK;

-------------------------------------------------------------------------------

FUNCTION STOCKLEDGER_INFO(O_error_message           IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                          I_neg_soh_ac              IN OUT   TRAN_DATA.TOTAL_COST%TYPE,
                          I_neg_soh                 IN       TRAN_DATA.UNITS%TYPE,
                          I_total_cost_loc          IN OUT   TRAN_DATA.TOTAL_COST%TYPE,
                          I_item                    IN       TRAN_DATA.ITEM%TYPE,
                          I_pack_ind                IN       ITEM_MASTER.PACK_IND%TYPE,
                          I_receive_as_type         IN       ITEM_LOC.RECEIVE_AS_TYPE%TYPE,
                          I_dept                    IN       TRAN_DATA.DEPT%TYPE,
                          I_class                   IN       TRAN_DATA.CLASS%TYPE,
                          I_subclass                IN       TRAN_DATA.SUBCLASS%TYPE,
                          I_tran_date               IN       DATE,
                          I_tran_type               IN       VARCHAR2,
                          I_receipt_qty             IN       TRAN_DATA.UNITS%TYPE,
                          I_total_retail_loc        IN       TRAN_DATA.TOTAL_RETAIL%TYPE,
                          I_shipment                IN       SHIPMENT.SHIPMENT%TYPE,
                          I_order_no                IN       ORDHEAD.ORDER_NO%TYPE,
                          I_stock_count_processed   IN       BOOLEAN,
                          I_snapshot_cost           IN       ORDLOC.UNIT_COST%TYPE,
                          I_snapshot_retail         IN       ORDLOC.UNIT_RETAIL%TYPE,
                          I_loc                     IN       ITEM_LOC.LOC%TYPE,
                          I_loc_type                IN       ITEM_LOC.LOC_TYPE%TYPE,
                          I_ref_pack_no             IN       TRAN_DATA.REF_PACK_NO%TYPE,
                          I_total_cost_excl_elc     IN       TRAN_DATA.TOTAL_COST_EXCL_ELC%TYPE)
RETURN BOOLEAN IS

   L_function       VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.STOCKLEDGER_INFO';

   L_tran_code      TRAN_DATA.TRAN_CODE%TYPE := 0;
   L_adj_code       TRAN_DATA.ADJ_CODE%TYPE  := NULL;
   L_total_cost     TRAN_DATA.TOTAL_COST%TYPE;
   L_total_retail   TRAN_DATA.TOTAL_RETAIL%TYPE;
   L_receipt_qty    TRAN_DATA.UNITS%TYPE;
   L_found          BOOLEAN;
   L_store          STORE.STORE%TYPE;
   L_wh             WH.WH%TYPE;
   L_neg_rct_qty    TRAN_DATA.UNITS%TYPE := 0;

BEGIN

   --- If this is an adjustment then set L_adj_code to
   --- 'U'nit adjustment for tran_data_insert
   if I_tran_type = 'A' then
      L_adj_code := 'U';
   end if;
   --- If there is a negative stock on hand then do a tran_data_insert
   --- to adjust for the negative stock position.
   if (I_neg_soh_ac != 0) then
      L_tran_code := 70;
      if I_receipt_qty <= 0 then
         L_neg_rct_qty := I_receipt_qty;
      else
         L_neg_rct_qty := I_neg_soh;
      end if;

      if STKLEDGR_SQL.BUILD_TRAN_DATA_INSERT(O_error_message,
                                             I_item,                        -- I_item
                                             I_dept,                        -- I_dept
                                             I_class,                       -- I_class
                                             I_subclass,                    -- I_subclass
                                             I_loc,                         -- I_loc
                                             I_loc_type,                    -- I_loc_type
                                             I_tran_date,                   -- I_tran_date
                                             L_tran_code,                   -- IO_tran_code
                                             NULL,                          -- I_adj_code
                                             L_neg_rct_qty,                 -- unit
                                             I_neg_soh_ac,                  -- IO_total_cost
                                             NULL,                          -- I_total_retail
                                             NULL,                          -- I_ref_no_1
                                             NULL,                          -- I_ref_no_2
                                             NULL,                          -- I_tsf_souce_store
                                             NULL,                          -- I_tsf_souce_wh
                                             NULL,                          -- I_old_unit_retail
                                             NULL,                          -- I_new_unit_retail
                                             NULL,                          -- I_source_dept
                                             NULL,                          -- I_source_class
                                             NULL,                          -- I_souce_subclass
                                             L_function,                    -- I_pgm_name
                                             NULL) = FALSE then             -- I_gl_ref_no
         return FALSE;
      end if;
   end if;

   --- Tran_data_insert to record receipt
   L_tran_code := 20;
   if STKLEDGR_SQL.BUILD_TRAN_DATA_INSERT(O_error_message,
                                          I_item,                        -- I_item
                                          I_dept,                        -- I_dept
                                          I_class,                       -- I_class
                                          I_subclass,                    -- I_subclass
                                          I_loc,                         -- I_loc
                                          I_loc_type,                    -- I_loc_type
                                          I_tran_date,                   -- I_tran_date
                                          L_tran_code,                   -- IO_tran_code
                                          L_adj_code,                    -- I_adj_code
                                          I_receipt_qty,                 -- I_units
                                          I_total_cost_loc,              -- IO_total_cost
                                          I_total_retail_loc,            -- I_total_retail
                                          I_order_no,                    -- I_ref_no_1
                                          I_shipment,                    -- I_ref_no_2
                                          NULL,                          -- I_tsf_souce_store
                                          NULL,                          -- I_tsf_souce_wh
                                          NULL,                          -- I_old_unit_retail
                                          NULL,                          -- I_new_unit_retail
                                          NULL,                          -- I_source_dept
                                          NULL,                          -- I_source_class
                                          NULL,                          -- I_souce_subclass
                                          L_function,                    -- I_pgm_name
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          I_ref_pack_no,                 -- I_ref_pack_no
                                          I_total_cost_excl_elc) = FALSE then
       return FALSE;
   end if;
   ---
   if CREATE_ORD_TSF_SQL.BUILD_TRAN_DATA_SG(O_error_message,
                                            I_order_no,
                                            I_item,
                                            I_total_cost_loc,
                                            I_total_retail_loc,
                                            I_receipt_qty,
                                            LP_tsf_no,
                                            I_ref_pack_no) = FALSE then
      return FALSE;
   end if;
   ---
   --- Update snapshot in any of these cases:
   ---    *) if receiving an item
   ---    *) if receiving loc is a store
   ---    *) if receive as type is 'E'aches
   if (I_pack_ind = 'N')
   or (I_loc_type = 'S')
   or (I_receive_as_type = 'E') then
      if I_loc_type = 'W' then
         L_store := -1;
         L_wh    := I_loc;
      else
         L_store := I_loc;
         L_wh    := -1;
      end if;

      if UPDATE_SNAPSHOT_SQL.EXECUTE(O_error_message,              -- O_error_message
                                     'RCV',                        -- I_tran_type
                                     I_item,                       -- I_item
                                     L_store,                      -- I_tran_store
                                     L_wh,                         -- I_tran_wh
                                     I_tran_date,                  -- I_tran_date
                                     LP_vdate,                     -- I_vdate
                                     I_receipt_qty) = FALSE then   -- I_adj_qty
         return FALSE;
      end if;
   end if;

   --- If the receipt took place during a stock count that is now closed
   --- special processing is needed.  When the stock count was completed, it
   --- included the stock contained in the receipt currently being processed.
   --- Since RMS didn't know about the receipt, adjustments were made and the
   --- stock_on_hand was updated to reflect the qty in the count that RMS was
   --- not aware of.
   ---
   --- When a receipt comes in under these circumstances we do not want to
   --- update stock_on_hand -- it already has been accounted for.  We DO want
   --- to write an adjustment to tran_data.  This tran_data write essentially
   --- reverses the tran_data that was written to explain the stock counts
   --- discrepancy.

   if I_stock_count_processed then
      L_tran_code    := 22;
      L_total_cost   := I_snapshot_cost * I_receipt_qty * -1;
      L_total_retail := I_snapshot_retail * I_receipt_qty * -1;
      L_receipt_qty  := I_receipt_qty * -1;

      if STKLEDGR_SQL.BUILD_TRAN_DATA_INSERT(O_error_message,
                                             I_item,                        -- I_item
                                             I_dept,                        -- I_dept
                                             I_class,                       -- I_class
                                             I_subclass,                    -- I_subclass
                                             I_loc,                         -- I_loc
                                             I_loc_type,                    -- I_loc_type
                                             I_tran_date,                   -- I_tran_date
                                             L_tran_code,                   -- IO_tran_code
                                             L_adj_code,                    -- I_adj_code
                                             L_receipt_qty,                 -- I_units
                                             L_total_cost,                  -- IO_total_cost
                                             L_total_retail,                -- I_total_retail
                                             I_order_no,                    -- I_ref_no_1
                                             I_shipment,                    -- I_ref_no_2
                                             NULL,                          -- I_tsf_souce_store
                                             NULL,                          -- I_tsf_souce_wh
                                             NULL,                          -- I_old_unit_retail
                                             NULL,                          -- I_new_unit_retail
                                             NULL,                          -- I_source_dept
                                             NULL,                          -- I_source_class
                                             NULL,                          -- I_souce_subclass
                                             L_function,                    -- I_pgm_name
                                             NULL) = FALSE then             -- I_gl_ref_no
         return FALSE;
      end if;

   end if;

   --- Call flush
   if STKLEDGR_SQL.FLUSH_TRAN_DATA_INSERT (O_error_message) = FALSE then
      return FALSE;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END STOCKLEDGER_INFO;

-------------------------------------------------------------------------------

FUNCTION UPD_INV_STATUS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                        I_item            IN       ITEM_MASTER.ITEM%TYPE,
                        I_inv_status      IN       SHIPSKU.INV_STATUS%TYPE,
                        I_qty             IN       ITEM_LOC_SOH.STOCK_ON_HAND%TYPE,
                        I_total_cost      IN       ORDLOC.UNIT_COST%TYPE      DEFAULT NULL,
                        I_total_retail    IN       ORDLOC.UNIT_RETAIL%TYPE    DEFAULT NULL,
                        I_loc             IN       ITEM_LOC.LOC%TYPE,
                        I_loc_type        IN       ITEM_LOC.LOC_TYPE%TYPE,
                        I_tran_date       IN       PERIOD.VDATE%TYPE,
                        I_order_no        IN       ORDHEAD.ORDER_NO%TYPE   DEFAULT NULL)
RETURN BOOLEAN IS

   L_found       BOOLEAN;
   L_function    TRAN_DATA.PGM_NAME%TYPE  := 'SMR_ORDER_RCV_SQL.UPD_INV_STATUS';
   L_tran_code   TRAN_DATA.TRAN_CODE%TYPE := 25;
   L_reason      INV_ADJ.REASON%TYPE      := NULL;

BEGIN

   if INVADJ_SQL.ADJ_UNAVAILABLE(I_item,
                                 I_inv_status,
                                 I_loc_type,
                                 I_loc,
                                 I_qty,
                                 O_error_message,
                                 L_found) = FALSE then
      return FALSE;
   end if;
   if (I_total_cost IS NULL AND I_total_retail IS NULL AND I_order_no IS NULL) then
      if INVADJ_SQL.ADJ_TRAN_DATA(I_item,
                                  I_loc_type,
                                  I_loc,
                                  I_qty,
                                  L_function,
                                  I_tran_date,
                                  L_tran_code,
                                  L_reason,
                                  I_inv_status,
                                  NULL,    --I_wac
                                  NULL,    --I_unit_retail
                                  O_error_message,
                                  L_found) = FALSE then
         return FALSE;
      end if;
   else
      if INVADJ_SQL.ADJ_TRAN_DATA(I_item,
                                  I_loc_type,
                                  I_loc,
                                  I_qty,
                                  I_total_cost,
                                  I_total_retail,
                                  I_order_no,
                                  L_function,
                                  I_tran_date,
                                  L_tran_code,
                                  L_reason,
                                  I_inv_status,
                                  NULL,  --I_wac
                                  NULL,  --I_unit_retail
                                  O_error_message,
                                  L_found) = FALSE then
         return FALSE;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                             SQLERRM,
                                             L_function,
                                             TO_CHAR(SQLCODE));
      return FALSE;
END UPD_INV_STATUS;

-------------------------------------------------------------------------------

FUNCTION SUP_DATA_INSERTS(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                          I_supplier        IN       SUPS.SUPPLIER%TYPE,
                          I_dept            IN       DEPS.DEPT%TYPE,
                          I_tran_date       IN       DATE,
                          I_cost_prim       IN       ITEM_LOC_SOH.UNIT_COST%TYPE,
                          I_retail_prim     IN       ITEM_LOC.UNIT_RETAIL%TYPE)
RETURN BOOLEAN IS

   L_function     VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.SUP_DATA_INSERTS';

BEGIN

   P_sup_data_size        := P_sup_data_size + 1;
   P_sup_data_dept(P_sup_data_size)       := I_dept;
   P_sup_data_supplier(P_sup_data_size)   := I_supplier;
   P_sup_data_day_date(P_sup_data_size)   := I_tran_date;
   P_sup_data_tran_type(P_sup_data_size)  := 1;
   P_sup_data_amount(P_sup_data_size)     := I_cost_prim;

   P_sup_data_size        := P_sup_data_size + 1;
   P_sup_data_dept(P_sup_data_size)       := I_dept;
   P_sup_data_supplier(P_sup_data_size)   := I_supplier;
   P_sup_data_day_date(P_sup_data_size)   := I_tran_date;
   P_sup_data_tran_type(P_sup_data_size)  := 2;
   P_sup_data_amount(P_sup_data_size)     := I_retail_prim;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END SUP_DATA_INSERTS;

-------------------------------------------------------------------------------

FUNCTION FLUSH_SUP_DATA_CACHE(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE)
RETURN BOOLEAN IS

   L_function   VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.FLUSH_SUP_DATA_CACHE';

BEGIN

   if P_sup_data_size > 0 then
      FORALL i IN 1..P_sup_data_size
         insert into sup_data
                   ( dept,
                     supplier,
                     day_date,
                     tran_type,
                     amount)
            values ( P_sup_data_dept(i),
                     P_sup_data_supplier(i),
                     P_sup_data_day_date(i),
                     P_sup_data_tran_type(i),
                     P_sup_data_amount(i));

   end if;

   P_sup_data_size := 0;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END FLUSH_SUP_DATA_CACHE;

-------------------------------------------------------------------------------

FUNCTION CHECK_AGAINST_CONTRACT(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                                I_values          IN OUT   COST_RETAIL_QTY_RECORD,
                                I_item_rec        IN       ITEM_RCV_RECORD)
RETURN BOOLEAN IS

   L_function               VARCHAR2(60)  :=  'SMR_ORDER_RCV_SQL.CHECK_AGAINST_CONTRACT';
   L_table                  VARCHAR2(30)  :=  NULL;
   L_key1                   VARCHAR2(100) :=  NULL;
   L_key2                   VARCHAR2(100) :=  NULL;
   RECORD_LOCKED            EXCEPTION;
   PRAGMA                   EXCEPTION_INIT(Record_Locked, -54);

   L_update_qty             ORDLOC.QTY_RECEIVED%TYPE;
   L_add_del_ind            VARCHAR2(1);
   L_qty_left_to_add        ORDLOC.QTY_RECEIVED%TYPE;
   L_qty_left_to_subtract   ORDLOC.QTY_RECEIVED%TYPE;
   L_adequate_sup_avail     BOOLEAN;

   cursor C_ADD_CONTRACT_DETAIL is
      select NVL(qty_ordered,0) - NVL(qty_received,0) available_qty
        from contract_detail
       where contract_no = I_values.cont_no
         and (   (item_level_index = 1 and
                  item = I_item_rec.item)
              or (item_level_index = 2 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_1 = diff_1)
              or (item_level_index = 3 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_2 = diff_2)
              or (item_level_index = 4 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_3 = diff_3)
              or (item_level_index = 5 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_4 = diff_4)
              or (item_level_index = 6 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent)))
       order by ready_date,
             item_level_index
         for update of qty_received nowait;

   --- Order the cursor in reverse when updating with a negative qty
   cursor C_DEL_CONTRACT_DETAIL is
      select NVL(qty_received,0) available_qty
        from contract_detail
       where contract_no = I_values.cont_no
         and (   (item_level_index = 1 and
                  item = I_item_rec.item)
              or (item_level_index = 2 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_1 = diff_1)
              or (item_level_index = 3 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_2 = diff_2)
              or (item_level_index = 4 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_3 = diff_3)
              or (item_level_index = 5 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent) and
                  I_item_rec.diff_4 = diff_4)
              or (item_level_index = 6 and
                  (item_parent = I_item_rec.item_parent or
                   item_grandparent = I_item_rec.item_grandparent)))
       order by ready_date desc,
             item_level_index desc
         for update of qty_received nowait;

BEGIN

   --- Get contract type
   if CONTRACT_SQL.GET_CONTRACT_TYPE(O_error_message,
                                     I_values.cont_type,
                                     I_values.cont_no) = FALSE then
      return FALSE;
   end if;

   --- If contract was not found then error out.
   if I_values.cont_type is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('INV_CONTRACT_SEARCH',NULL,NULL,NULL);
      return FALSE;
   end if;

   --- Get unit_cost from contract_cost table
   if CONTRACT_SQL.GET_UNIT_COST(O_error_message,
                                 I_item_rec.item,
                                 I_values.cont_no,
                                 I_values.cont_cost) = FALSE then
      return FALSE;
   end if;

   --- If there is an overage amount != 0, that means we received an amount over
   --- the qty initiallly ordered.  The contract needs to be updated in this case.
   --- Set add/delete indicator and make sure update_qty is a positive number

   if I_values.overage_qty > 0 then
      L_add_del_ind := 'A';
      L_update_qty := I_values.overage_qty;
   elsif I_values.overage_qty < 0 then
      L_add_del_ind := 'D';
      L_update_qty := I_values.overage_qty * -1;
   end if;


   if I_values.overage_qty != 0 then
      --- Update_orditem: updates sup_avail.qty_avail and .last_update_date for item/supplier
      --- and updates contract_detail.qty_ordered for contract_no/item
      if CONTRACT_ORDER_SQL.UPDATE_ORDITEM(O_error_message,       -- O_error_message
                                           L_adequate_sup_avail,  -- O_adequate_sup_avail (BOOLEAN)
                                           I_values.cont_no,      -- I_contract_no
                                           I_item_rec.order_no,   -- I_order_no
                                           I_item_rec.item,       -- I_item
                                           L_update_qty,          -- I_qty_ordered
                                           I_values.cont_type,    -- I_contract_type
                                           L_add_del_ind,         -- I_add_delete_ind: add_to/delete_from order
                                           'Y',                   -- I_allow_over_order_ind:
                                           TRUE) = FALSE then     -- I_ignore_sup_avail
         return FALSE;
      end if;
   end if;

   --- If we have an A or B type contract we need to update contract_detail.qty_received
   if I_values.cont_type in ('A','B') then

      if I_values.input_qty > 0 then

         --- If the input qty is positive, then we will add to received qty
         L_qty_left_to_add := I_values.input_qty;

         L_table := 'C_ADD_CONTRACT_DETAIL';
         L_key1  := TO_CHAR(I_values.cont_no);
         L_key2  := I_item_rec.item;

         FOR rec IN C_ADD_CONTRACT_DETAIL LOOP

            if rec.available_qty >= L_qty_left_to_add then

               --- If the available qty on contract_detail (qty_ordered - qty_received)
               --- is greater than the qty_left_to_add then we can update this record
               --- with the entire qty_left_to_add.

               L_update_qty := L_qty_left_to_add;

            else

               --- Otherwise, update this record to bring the qty received up to the
               --- qty ordered and we will have more qty_left_to_add for the next record.

               L_update_qty := rec.available_qty;

            end if;

            --- Subtract the update_qty to get the new qty_left_to_add
            L_qty_left_to_add := L_qty_left_to_add - L_update_qty;

            SQL_LIB.SET_MARK('UPDATE',NULL,'C_ADD_CONTRACT_DETAIL',
                             'Contract:'||to_char(I_values.cont_no)||' Item:'||I_item_rec.item);

            update contract_detail
               set qty_received = NVL(qty_received,0) + L_update_qty
             where current of C_ADD_CONTRACT_DETAIL;

            EXIT WHEN L_qty_left_to_add <= 0;

         end LOOP;

         if L_qty_left_to_add > 0 then

            --- If there is any qty_left_to_add then we will add it to
            --- the first record returned in the cursor.

            FOR rec IN C_ADD_CONTRACT_DETAIL LOOP

               SQL_LIB.SET_MARK('UPDATE',NULL,'C_ADD_CONTRACT_DETAIL',
                                'Contract:'||to_char(I_values.cont_no)||' Item:'||I_item_rec.item);

               update contract_detail
                  set qty_received = NVL(qty_received,0) + L_qty_left_to_add
                where current of C_ADD_CONTRACT_DETAIL;

               EXIT;  -- only need one record to get rid of the qty_left_to_add

            end LOOP;

         end if;

      elsif I_values.input_qty < 0 then

         --- Input_qty is negative, so update contract_detail in reverse order.
         --- Make the qty_left_to_subtract a positive value to make the math
         --- easier to understand.

         L_qty_left_to_subtract := I_values.input_qty * -1;

         L_table := 'C_DEL_CONTRACT_DETAIL';
         L_key1  := TO_CHAR(I_values.cont_no);
         L_key2  := I_item_rec.item;

         FOR rec IN C_DEL_CONTRACT_DETAIL LOOP

            if rec.available_qty - L_qty_left_to_subtract >= 0 then

               --- If the available qty on contract_detail (qty_received) minus the
               --- qty_left_to_subtract is greater than zero then we want to update this
               --- record with the entire qty_left_to_subtract.

               L_update_qty := L_qty_left_to_subtract;

            else

               --- Otherwise, update this record with the available_qty (qty_received)
               --- to bring the qty received down to zero and we will have more
               --- qty_left_to_subtract for the next record.

               L_update_qty := rec.available_qty;

            end if;

            --- Subtract the update_qty to get the new qty_left_to_subtract
            L_qty_left_to_subtract := L_qty_left_to_subtract - L_update_qty;

            SQL_LIB.SET_MARK('UPDATE',NULL,'C_DEL_CONTRACT_DETAIL',
                             'Contract:'||to_char(I_values.cont_no)||' Item:'||I_item_rec.item);

            update contract_detail
               set qty_received = NVL(qty_received,0) - L_update_qty
             where current of C_DEL_CONTRACT_DETAIL;

            EXIT WHEN L_qty_left_to_subtract <= 0;

         end LOOP;

         if L_qty_left_to_subtract > 0 then

            --- If there is any qty_left_to_subtract then we have a problem.
            --- We cannot "unreceive" more than the amount already received.
            --- This should never happen since we cannot do a negative adjustment
            --- for more than the qty received, but we will check here to be thorough.

            O_error_message := SQL_LIB.CREATE_MSG('ADJUST_GT_QTY_RECEIVED',NULL, NULL, NULL);
            return FALSE;

         end if;

      end if;   --- I_input_qty <> 0

   else -- contract_type in ('C','D')

      --- If overage is not 0 then update contract header
      if I_values.overage_qty != 0 then

         --- Lock the contract for update
         if CONTRACT_SQL.LOCK_CONTRACT(O_error_message,
                                       I_values.cont_no) = FALSE then
            return FALSE;
         end if;

         SQL_LIB.SET_MARK('UPDATE',NULL,'CONTRACT_HEADER', 'Contract:'||to_char(I_values.cont_no));
         update contract_header ch
            set ch.outstand_cost = ch.outstand_cost -
                                   (I_values.cont_cost * I_values.overage_qty)
          where contract_no = I_values.cont_no;

      end if;  -- overage_qty != 0

   end if;  -- contract_type

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END CHECK_AGAINST_CONTRACT;

-------------------------------------------------------------------------------
FUNCTION INVC_PROCESSING(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                         I_values          IN       COST_RETAIL_QTY_RECORD,
                         I_item_rec        IN       ITEM_RCV_RECORD)
RETURN BOOLEAN IS

   L_function   VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.INVC_PROCESSING';
   L_posted     BOOLEAN;

BEGIN
   if LP_so_ext_invc_match_ind = 'Y' then
      ---
      -- Only call ASN_TO_INVC if there is an ASN associated with the receipt.
      ---
      if  I_item_rec.tran_type = 'R' and I_item_rec.settlement_code = 'E' and I_item_rec.asn is not NULL  then

         if INVC_WRITE_SQL.ASN_TO_INVC(O_error_message,           -- O_error_message
                                       L_posted,                  -- O_posted
                                       I_item_rec.ship_no,        -- I_rcpt
                                       I_item_rec.supplier,       -- I_supplier
                                       'I',                       -- I_invc_type
                                       I_item_rec.item,           -- I_item
                                       I_values.unit_cost_order,  -- I_old_unit_cost, order currency
                                       NULL,                      -- I_new_unit_cost
                                       I_values.input_qty,        -- I_rcv_qty
                                       NULL,                      -- I_adj_qty
                                       NULL) = FALSE then         -- I_vat_region
            return FALSE;
         end if;

      elsif I_item_rec.tran_type <> 'R' then

         if INVC_WRITE_SQL.ASN_TO_INVC(O_error_message,           -- O_error_message
                                       L_posted,                  -- O_posted
                                       I_item_rec.ship_no,        -- I_rcpt
                                       I_item_rec.supplier,       -- I_supplier
                                       NULL,                      -- I_invc_type
                                       I_item_rec.item,           -- I_item
                                       I_values.unit_cost_order,  -- I_old_unit_cost, order currency
                                       NULL,                      -- I_new_unit_cost
                                       NULL,                      -- I_rcv_qty
                                       I_values.input_qty,        -- I_adj_qty
                                       NULL) = FALSE then         -- I_vat_region
            return FALSE;
         end if;

      end if;

   end if; -- inv_match_ind = Y
   --- An invoice can be created to reference future receipts of PO's.  This function
   --- updates any invoices that reference the PO with the PO's receipt number(s).
   if  (LP_so_ext_invc_match_ind = 'Y')
   and (I_item_rec.ship_origin != 4)  then
      if not INVC_MATCH_SQL.CHECK_ASSOC(O_error_message,
                                        I_item_rec.ship_no) then
         return FALSE;
      end if;
   end if;

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END INVC_PROCESSING;

-------------------------------------------------------------------------------

FUNCTION IB_LINK(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                 I_item_rec        IN       ITEM_RCV_RECORD)
RETURN BOOLEAN IS

   L_function     VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.IB_LINK';

   L_ib_wh_link   WH.WH%TYPE   := NULL;
   L_soh          ITEM_LOC_SOH.STOCK_ON_HAND%TYPE;

   cursor C_GET_IB_WH_LINK is
      select a.ib_wh_link
        from wh a
       where a.wh       = I_item_rec.loc
         and a.repl_ind = 'Y'
         and a.ib_ind   = 'N'
         and exists(select b.auto_ib_clear
                      from wh b
                     where b.wh            = a.ib_wh_link
                       and b.auto_ib_clear = 'Y');

BEGIN

   if I_item_rec.loc_type = 'W' and I_item_rec.order_orig_ind in (0,1) then
      --
      SQL_LIB.SET_MARK('OPEN','C_GET_IB_WH_LINK','WH', 'Loc:'||to_char(I_item_rec.loc));
      open C_GET_IB_WH_LINK;
      fetch C_GET_IB_WH_LINK into L_ib_wh_link;
      close C_GET_IB_WH_LINK;
      --
      if L_ib_wh_link is NOT NULL then

         if ITEMLOC_QUANTITY_SQL.GET_LOC_CURRENT_AVAIL(O_error_message,
                                                       L_soh,
                                                       I_item_rec.item,
                                                       L_ib_wh_link,
                                                       'W') = FALSE then
            return FALSE;
         end if;

         if TRANSFER_SQL.AUTOMATIC_BT_EXECUTE(O_error_message,
                                              I_item_rec.item,
                                              L_ib_wh_link,   -- from loc
                                              I_item_rec.loc, -- to loc
                                              L_soh) = FALSE then

            return FALSE;
         end if;

      end if; -- L_ib_wh_link is NOT NULL

   end if; --  LP_loc_type = W and L_ship_origin in (0,1)

   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END IB_LINK;

-------------------------------------------------------------------------------

FUNCTION OPEN_ORDER(O_error_message   IN OUT   VARCHAR2,
                    I_order_no        IN       ORDHEAD.ORDER_NO%TYPE)
RETURN BOOLEAN IS

   L_function      VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.OPEN_ORDER';

   L_rowid         ROWID;
   L_table         VARCHAR2(30);
   L_key1          VARCHAR2(100);
   L_key2          VARCHAR2(100);
   RECORD_LOCKED   EXCEPTION;
   PRAGMA          EXCEPTION_INIT(Record_Locked, -54);

   cursor C_LOCK_OPEN_ORDER is
      select oh.rowid
        from ordhead oh,
             ordloc ol
       where oh.order_no    = I_order_no
         and oh.status      = 'C'
         and ol.order_no    = oh.order_no
         and ol.qty_ordered > NVL(ol.qty_received,0)
         for update of oh.status nowait;

BEGIN

   L_rowid := NULL;
   L_table := 'ORDHEAD/ORDLOC';
   L_key1 := TO_CHAR(I_order_no);
   L_key2 := NULL;

   SQL_LIB.SET_MARK('UPDATE',NULL,'ORDHEAD', 'Order_no:'||to_char(I_order_no));
   open C_LOCK_OPEN_ORDER;
   fetch C_LOCK_OPEN_ORDER into L_rowid;
   close C_LOCK_OPEN_ORDER;

   update ordhead
      set status = 'A'
    where rowid = L_rowid;

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END OPEN_ORDER;
-------------------------------------------------------------------------------
FUNCTION CONTAINER_ITEM_CHECK(O_error_message        IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                              I_container_item_rec   IN OUT   ITEM_RCV_RECORD,
                              I_container_values     IN OUT   COST_RETAIL_QTY_RECORD,
                              I_container_item       IN       ITEM_MASTER.ITEM%TYPE)
RETURN BOOLEAN IS

   L_function   VARCHAR2(60)  := 'SMR_ORDER_RCV_SQL.CONTAINER_ITEM_CHECK';

   L_im_rec     ITEM_MASTER%ROWTYPE;


BEGIN

   --- Get item master info for transaction level item which may be
   --- different than the input_item.

   if ITEM_ATTRIB_SQL.GET_ITEM_MASTER(O_error_message,
                                      L_im_rec,
                                      I_container_item) = FALSE then
      return FALSE;
   end if;

   I_container_item_rec.item := I_container_item;
   I_container_item_rec.item_level := L_im_rec.item_level;
   I_container_item_rec.tran_level := L_im_rec.tran_level;
   I_container_item_rec.diff_1 := L_im_rec.diff_1;
   I_container_item_rec.diff_2 := L_im_rec.diff_2;
   I_container_item_rec.diff_3 := L_im_rec.diff_3;
   I_container_item_rec.diff_4 := L_im_rec.diff_4;
   I_container_item_rec.item_parent := L_im_rec.item_parent;
   I_container_item_rec.item_grandparent := L_im_rec.item_grandparent;
   I_container_item_rec.dept := L_im_rec.dept;
   I_container_item_rec.class := L_im_rec.class;
   I_container_item_rec.subclass := L_im_rec.subclass;
   I_container_item_rec.pack_ind := L_im_rec.pack_ind;
   I_container_item_rec.sellable_ind := L_im_rec.sellable_ind;
   I_container_item_rec.orderable_ind := L_im_rec.orderable_ind;
   I_container_item_rec.inventory_ind := L_im_rec.inventory_ind;
   I_container_item_rec.pack_type := NVL(L_im_rec.pack_type,'N');
   I_container_item_rec.suom := L_im_rec.standard_uom;
   I_container_item_rec.simple_pack_ind := L_im_rec.simple_pack_ind;
   I_container_item_rec.catch_weight_ind := L_im_rec.catch_weight_ind;
   I_container_item_rec.deposit_item_type := L_im_rec.deposit_item_type;
   I_container_item_rec.container_item := NULL;

   --- Force supplier cost for unit_cost
   I_container_values.unit_cost_input := NULL;
   I_container_values.unit_cost_order := NULL;

   --- Add/update container item to ordloc/shipsku
   if SMR_ORDER_RCV_SQL.ON_ORDER(O_error_message,
                             I_container_item_rec,
                             I_container_values) = FALSE then
      return FALSE;
   end if;
   ---
   return TRUE;

EXCEPTION
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END CONTAINER_ITEM_CHECK;
-------------------------------------------------------------------------------
FUNCTION UPDATE_SHIPSKU_WEIGHT(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                               I_shipment        IN       SHIPSKU.SHIPMENT%TYPE,
                               I_item            IN       SHIPSKU.ITEM%TYPE,
                               I_carton          IN       SHIPSKU.CARTON%TYPE,
                               I_inv_status      IN       SHIPSKU.INV_STATUS%TYPE,
                               I_weight          IN       SHIPSKU.WEIGHT_EXPECTED%TYPE,
                               I_weight_uom      IN       SHIPSKU.WEIGHT_EXPECTED_UOM%TYPE)
RETURN BOOLEAN IS

   L_function   VARCHAR2(60)     := 'SMR_ORDER_RCV_SQL.UPDATE_SHIPSKU_WEIGHT';

   RECORD_LOCKED                 EXCEPTION;
   PRAGMA                        EXCEPTION_INIT(Record_Locked, -54);
   L_table                       VARCHAR2(30)                       := 'SHIPSKU';
   L_key1                        VARCHAR2(100)                      := to_char(I_shipment);
   L_key2                        VARCHAR2(100)                      := I_item;

   L_rowid                       ROWID                              := NULL;
   L_prev_weight_expected        SHIPSKU.WEIGHT_EXPECTED%TYPE       := NULL;
   L_prev_weight_expected_uom    SHIPSKU.WEIGHT_EXPECTED_UOM%TYPE   := NULL;
   L_prev_weight_received        SHIPSKU.WEIGHT_RECEIVED%TYPE       := NULL;
   L_prev_weight_received_uom    SHIPSKU.WEIGHT_RECEIVED_UOM%TYPE   := NULL;

   L_total_weight_received       SHIPSKU.WEIGHT_RECEIVED%TYPE       := NULL;
   L_total_weight_received_uom   SHIPSKU.WEIGHT_RECEIVED_UOM%TYPE   := NULL;
   L_weight_converted            SHIPSKU.WEIGHT_RECEIVED%TYPE       := NULL;

   cursor C_LOCK_SHIPSKU is
      select rowid,
             weight_received,
             weight_received_uom
        from shipsku
       where shipment           = I_shipment
         and item               = I_item
         and NVL(carton,-1)     = NVL(I_carton, -1)
         for update nowait;

BEGIN

   open C_LOCK_SHIPSKU;
   fetch C_LOCK_SHIPSKU into L_rowid,
                             L_prev_weight_received,
                             L_prev_weight_received_uom;
   close C_LOCK_SHIPSKU;

   if L_rowid is NULL then
      -- shouldn't be here
      O_error_message := SQL_LIB.CREATE_MSG('INV_SHIP', NULL, NULL, NULL);
      return FALSE;
   else
      -- for adding up the receipt weight
      if L_prev_weight_received is NOT NULL and
         L_prev_weight_received_uom is NOT NULL then
         if I_weight_uom = L_prev_weight_received_uom then
            L_weight_converted := I_weight;
         else
            if UOM_SQL.CONVERT(O_error_message,
                               L_weight_converted,
                               L_prev_weight_received_uom,
                               I_weight,
                               I_weight_uom,
                               I_item,
                               NULL,
                               NULL) = FALSE then
               return FALSE;
            end if;
         end if;

         L_total_weight_received := L_weight_converted + L_prev_weight_received;
         L_total_weight_received_uom := L_prev_weight_received_uom;
      else    -- first time receiving
         L_total_weight_received := I_weight;
         L_total_weight_received_uom := I_weight_uom;
      end if;

      update shipsku
         set weight_received = L_total_weight_received,
             weight_received_uom = L_total_weight_received_uom
       where rowid = L_rowid;
   end if;

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
      O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                             L_table,
                                             L_key1,
                                             L_key2);
      return FALSE;
   when OTHERS then
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END UPDATE_SHIPSKU_WEIGHT;
-------------------------------------------------------------------------------
FUNCTION DSD_ORDER_RCV(O_error_message   IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                       I_order_no        IN       ORDAUTO_TEMP.ORDER_NO%TYPE)
   RETURN BOOLEAN IS

   L_program               VARCHAR2(50)      := 'SMR_ORDER_RCV_SQL.DSD_ORDER_RCV';
   L_invalid_param         VARCHAR2(30)      := NULL;
   L_date                  PERIOD.VDATE%TYPE := GET_VDATE;
   L_item                  ORDAUTO_TEMP.ITEM%TYPE;

   cursor C_GET_ORDAUTO_TEMP is
      select ot.item,
             ot.ref_item,
             ot.supplier,
             ot.dept,
             ot.store,
             ot.qty,
             ot.standard_uom,
             ot.unit_cost,
             ot.currency_code,
             ot.unit_retail,
             ot.origin_country_id,
             ot.cost_source,
             ot.weight_received,
             ot.weight_received_uom,
             itm.pack_ind,
             itm.pack_type,
             itm.order_as_type,
             itm.simple_pack_ind,
             itm.catch_weight_ind
        from ordauto_temp ot,
             item_master itm
       where order_no = I_order_no
         and ot.item = itm.item
         and NVL(itm.deposit_item_type,'X') != 'A';

   cursor C_PACK_ITEMS IS
      select item,
             qty
        from v_packsku_qty
       where pack_no = L_item;

   TYPE ordauto_temp_tbl is table of C_GET_ORDAUTO_TEMP%ROWTYPE index by binary_integer;
   TYPE pack_item_tbl is table of C_PACK_ITEMS%ROWTYPE index by binary_integer;

   L_ordauto_temp_tbl      ordauto_temp_tbl;
   L_pack_item_tbl         pack_item_tbl;

BEGIN

  LP_online_dsd_ind := 'Y';

   if I_order_no is NULL then
      L_invalid_param := 'I_order_no';
   end if;
   ---

   if L_invalid_param is NOT NULL then
      O_error_message := SQL_LIB.CREATE_MSG('REQUIRED_INPUT_IS_NULL',
                                            L_invalid_param,
                                            L_program,
                                            NULL);
      return FALSE;
   end if;

   open C_GET_ORDAUTO_TEMP;
   fetch C_GET_ORDAUTO_TEMP BULK COLLECT into L_ordauto_temp_tbl;
   close C_GET_ORDAUTO_TEMP;

   if L_ordauto_temp_tbl.first is NULL then
      O_error_message := SQL_LIB.CREATE_MSG('NO_REC_TO_PROCESS');
      return FALSE;
   end if;

   for i in L_ordauto_temp_tbl.first..L_ordauto_temp_tbl.last loop

      if L_ordauto_temp_tbl(i).pack_ind = 'Y' and
         L_ordauto_temp_tbl(i).pack_type = 'B' and
         L_ordauto_temp_tbl(i).order_as_type = 'E' then

         L_item := L_ordauto_temp_tbl(i).item;

         open C_PACK_ITEMS;
         fetch C_PACK_ITEMS BULK COLLECT into L_pack_item_tbl;
         close C_PACK_ITEMS;

         if L_pack_item_tbl.first is NULL then
            O_error_message := SQL_LIB.CREATE_MSG('NO_REC_TO_PROCESS',
                                                  NULL,
                                                  L_program,
                                                  NULL);
            return FALSE;
         end if;

         for j in L_pack_item_tbl.first..L_pack_item_tbl.last loop
            if SMR_ORDER_RCV_SQL.PO_LINE_ITEM_ONLINE(O_error_message,
                                                 L_ordauto_temp_tbl(i).store,
                                                 I_order_no,
                                                 L_pack_item_tbl(j).item,
                                                 L_pack_item_tbl(j).qty * L_ordauto_temp_tbl(i).qty,
                                                 'R',
                                                 L_date,
                                                 NULL,                            -- receipt number
                                                 NULL,                            -- asn number
                                                 NULL,                            -- appt number
                                                 NULL,                            -- carton
                                                 'P',                             -- distro type
                                                 NULL,                            -- distro number
                                                 L_ordauto_temp_tbl(i).store,     -- destination
                                                 'ATS',                           -- disposition
                                                 L_ordauto_temp_tbl(i).unit_cost,
                                                 'Y') = FALSE then
               LP_online_dsd_ind := 'N';
               return FALSE;
            end if;
         end loop;
      elsif L_ordauto_temp_tbl(i).simple_pack_ind = 'Y' and
        L_ordauto_temp_tbl(i).catch_weight_ind = 'Y' then
         if SMR_ORDER_RCV_SQL.PO_LINE_ITEM_ONLINE(O_error_message,
                                              L_ordauto_temp_tbl(i).store,
                                              I_order_no,
                                              L_ordauto_temp_tbl(i).item,
                                              L_ordauto_temp_tbl(i).qty,
                                              'R',
                                              L_date,
                                              NULL,                        -- receipt number
                                              NULL,                        -- asn number
                                              NULL,                        -- appt number
                                              NULL,                        -- carton
                                              'P',                         -- distro type
                                              NULL,                        -- distro number
                                              L_ordauto_temp_tbl(i).store, -- destination
                                              'ATS',                       -- disposition
                                              L_ordauto_temp_tbl(i).unit_cost,
                                              'Y',                         -- online indicator
                                              NULL,                        -- shipment
                                              L_ordauto_temp_tbl(i).weight_received,
                                              L_ordauto_temp_tbl(i).weight_received_uom) = FALSE then
            LP_online_dsd_ind := 'N';
            return FALSE;
         end if;
      else
         if SMR_ORDER_RCV_SQL.PO_LINE_ITEM_ONLINE(O_error_message,
                                              L_ordauto_temp_tbl(i).store,
                                              I_order_no,
                                              L_ordauto_temp_tbl(i).item,
                                              L_ordauto_temp_tbl(i).qty,
                                              'R',
                                              L_date,
                                              NULL,                        -- receipt number
                                              NULL,                        -- asn number
                                              NULL,                        -- appt number
                                              NULL,                        -- carton
                                              'P',                         -- distro type
                                              null,                        -- distro number
                                              L_ordauto_temp_tbl(i).store, -- destination
                                              'ATS',                       -- disposition
                                              L_ordauto_temp_tbl(i).unit_cost,
                                              'Y') = FALSE then
            LP_online_dsd_ind := 'N';
            return FALSE;
         end if;
      end if;
   end loop;
   LP_online_dsd_ind := 'N';
   return TRUE;

EXCEPTION
   WHEN OTHERS THEN
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_program,
                                            TO_CHAR(SQLCODE));
      RETURN FALSE;
END DSD_ORDER_RCV;
-------------------------------------------------------------------------------
FUNCTION PO_LINE_ITEM_ONLINE(O_error_message    IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                             I_loc              IN       ITEM_LOC.LOC%TYPE,
                             I_order_no         IN       ORDHEAD.ORDER_NO%TYPE,
                             I_item             IN       ITEM_MASTER.ITEM%TYPE,
                             I_qty              IN       TRAN_DATA.UNITS%TYPE,
                             I_tran_type        IN       VARCHAR2,
                             I_tran_date        IN       DATE,
                             I_receipt_number   IN       SHIPMENT.EXT_REF_NO_IN%TYPE,
                             I_asn              IN       SHIPMENT.ASN%TYPE,
                             I_appt             IN       APPT_HEAD.APPT%TYPE,
                             I_carton           IN       SHIPSKU.CARTON%TYPE,
                             I_distro_type      IN       VARCHAR2,
                             I_distro_number    IN       ALLOC_HEADER.ALLOC_NO%TYPE,
                             I_destination      IN       ALLOC_DETAIL.TO_LOC%TYPE,
                             I_disp             IN       INV_STATUS_CODES.INV_STATUS_CODE%TYPE,
                             I_unit_cost        IN       ORDLOC.UNIT_COST%TYPE,
                             I_online_ind       IN       VARCHAR2,
                             --
                             I_shipment         IN       SHIPMENT.SHIPMENT%TYPE,
                             --
                             I_weight           IN       ITEM_LOC_SOH.AVERAGE_WEIGHT%TYPE,
                             I_weight_uom       IN       UOM_CLASS.UOM%TYPE)
RETURN BOOLEAN IS

   L_function          VARCHAR2(60) := 'SMR_ORDER_RCV_SQL.PO_LINE_ITEM_ONLINE';
   L_rib_otb_tbl       "RIB_OTB_TBL"     := NULL;
   L_rib_otbdesc_rec   "RIB_OTBDesc_REC" := NULL;
   L_message_type      VARCHAR2(20)    := NULL;
   L_status_code       VARCHAR2(1)     := NULL;

BEGIN

   LP_shipment_to_process := I_shipment;

   --- clear out any leftover OTB info/cache DML
   if SMR_ORDER_RCV_SQL.INIT_PO_ASN_LOC_GROUP(O_error_message) = FALSE then
      return FALSE;
   end if;
   ---
   if PO_LINE_ITEM(O_error_message,
                   I_loc,
                   I_order_no,
                   I_item,
                   I_qty,
                   I_tran_type,
                   I_tran_date,
                   TO_CHAR(I_receipt_number),
                   I_asn,
                   I_appt,
                   I_carton,
                   I_distro_type,
                   I_distro_number,
                   I_destination,
                   I_disp,
                   I_unit_cost,
                   NULL,             --- I_shipped_qty
                   I_weight,         --- I_weight
                   I_weight_uom,     --- I_weight_uom
                   I_online_ind) = FALSE then
       return FALSE;
    end if;
   ---
   if SMR_ORDER_RCV_SQL.FINISH_PO_ASN_LOC_GROUP(O_error_message,
                                            L_rib_otb_tbl) = FALSE then
      return FALSE;
   end if;
   ---
   L_rib_otbdesc_rec := "RIB_OTBDesc_REC"(0, L_rib_otb_tbl);
   ---
   RMSSUB_OTBMOD.CONSUME(L_status_code,
                         O_error_message,
                         L_rib_otbdesc_rec,
                         L_message_type);
   if L_status_code != API_CODES.SUCCESS then
      return FALSE;
   end if;
   ---
   LP_shipment_to_process := NULL;

   return TRUE;

EXCEPTION
   when OTHERS then
      LP_shipment_to_process := NULL;
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END PO_LINE_ITEM_ONLINE;
-------------------------------------------------------------------------------
FUNCTION PO_IMPORT_ITEM_ONLINE(O_error_message       IN OUT   RTK_ERRORS.RTK_TEXT%TYPE,
                               I_loc                 IN       ITEM_LOC.LOC%TYPE,
                               I_order_no            IN       ORDHEAD.ORDER_NO%TYPE,
                               I_tran_type           IN       VARCHAR2,
                               I_tran_date           IN       DATE,
                               I_receipt_number      IN       SHIPMENT.EXT_REF_NO_IN%TYPE,
                               I_asn                 IN       SHIPMENT.ASN%TYPE,
                               I_appt                IN       APPT_HEAD.APPT%TYPE,
                               I_distro_type         IN       VARCHAR2,
                               I_distro_number       IN       ALLOC_HEADER.ALLOC_NO%TYPE,
                               I_destination         IN       ALLOC_DETAIL.TO_LOC%TYPE,
                               I_disp                IN       INV_STATUS_CODES.INV_STATUS_CODE%TYPE,
                               I_unit_cost           IN       ORDLOC.UNIT_COST%TYPE,
                               I_online_ind          IN       VARCHAR2,
                               I_shipment            IN       SHIPMENT.SHIPMENT%TYPE,
                               I_item_receiving_tbl  IN       RECEIVE_SQL.ITEM_RECV_TABLE)
RETURN BOOLEAN IS

   L_function          VARCHAR2(60)      := 'SMR_ORDER_RCV_SQL.PO_IMPORT_ITEM_ONLINE';
   L_rib_otb_tbl       "RIB_OTB_TBL"     := NULL;
   L_rib_otbdesc_rec   "RIB_OTBDesc_REC" := NULL;
   L_message_type      VARCHAR2(20)      := NULL;
   L_status_code       VARCHAR2(1)       := NULL;


BEGIN

   LP_shipment_to_process := I_shipment;

   --- clear out any leftover OTB info/cache DML
   if SMR_ORDER_RCV_SQL.INIT_PO_ASN_LOC_GROUP(O_error_message) = FALSE then
      return FALSE;
   end if;
   ---
   FOR i in I_item_receiving_tbl.FIRST..I_item_receiving_tbl.LAST LOOP
      if LP_prev_shipment = I_shipment then
         LP_create_tsf := 'N';
      else
         LP_create_tsf := 'Y';
         LP_prev_shipment := I_shipment;
      end if;
      ---
      if PO_LINE_ITEM(O_error_message,
                      I_loc,
                      I_order_no,
                      I_item_receiving_tbl(i).item,
                      I_item_receiving_tbl(i).qty_received,
                      I_tran_type,
                      I_tran_date,
                      TO_CHAR(I_receipt_number),
                      I_asn,
                      I_appt,
                      I_item_receiving_tbl(i).carton,
                      I_distro_type,
                      I_distro_number,
                      I_destination,
                      I_disp,
                      I_unit_cost,
                      NULL,             --- I_shipped_qty
                      I_item_receiving_tbl(i).weight_received,         --- I_weight
                      I_item_receiving_tbl(i).weight_received_uom,     --- I_weight_uom
                      I_online_ind) = FALSE then
         return FALSE;
      end if;
   end LOOP;
   ---
   if SMR_ORDER_RCV_SQL.FINISH_PO_ASN_LOC_GROUP(O_error_message,
                                            L_rib_otb_tbl) = FALSE then
      return FALSE;
   end if;
   ---
   L_rib_otbdesc_rec := "RIB_OTBDesc_REC"(0, L_rib_otb_tbl);
   ---
   RMSSUB_OTBMOD.CONSUME(L_status_code,
                         O_error_message,
                         L_rib_otbdesc_rec,
                         L_message_type);
   if L_status_code != API_CODES.SUCCESS then
      return FALSE;
   end if;
   ---
   LP_shipment_to_process := NULL;

   return TRUE;

EXCEPTION
   when OTHERS then
      LP_shipment_to_process := NULL;
      O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                            SQLERRM,
                                            L_function,
                                            TO_CHAR(SQLCODE));
      return FALSE;
END PO_IMPORT_ITEM_ONLINE;
-------------------------------------------------------------------------------

--OLR V1.02 Insert START patch 12564615
FUNCTION INSERT_UPDATE_SHIPSKU_LOC(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE,
                                   I_item_rec      IN OUT ITEM_RCV_RECORD,
                                   I_values        IN OUT COST_RETAIL_QTY_RECORD)
RETURN BOOLEAN IS

   L_function    VARCHAR2(61)  := 'SMR_ORDER_RCV_SQL.INSERT_UPDATE_SHIPSKU_LOC';
   RECORD_LOCKED EXCEPTION;
   PRAGMA        EXCEPTION_INIT(Record_Locked, -54);
   L_table       VARCHAR2(30)  := 'SHIPSKU_LOC';
   L_key1        VARCHAR2(100) := to_char(I_item_rec.ship_no);
   L_key2        VARCHAR2(100) := I_item_rec.item;

   L_rowid       ROWID         := NULL;
   L_exists      BOOLEAN       := FALSE;

   cursor C_LOCK_SHIPSKU_LOC is
   select rowid
     from shipsku_loc
    where shipment = I_item_rec.ship_no
      and item = I_item_rec.item
      and seq_no = I_item_rec.ship_seq_no
      and to_loc = I_item_rec.loc
      for update nowait;

BEGIN

   --- Get unit retail and lock shipsku table for possible update
   SQL_LIB.SET_MARK('OPEN','C_LOCK_SHIPSKU_LOC','SHIPSKU_LOC','Shipment:'||to_char(I_item_rec.ship_no)||
                    ' Item:'||I_item_rec.item);
   open C_LOCK_SHIPSKU_LOC;
   fetch C_LOCK_SHIPSKU_LOC into L_rowid;
   close C_LOCK_SHIPSKU_LOC;

   --- Update shipsku_loc table
   if L_rowid is NOT NULL then

      SQL_LIB.SET_MARK('UPDATE',NULL,'SHIPSKU_LOC','rowid:'||L_rowid);
      update shipsku_loc
         set qty_received = NVL(qty_received, 0) + I_values.input_qty
       where rowid = L_rowid;

   else -- L_rowid is NULL, shipsku_loc record does not exist

      --- Insert into shipsku_loc table
      insert into shipsku_loc(shipment,
                              seq_no,
                              item,
                              to_loc,
                              qty_received)
                       values(I_item_rec.ship_no, -- shipment
                              I_item_rec.ship_seq_no, -- seq_no
                              I_item_rec.item, -- item
                              I_item_rec.loc, -- location
                              I_values.input_qty); -- qty_received
   end if;

   return TRUE;

EXCEPTION
   when RECORD_LOCKED then
         O_error_message := SQL_LIB.CREATE_MSG('TABLE_LOCKED',
                                               L_table,
                                               L_key1,
                                               L_key2);
         return FALSE;
   when OTHERS then
         O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                               SQLERRM,
                                               L_function,
                                               TO_CHAR(SQLCODE));
         return FALSE;
END INSERT_UPDATE_SHIPSKU_LOC;
-------------------------------------------------------------------------------
FUNCTION ADD_ORD_SHIPMENT_TO_QUEUE(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE,
                                   I_order_no IN ORDHEAD.ORDER_NO%TYPE,
                                   I_shipment IN SHIPSKU.SHIPMENT%TYPE)
RETURN BOOLEAN IS

   L_program VARCHAR2(64) := 'SMR_ORDER_RCV_SQL.ADD_ORD_SHIPMENT_TO_QUEUE';
   L_count   NUMBER       := 0;

BEGIN

   for i in 1..LP_ord_shipment_tbl.count LOOP
      if LP_ord_shipment_tbl(i).order_no = I_order_no and
         LP_ord_shipment_tbl(i).shipment_no = I_shipment then
         return TRUE;
      end if;
   end LOOP;

   --- Add a new row into the array
   L_count := LP_ord_shipment_tbl.count + 1;

   LP_ord_shipment_tbl(L_count).order_no := I_order_no;
   LP_ord_shipment_tbl(L_count).shipment_no := I_shipment;
   ---
   return TRUE;
EXCEPTION
   when OTHERS then
         O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                               SQLERRM,
                                               L_program,
                                               to_char(SQLCODE));
         return FALSE;
END ADD_ORD_SHIPMENT_TO_QUEUE;
-------------------------------------------------------------------------------
FUNCTION PROCESS_REALLOC_ALC_FOR_QUEUE(O_error_message IN OUT RTK_ERRORS.RTK_TEXT%TYPE)
RETURN BOOLEAN IS

    L_program VARCHAR2(64) := 'SMR_ORDER_RCV_SQL.PROCESS_REALLOC_ALC_FOR_QUEUE';

BEGIN
   if LP_so_import_ind = 'Y' and LP_so_rtm_simplified_ind = 'N' then
      for i in 1..LP_ord_shipment_tbl.count LOOP
         if ALC_ALLOC_SQL.REALLOC_ALC(O_error_message,
                                      LP_ord_shipment_tbl(i).order_no,
                                      LP_ord_shipment_tbl(i).shipment_no) = FALSE then
            return FALSE;
         end if;
      end LOOP;
   end if;
   ---
   LP_ord_shipment_tbl.delete;
   ---
   return TRUE;

EXCEPTION
   when OTHERS then
         O_error_message := SQL_LIB.CREATE_MSG('PACKAGE_ERROR',
                                               SQLERRM,
                                               L_program,
                                               to_char(SQLCODE));
         return FALSE;
END PROCESS_REALLOC_ALC_FOR_QUEUE;
-------------------------------------------------------------------------------
--OLR V1.02 Insert END patch 12564615
-------------------------------------------------------------------------------
END SMR_ORDER_RCV_SQL;
/