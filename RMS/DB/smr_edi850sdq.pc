/*---------------------------------------------------------------------------------------------------------------------------------------------------
* Module Name:  smr_edi850dl
* Change History
* Version Date      Developer       Issue     Description
* ======= ========= =============== ========= ========================================================================================================
*    1.00 27-Mar-15 S. Fehr                   re-write for SDQ (Store Delivery Quantity)
*--------------------------------------------------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------------*\
* includes                                               *
\*------------------------------------------------------*/

#include <errno.h>
#include <retek_2.h>
#include <intrface.h>
#include <std_rest.h>
#include <string.h>

EXEC SQL INCLUDE SQLCA.H;

/*------------------------------------------------------*\
  define char lengths then add 1 for the null terminator
\*------------------------------------------------------*/
#define DEBUG 1
/*#undef DEBUG*/

#define NUM_INIT_PARAMETERS    4
#define LEN_OUTFILE_NAME    1024

/*------------------------------------------------------*\
  defines for SMR output format - H1 
\*------------------------------------------------------*/
#define LEN_SMR_REC_TYPE1             6
#define LEN_SMR_REC_TYPE2             2
#define LEN_SMR_REC_SEQ               4
#define LEN_SMR_TRADING_PTNR         15
#define LEN_SMR_COMPANY_ID            3
#define LEN_SMR_PO_TYPE               2
#define LEN_SMR_PO_NMBR               9
#define LEN_SMR_PO_PURPOSE_CODE       2
#define LEN_SMR_DC_STORE_NMBR         5
#define LEN_SMR_VENDOR_NMBR_REF       2
#define LEN_SMR_VENDOR_NMBR           9
#define LEN_SMR_SUPPLIER_NMBR         9
#define LEN_SMR_DEPT_NMBR_REF         2
#define LEN_SMR_DEPT_NMBR             3
#define LEN_SMR_BUYER_NMBR_REF        2
#define LEN_SMR_BUYER_FNCTN_CODE      2
#define LEN_SMR_BUYER_NMBR            3
#define LEN_SMR_BUYER_CONTACT_NAME   60
#define LEN_SMR_BUYER_COMM_QUALFR     2
#define LEN_SMR_BUYER_PHONE_NMBR     80
#define LEN_SMR_DC_FUNCTION_CODE      2
#define LEN_SMR_DC_CONTACT_NAME      60
#define LEN_SMR_DC_COMM_QUALIFER      2
#define LEN_SMR_DC_PHONE_NMBR        80
#define LEN_SMR_CASH_REQ_CODE         2
#define LEN_SMR_DELIVERY_INSTRUCT    35
#define LEN_SMR_SPECIAL_FREIGHT_DESC 20
#define LEN_SMR_DISCOUNT_DESC        30
#define LEN_SMR_850_TOTAL_QTY_PO      9
#define LEN_SMR_PO_DATE               8
#define LEN_SMR_PO_CHANGE_DATE        8

#define LEN_SMR_PO_REQUESTED_SHIP     3
#define LEN_SMR_PO_SHIP_DATE          8
#define LEN_SMR_PO_RCV_DATE           8
#define LEN_SMR_PO_CANCEL_AFTER       3
#define LEN_SMR_PO_CANCEL_DATE        8
#define LEN_SMR_PO_PROMO              3
#define LEN_SMR_PO_PROMO_DATE         8
#define LEN_SMR_TERMS_ID_QUALIFER     2
#define LEN_SMR_TERMS_OF_PURCHASE   170

#define LEN_SMR_CHARGE_IND            1
#define LEN_SMR_VICS                  2
#define LEN_SMR_NEW_STORE_RUSH       10
#define LEN_SMR_SAC_DESC             40

#define LEN_SMR_DESC_TYPE             1
#define LEN_SMR_COMMENTS            300
#define LEN_SMR_SPLIT_COMMENTS       50

#define LEN_SMR_SHIP_TO_MARK_FOR      2
#define LEN_SMR_ADDRESS              55
#define LEN_SMR_CITY                 30
#define LEN_SMR_ZIP                  10
#define LEN_SMR_COUNTRY               3
#define LEN_SMR_STATE                 2
#define LEN_SMR_ZIP                  10
#define LEN_SMR_WH_DESC              25

#define LEN_SMR_WH_NAME              25
#define LEN_SDQ_SA_FILL              92

#define LEN_BULK_ORDER_PO             6
#define LEN_SMR_PO_CHANGE_CODE        2


/*------------------------------------------------------*\
 defines for SMR output format - D1 
\*------------------------------------------------------*/

#define NULL_SMR_REC_TYPE1           (LEN_SMR_REC_TYPE1 + 1)
#define NULL_SMR_TRADING_PTNR        (LEN_SMR_TRADING_PTNR + 1)
#define NULL_SMR_COMPANY_ID          (LEN_SMR_COMPANY_ID + 1)
#define NULL_SMR_PO_TYPE             (LEN_SMR_PO_TYPE + 1)
#define NULL_SMR_PO_NMBR             (LEN_SMR_PO_NMBR + 1)
#define NULL_SMR_PO_PURPOSE_CODE     (LEN_SMR_PO_PURPOSE_CODE + 1)
#define NULL_SMR_DC_STORE_NMBR       (LEN_SMR_DC_STORE_NMBR + 1)
#define NULL_SMR_SHIP_TO_MARK_FOR    (LEN_SMR_SHIP_TO_MARK_FOR + 1)
#define NULL_SMR_VENDOR_NMBE_REF     (LEN_SMR_VENDOR_NMBE_REF + 1)
#define NULL_SMR_VENDOR_NMBR         (LEN_SMR_VENDOR_NMBR + 1)
#define NULL_SMR_DEPT_NMBR_REF       (LEN_SMR_DEPT_NMBR_REF + 1)
#define NULL_SMR_DEPT_NMBR           (LEN_SMR_DEPT_NMBR + 1)
#define NULL_SMR_BUYER_NMBR_REF      (LEN_SMR_BUYER_NMBR_REF + 1)
#define NULL_SMR_BUYER_FNCTN_CODE    (LEN_SMR_BUYER_FNCTN_CODE + 1)
#define NULL_SMR_BUYER_NMBR          (LEN_SMR_BUYER_NMBR + 1)
#define NULL_SMR_BUYER_CONTACT_NAME  (LEN_SMR_BUYER_CONTACT_NAME + 1)
#define NULL_SMR_BUYER_COMM_QUALFR   (LEN_SMR_BUYER_COMM_QUALFR + 1)
#define NULL_SMR_BUYER_PHONE_NMBR    (LEN_SMR_BUYER_PHONE_NMBR + 1)
#define NULL_SMR_DC_FUNCTION_CODE    (LEN_SMR_DC_FUNCTION_CODE + 1)
#define NULL_SMR_DC_CONTACT_NAME     (LEN_SMR_DC_CONTACT_NAME + 1)
#define NULL_SMR_DC_COMM_QUALIFER    (LEN_SMR_DC_COMM_QUALIFER + 1)
#define NULL_SMR_DC_PHONE_NMBR       (LEN_SMR_DC_PHONE_NMBR + 1)
#define NULL_SMR_CASH_REQ_CODE       (LEN_SMR_CASH_REQ_CODE + 1)
#define NULL_SMR_DELIVERY_INSTRUCT   (LEN_SMR_DELIVERY_INSTRUCT + 1)
#define NULL_SMR_SPECIAL_FREIGHT_DESC (LEN_SMR_SPECIAL_FREIGHT_DESC + 1)
#define NULL_SMR_DISCOUNT_DESC       (LEN_SMR_DISCOUNT_DESC + 1)
#define NULL_SMR_TOTAL_QTY_PO        (LEN_SMR_850_TOTAL_QTY_PO + 1)
#define NULL_SMR_PO_DATE             (LEN_SMR_PO_DATE + 1)
#define NULL_SMR_PO_REQUESTED_SHIP   (LEN_SMR_PO_REQUESTED_SHIP + 1)
#define NULL_SMR_PO_SHIP_DATE        (LEN_SMR_PO_SHIP_DATE + 1)
#define NULL_SMR_PO_RCV_DATE         (LEN_SMR_PO_RCV_DATE + 1)
#define NULL_SMR_PO_CANCEL_AFTER     (LEN_SMR_PO_CANCEL_AFTER + 1)
#define NULL_SMR_PO_CANCEL_DATE      (LEN_SMR_PO_CANCEL_DATE + 1)
#define NULL_SMR_PO_PROMO            (LEN_SMR_PO_PROMO + 1)
#define NULL_SMR_PO_PROMO_DATE       (LEN_SMR_PO_PROMO_DATE + 1)
#define NULL_SMR_PO_CHANGE_CODE      (LEN_SMR_PO_CHANGE_CODE + 1)
#define NULL_SMR_TERMS_ID_QUALIFER   (LEN_SMR_TERMS_ID_QUALIFER + 1)
#define NULL_SMR_TERMS_OF_PURCHASE   (LEN_SMR_TERMS_OF_PURCHASE + 1)

#define NULL_SMR_VICS                (LEN_SMR_VICS + 1)
#define NULL_SMR_NEW_STORE_RUSH      (LEN_SMR_NEW_STORE_RUSH + 1)
#define NULL_SMR_SAC_DESC            (LEN_SMR_SAC_DESC + 1)
#define NULL_SMR_COMMENTS            (LEN_SMR_COMMENTS + 1)
#define NULL_SMR_SPLIT_COMMENTS      (LEN_SMR_SPLIT_COMMENTS + 1)

/*---------------------------------------------------------------------------*\
  the following defines are to improve readability of the code 
\*---------------------------------------------------------------------------*/
#define SMR_TERMS1 "THIS OFFER TO PURCHASE IS MADE SUBJECT TO STEIN MART'S STANDARD TERMS AND CONDITIONS OF PURCHASE WHICH AR AVAILABLE ON OUR WEB SITE AT HTTP://VENDORS.STEINMART.COM/"
#define SMR_TERMS2 "AND ARE ALSO AVAILABLE VIA FACSIMILE OR MAIL UPON REQUEST BY ANY VENDOR (\"SELLER\") AND WHICH ARE INCORPORATED HEREIN."

#define SMR_BULK_PO_TYPE              "BK"
#define SMR_ALLOC_PO_TYPE             "RL"
#define SMR_STANDALONE_PO_TYPE        "SA"

#define SMR_PO_PURPOSE_CD_CANCEL      "01"
#define SMR_PO_PURPOSE_CD_CHANGE      "04"
#define SMR_PO_PURPOSE_CD_00          "00"

#define LEN_BUYER_NAME                 120
#define LEN_BUYER_PHONE                20
#define LEN_TERMS_CODE                 50

#define LEN_NEW_STORE_RUSH             10

#define LEN_SMR_ITEM_SKU_NMBR          11
#define LEN_SMR_ITEM_STORE_NMBR         9
#define LEN_SMR_DETAIL_REC_SUB_SEL      5
#define LEN_SMR_VPN                    15
#define LEN_SDQ_TEXT                    3
#define LEN_SMR_ITEM_QTY                7
#define LEN_SMR_PACK_QTY                8
#define LEN_SMR_PACK_SUBLINE_QTY        9
#define LEN_QTY_LEFT_TO_RECEIVE         7
#define LEN_SMR_UNIT_COST              10
#define LEN_SMR_UPC                    15
#define LEN_SMR_RETAIL_PRICE_ID         3
#define LEN_SMR_RETAIL_PRICE           10
#define LEN_SMR_BUYER_COLOR_QUALIFIER   2
#define LEN_SMR_BUYER_COLOR_DESC       15
#define LEN_SMR_BUYER_SIZE_QUALIFIER    2
#define LEN_SMR_BUYER_SIZE_DESC        15
#define LEN_SMR_COMPARE_TO_PRICE_ID     3
#define LEN_SMR_COMPARE_TO_PRICE       10

#define LEN_SMR_BUYER_COLOR_DESC       15
#define LEN_SMR_BUYER_SIZE_DESC        15

#define LEN_SMR_CODE                   10
#define LEN_SMR_CODE_DESC              10
#define LEN_INTERFACE_ID               10

#define LEN_SMR_PROMO_QUALIFIER        3
#define LEN_CREATE_DATETIME            14
#define LEN_GROUP_ID                   40


#define NULL_SMR_ITEM_SKU_NMBR    (LEN_SMR_ITEM_SKU_NMBR + 1)
#define NULL_SMR_VPN              (LEN_SMR_VPN + 1)
#define NULL_SMR_UPC              (LEN_SMR_UPC + 1)
#define NULL_WH                   (LEN_WH + 1)

#define NULL_BUYER_NAME           (LEN_BUYER_NAME + 1)
#define NULL_BUYER_PHONE          (LEN_BUYER_PHONE + 1)
#define NULL_TERMS_CODE           (LEN_TERMS_CODE + 1)

#define NULL_NEW_STORE_RUSH       (LEN_NEW_STORE_RUSH + 1)

#define NULL_SMR_BUYER_COLOR_DESC (LEN_SMR_BUYER_COLOR_DESC+1)
#define NULL_SMR_BUYER_SIZE_DESC  (LEN_SMR_BUYER_SIZE_DESC+1)

#define NULL_SMR_CODE             (LEN_SMR_CODE + 1)
#define NULL_SMR_CODE_DESC        (LEN_SMR_CODE_DESC + 1)

#define NULL_SMR_PROMO_QUALIFIER  (LEN_SMR_PROMO_QUALIFIER + 1)

#define NULL_SMR_WH_NAME          (LEN_SMR_WH_NAME + 1)
#define NULL_INTERFACE_ID         (LEN_INTERFACE_ID + 1)

#define LEN_FILE_NAME                    200
#define LEN_SMR_UOM_IDENTIFIER             2
#define NULL_SMR_UOM_IDENTIFIER         (LEN_SMR_UOM_IDENTIFIER + 1)

#define LEN_FLAG_TYPE                      1
#define LEN_PACK_TYPE                      1

#define NULL_FLAG_TYPE                  (LEN_FLAG_TYPE + 1)
#define NULL_PACK_TYPE                  (LEN_PACK_TYPE + 1)

#define NULL_CREATE_DATETIME            (LEN_CREATE_DATETIME + 1)
#define NULL_GROUP_ID                   (LEN_GROUP_ID + 1)


/*---------------------------------------------------------------------------*\
  lengths for global variables
\*---------------------------------------------------------------------------*/
#define LEN_ST_ARRAY                     250
#define LEN_QTY_DEC                        4
#define LEN_LONG_MESSAGE                 255

#define RECORD_LOCKED                     54


/*---------------------------------------------------------------------------*\
  global variables
\*---------------------------------------------------------------------------*/
long    SQLCODE = 0;
long    sql_holder = 0;

char    restart_start_array[1][255];
char    restart_application_image_array[2][255];
char    restart_application_image[255];

extern  long g_l_rec_cnt;

long    pl_line_no = 0;
long    pl_tran_no = 0;
long    pl_no_of_lines = 0;
long    pl_no_tran_lines = 0;
long    pl_terms_count = 0;

int     backdays_added_newloc = 0;

int     pi_pkg_fail;
char    ps_error_message[256];

/*---------------------------------------------------------------------------*\
  program variables
\*---------------------------------------------------------------------------*/
char    ps_restart_num_threads[NULL_THREAD];
char    ps_restart_thread_val[NULL_THREAD];
char    ps_restart_driver_name[MAX_DRIVER_NAME_LEN];
int     pi_qty_dec = LEN_QTY_DEC;      /* implied decimal places holder */
char    logmessage[LEN_LONG_MESSAGE];

/*---------------------------------------------------------------------------*\
  init variables
\*---------------------------------------------------------------------------*/
char    ps_vdate[NULL_DATE];
char    ps_multichannel_ind[NULL_IND];        /* system variable for multichannel Y or N */
char    ps_qty_type_flag[NULL_FLAG_TYPE];

/**
char    ps_create_datetime[NULL_CREATE_DATETIME];
**/
char    ps_bk_wh[NULL_LOC];
char    ps_dd_wh[NULL_LOC];
char    ps_create_datetime[NULL_DATE];
char    ps_group_id[NULL_GROUP_ID];
char    ps_interface_id[NULL_INTERFACE_ID];
/*---------------------------------------------------------------------------*\
  restart/recovery
\*---------------------------------------------------------------------------*/
init_parameter parameter[NUM_INIT_PARAMETERS] =
{
  /* Name -------------Type --------- Sub_type */
    "commit_max_ctr",       "uint",        "",
    "thread_val",   "string",      "",
    "num_threads",  "string",      "",
    "restartPoNmbr", "string",     "I"
};

uint commitMaxCtr;
char restartThreadVal[NULL_THREAD];
char restartNumThreads[NULL_THREAD];
char restartPO[NULL_ORDER_NO]="";

/*---------------------------------------------------------------------------*\
  used for optional filename from program parameters 
\*---------------------------------------------------------------------------*/
char outFileNameParameter[LEN_OUTFILE_NAME] = "";

FILE *ediFilePtr;

/*---------------------------------------------------------------------------*\
  output format strings 
\*---------------------------------------------------------------------------*/
char poHeaderComments1[NULL_SMR_SPLIT_COMMENTS];
char poHeaderComments2[NULL_SMR_SPLIT_COMMENTS];
char poHeaderComments3[NULL_SMR_SPLIT_COMMENTS];
char poHeaderComments4[NULL_SMR_SPLIT_COMMENTS];
char poHeaderComments5[NULL_SMR_SPLIT_COMMENTS];
char poHeaderComments6[NULL_SMR_SPLIT_COMMENTS];

char h1String[LEN_ST_ARRAY];
char h2String[LEN_ST_ARRAY];
char h3String[LEN_ST_ARRAY];
char h4String[LEN_ST_ARRAY];
char d1String850[LEN_ST_ARRAY];
char d2String[LEN_ST_ARRAY];
char d3String[LEN_ST_ARRAY];
char poVndpString[LEN_ST_ARRAY];
char h1String_850[LEN_ST_ARRAY];
char h4String_850[LEN_ST_ARRAY];

int po_seq = 0;
int ps_hb_release = 0;
int ps_hdr_record_id;
int ps_dtl_record_id;
int recSequence;
int d1RecSequence;

char maxRevNo[NULL_REV_NO];
char NewLoc[NULL_LOC];

char recTypeDescH1[NULL_SMR_REC_TYPE1];
char recTypeDescH2[NULL_SMR_REC_TYPE1];
char recTypeDescH3[NULL_SMR_REC_TYPE1];
char recTypeDescH4[NULL_SMR_REC_TYPE1];
char recTypeDescD1[NULL_SMR_REC_TYPE1];
char recTypeDescD2[NULL_SMR_REC_TYPE1];
char recTypeDescD3[NULL_SMR_REC_TYPE1];
char recTypeDescD4[NULL_SMR_REC_TYPE1];
char recTypeDescVP[NULL_SMR_REC_TYPE1+1];

/*---------------------------------------------------------------------------*\
  header record fields
\*---------------------------------------------------------------------------*/
char orderNo[NULL_ORDER_NO]; /* defined in [env]/oracle/lib/src/std_len.h - modified LEN_ORDER_NO from 8 to 10 (in dev only!) */
char orderStatus[NULL_IND];
char orderLocation[NULL_LOC];
char SALocation[NULL_LOC];
char whName[NULL_SMR_WH_NAME];
char h4WhName[NULL_SMR_WH_NAME];
char supplier[NULL_SUPPLIER];
char dcStoreNumber[NULL_SMR_DC_STORE_NMBR];
char h4StoreNumber[NULL_SMR_DC_STORE_NMBR];
char shipToMarkFor[NULL_SMR_SHIP_TO_MARK_FOR];
char poNumber[NULL_SMR_PO_NMBR];
char masterPONumber[NULL_SMR_PO_NMBR];
char originalApproveDate[NULL_DATE];
char newNotBeforeDate[NULL_DATE];
char newNotAfterDate[NULL_DATE];
char orderDept[NULL_DEPT];
char buyer[NULL_BUYER];
char buyerName[NULL_BUYER_NAME];
char buyerPhone[NULL_BUYER_PHONE];
char termsCode[NULL_TERMS_CODE];
char promoQualifier[NULL_SMR_PROMO_QUALIFIER];
char promoStartDate[NULL_DATE];
char orderEDIPOInd[NULL_IND];
char orderQCInd[NULL_IND];
char orderTotalQty[NULL_SMR_TOTAL_QTY_PO];
char totalD1Qty[NULL_SMR_TOTAL_QTY_PO];
char qtyVPItem[NULL_SMR_TOTAL_QTY_PO];
char lastSentRevNo[NULL_REV_NO];
char ordItemLocChangeCode[NULL_SMR_PO_CHANGE_CODE];
char poPurposeCode[NULL_SMR_PO_PURPOSE_CODE];
char poType[NULL_SMR_PO_TYPE];
char poHeaderComments[NULL_SMR_COMMENTS];
char newStoreRushOrder[NULL_NEW_STORE_RUSH];
char termsOfPurch1[NULL_SMR_TERMS_OF_PURCHASE];
char termsOfPurch2[NULL_SMR_TERMS_OF_PURCHASE];

/*---------------------------------------------------------------------------*\
  detail record fields
\*---------------------------------------------------------------------------*/
char orderItem[NULL_ITEM];
char item[NULL_ITEM];
char itemSupVPN[NULL_VPN];
char qtyOrdered[NULL_QTY];
char orderUnitRetail[NULL_AMT];
char orderUnitCost[NULL_AMT];
char upc[NULL_ITEM];
char itemColorDesc[NULL_SMR_BUYER_COLOR_DESC];
char itemSizeDesc[NULL_SMR_BUYER_SIZE_DESC];
char itemMfgRecRetail[NULL_AMT];
char itemPackType[NULL_PACK_TYPE];

char itemTicketTypeId[NULL_SMR_CODE];
char itemTicketTypeDesc[NULL_SMR_CODE_DESC];
char itemHangerCode[NULL_SMR_CODE];
char itemHangerCodeDesc[NULL_SMR_CODE_DESC];

char d3StoreNumber[NULL_SMR_DC_STORE_NMBR];
char UOM_D3[NULL_SMR_UOM_IDENTIFIER];

/*---------------------------------------------------------------------------*\
  structure for retrieving alloc info associated with PO
\*---------------------------------------------------------------------------*/
struct allocStruct
{
   char allocItem[NULL_ITEM];
   char allocWh[NULL_LOC];
   char allocStore[NULL_LOC];
   char storeName[NULL_SMR_WH_NAME];
   char oldAllocStore[NULL_LOC];
   char storeDefaultWh[NULL_LOC];
   char qtyAlloc[NULL_QTY];
   char newStore[NULL_IND];
   char supVPN[NULL_VPN];
   short supVPNInd;
   char itemUnitRetail[NULL_AMT];
   char itemUnitCost[NULL_AMT];
   char itemUPC[NULL_ITEM];
   short itemUPCInd;
   char itemPackType[NULL_IND];
   short itemPackTypeInd;
   char itemColorDesc[NULL_SMR_BUYER_COLOR_DESC];
   short itemColorDescInd;
   char itemSizeDesc[NULL_SMR_BUYER_SIZE_DESC];
   short itemSizeDescInd;
   char itemMfgRecRetail[NULL_AMT];
} allocRec;

char totalQtyAlloc[NULL_QTY];

/*---------------------------------------------------------------------------*\
  variables for query null indicators
\*---------------------------------------------------------------------------*/
short orderLocationInd;
short orderDeptInd;
short buyerInd;
short buyerNameInd;
short buyerPhoneInd;
short lastSentRevNoInd;
short poHeaderCommentsInd;
short promoStartDateInd;
short storeDefaultWhInd;
short upcInd;
short whNameInd;

short itemSupVPNInd;
short itemColorDescInd;
short itemSizeDescInd;
short itemMfgRecRetailInd;
short itemPackTypeInd;
short itemHangerCodeInd;
short itemHangerCodeDescInd;
short itemTicketTypeIdInd;
short itemTicketTypeDescInd;
short orderUnitRetailInd;

short oldQtyOrderedInd;
short oldOrderUnitRetailInd;
short oldOrderUnitCostInd;

/*---------------------------------------------------------------------------*\
  process variables
\*---------------------------------------------------------------------------*/
char    ps_rowid[NULL_ROWID];

int  pi_edi_to_send_flag = 1;
long pi_err_flag = 0;
long pl_sqlcode = 0;
int  pi_exception = 0;
char ps_err_msg[NULL_ERROR_MESSAGE] = "";

/*---------------------------------------------------------------------------*\
 function prototypes
\*---------------------------------------------------------------------------*/
int init(char* argv[]);
int process(void);
int final(void);

/*---------------------------------------------------------------------------*\
  SMR function prototypes
\*---------------------------------------------------------------------------*/
void formatH1(void);
void formatH2(void);
void formatH3(void);
void formatH4(void);
void formatD1(void);
void formatD2(void);
void formatPOVNDP(void);

int writeH1(FILE *outRtkFilePtr);
int processH2(FILE *outRtkFilePtr);
int writeH2(FILE *outRtkFilePtr, char *vicCode, char *sacCode, char *sacDesc);

int splitwritecomments(FILE *outRtkFilePtr);

int writeH3(FILE *outRtkFilePtr);
int writeH3_All_POs(FILE *outRtkFilePtr); 
int writeH3_QCInd(FILE *outRtkFilePtr); 
int writeH4(FILE *outRtkFilePtr);
int writeD1(FILE *outRtkFilePtr);
int writeD2(FILE *outRtkFilePtr);
int writeD3(FILE *outRtkFilePtr);
int writePOVNDP(FILE *outRtkFilePtr);

int getMaxRevNo(void);
int insertPOAllocRevInfo(void);

int get_substr(int ipos, int fpos,char *ptr, char *ptr1);


/*---------------------------------------------------------------------------*\
  function main() - set restart flags, call init() and process()
\*---------------------------------------------------------------------------*/
int main(int argc, char* argv[])
{
   char* function = "main";
   int   li_init_results;
   char  ls_log_message[NULL_ERROR_MESSAGE];
   int   li_final_return;

   if (argc < 2)
   {
      fprintf(stderr,"Usage: %s userid/passwd outfilename(optional)\n",argv[0]);
      return(FAILED);
   }

   if (LOGON(argc, argv) < 0)
   {
      return(FAILED);
   }

   if (argc == 3)
      strcpy(outFileNameParameter,argv[2]);

   if ((li_init_results = init(argv)) < 0)
      gi_error_flag = 2;
   if (li_init_results != NO_THREAD_AVAILABLE)
   {
      if (li_init_results == OK)
      {
         if (process() < 0)
            gi_error_flag = 1;
      }

      if (final() < 0)
      {
         if (gi_error_flag == 0)
            gi_error_flag = 3;
      }
   }

   if (gi_error_flag == 2)
   {
      LOG_MESSAGE("Aborted in init");
      li_final_return = FAILED;
   }
   else if (gi_error_flag == 1)
   {
      sprintf(ls_log_message,"Thread %s - Aborted in process",restartThreadVal);
      LOG_MESSAGE(ls_log_message);
      li_final_return = FAILED;
   }
   else if (gi_error_flag == 3)
   {
      sprintf(ls_log_message,"Thread %s - Aborted in final",restartThreadVal);
      LOG_MESSAGE(ls_log_message);
      li_final_return = FAILED;
   }
   else if (li_init_results == NO_THREAD_AVAILABLE)
   {
      LOG_MESSAGE("Terminated - No threads available");
      li_final_return = NO_THREADS;
   }
   else
   {
      sprintf(ls_log_message,"Thread %s - Terminated Successfully",restartThreadVal);
      LOG_MESSAGE(ls_log_message);
      li_final_return = SUCCEEDED;
   }

   return(li_final_return);

}  /* End of main() */


/*------------------------------------------------------*\
* function init()                                        *
\*------------------------------------------------------*/
int init(char* argv[])
{
   char *function_name = "init";
   char ls_thread[NULL_THREAD];
   int restartInitResults;

   char    fileName[LEN_OUTFILE_NAME];

   /* variables for date time stamp */
   time_t currentTime;
   struct tm *timeInfo;
   char timeString[20];

/* char* homeDir = getenv("MMOUT");
   write SDQ file to /tmp (instead of not writing it) */
   char* homeDir = "/tmp";

   EXEC SQL DECLARE c_date_sys_options CURSOR FOR
      SELECT TO_CHAR(p.vdate,'YYYYMMDDHH24MISS'),
             so.multichannel_ind,
             TO_CHAR(sysdate,'YYYYMMDDHH24MISS')
        FROM period p,
             system_options so;

   EXEC SQL DECLARE c_count_terms CURSOR FOR
      SELECT count(terms)
        FROM terms;

   EXEC SQL DECLARE c_int_type CURSOR FOR
      SELECT to_char(interface_id)
        FROM smr_rms_int_type
       WHERE interface_name = 'EDI_850_860';
   
   EXEC SQL DECLARE c_bk_dd_wh CURSOR FOR
    select to_char(sum(dd)),to_char(sum(bk)) from (
      SELECT 0 dd, wh bk
        FROM wh_attributes
       WHERE wh_type_code = 'BK'
       UNION
      SELECT wh dd,0   
        FROM wh_attributes
       WHERE wh_type_code = 'DD');

   EXEC SQL DECLARE C_BACKDAYS_ADDED_NEWLOC CURSOR FOR
      SELECT NVL(BACKDAYS_ADDED_NEWLOC,15)
        FROM SMR_SYSTEM_OPTIONS;

/*---------------------------------------------------------------------------*\
  get date and timestamp for filename
\*---------------------------------------------------------------------------*/
   time(&currentTime);
   timeInfo = localtime(&currentTime);
   strftime(timeString, sizeof(timeString), "%Y%m%d%H%M%S", timeInfo);

   #ifdef DEBUG
   printf("Current system date time string is <%s>\n",timeString);
   #endif

/*---------------------------------------------------------------------------*\
  setup file names - check if output file name passed as parameter
\*---------------------------------------------------------------------------*/
   if (strcmp(outFileNameParameter,"") == 0)
      sprintf(fileName, "%s/%s_%s.dat", homeDir, "RMS_PO", timeString);
   else
      sprintf(fileName, "%s/%s", homeDir, outFileNameParameter);

   #ifdef DEBUG
   printf("Output EDI filename is <%s>\n",fileName);
   #endif

   #ifdef DEBUG
   printf("open file\n");
   #endif
   ediFilePtr = fopen(fileName,"w");
   if (ediFilePtr == (FILE *)NULL)
   {
      strcpy(err_data, "Failed opening file");
      strcpy(table, "period, system_options");
      WRITE_ERROR(RET_FUNCTION_ERR,function_name,"",err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("initialize restart process next\n");
   #endif
   /* initialize restart recovery information */
   restartInitResults = retek_init(NUM_INIT_PARAMETERS,
                                   parameter,
                                   &commitMaxCtr,
                                   restartThreadVal,
                                   restartNumThreads,
                                   restartPO);

   #ifdef DEBUG
   printf("look at file pointer next\n");
   printf("File pointer is <%ld>\n",ftell(ediFilePtr));
   #endif

   if (restartInitResults != 0)
       return(restartInitResults);

   if (commitMaxCtr > MAX_ORACLE_ARRAY_SIZE)
   {
      commitMaxCtr = MAX_ORACLE_ARRAY_SIZE;
      if (limit_commit_max_ctr(commitMaxCtr) < 0)
         return (FATAL);
   }

/*---------------------------------------------------------------------------*\
  setup output format strings
\*---------------------------------------------------------------------------*/
   #ifdef DEBUG
   printf("Setup format strings next\n");
   #endif
   formatH1();
   formatH2();
   formatH3();
   formatH4();
   formatD1();
   formatD2();
   formatD3();
   formatPOVNDP();


/*---------------------------------------------------------------------------*\
  get vdate, system_options
\*---------------------------------------------------------------------------*/
   #ifdef DEBUG
   printf("Get vdate\n");
   #endif
   EXEC SQL OPEN c_date_sys_options;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_date_sys_options");
      strcpy(table, "period, system_options");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }
   EXEC SQL FETCH c_date_sys_options INTO :ps_vdate,
                                          :ps_multichannel_ind,
                                          :ps_create_datetime;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=c_date_sys_options");
      strcpy(table, "period, system_options");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

/*---------------------------------------------------------------------------*\
  get terms
\*---------------------------------------------------------------------------*/
   #ifdef DEBUG
   printf("Get terms next\n");
   #endif
   EXEC SQL OPEN c_count_terms;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_count_terms");
      strcpy(table, "terms");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }
   EXEC SQL FETCH c_count_terms INTO :pl_terms_count;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=c_count_terms");
      strcpy(table, "terms");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

/*---------------------------------------------------------------------------*\
  get bk_dd_wh
\*---------------------------------------------------------------------------*/
   #ifdef DEBUG
   printf("Get dd_wh next\n");
   #endif
   EXEC SQL OPEN c_bk_dd_wh;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_bk_dd_wh");
      strcpy(table, "wh_attributes");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }
   EXEC SQL FETCH c_bk_dd_wh INTO :ps_dd_wh, :ps_bk_wh;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=c_bk_dd_wh");
      strcpy(table, "wh_attributes");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

/*---------------------------------------------------------------------------*\
  get interface_id
\*---------------------------------------------------------------------------*/
   #ifdef DEBUG
   printf("Get interface_id next\n");
   #endif
   EXEC SQL OPEN c_int_type;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_int_type");
      strcpy(table, "smr_rms_int_type");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }
   EXEC SQL FETCH c_int_type INTO :ps_interface_id;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=c_int_type");
      strcpy(table, "smr_rms_int_type");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

/*---------------------------------------------------------------------------*\
  get backdays_added_newloc
\*---------------------------------------------------------------------------*/
   EXEC SQL OPEN C_BACKDAYS_ADDED_NEWLOC;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=C_BACKDAYS_ADDED_NEWLOC");
      strcpy(table, "smr_system_options");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }
   EXEC SQL FETCH C_BACKDAYS_ADDED_NEWLOC INTO :backdays_added_newloc;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=C_BACKDAYS_ADDED_NEWLOC");
      strcpy(table, "smr_system_options");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

   #ifdef DEBUG
   printf("Get backdays_added_newloc <%i>\n", backdays_added_newloc);
   #endif


   return(0);
}/* end init */


/*---------------------------------------------------------------------------*\
  format H1
\*---------------------------------------------------------------------------*/
void formatH1(void)
{
   strcpy(h1String_850,"%-*s"); /* Record type 1 */
   strcat(h1String_850,"%-*s"); /* Record type 2 */
   strcat(h1String_850,"%0*d"); /* Record sequence */
   strcat(h1String_850,"%0*d      "); /* Trading partner id */
   strcat(h1String_850,"%0*d");  /* Company id */
   strcat(h1String_850,"%-*s");  /* PO type */
   strcat(h1String_850,"%0*d");  /* PO number */
   strcat(h1String_850,"%-*s");  /* PO purpose code */
   strcat(h1String_850,"%0*d");  /* DC store number */
   strcat(h1String_850,"%-*s");  /* Master po number */
   strcat(h1String_850,"%-*s");  /* Vendor number ref */
   strcat(h1String_850,"%0*d");  /* Vendor number */
   strcat(h1String_850,"%-*s");  /* Department number ref */
   strcat(h1String_850,"%0*d");  /* Department number */
   strcat(h1String_850,"%-*s");  /* Buyer number ref */
   strcat(h1String_850,"%-*s");  /* Buyer function code */
   strcat(h1String_850,"%0*d");  /* Buyer number */
   strcat(h1String_850,"%-*s");  /* Buyer contact name */
   strcat(h1String_850,"%-*s");  /* Buyer comm qualifier */
   strcat(h1String_850,"%-*s");  /* Buyer phone number */
   strcat(h1String_850,"%-*s");  /* DC function code */
   strcat(h1String_850,"%-*s");  /* DC contact name */
   strcat(h1String_850,"%-*s");  /* DC comm qualifier */
   strcat(h1String_850,"%-*s");  /* DC phone number */
   strcat(h1String_850,"%-*s");  /* Cash req code 1 */
   strcat(h1String_850,"%-*s");  /* Cash req code 2 */
   strcat(h1String_850,"%-*s");  /* Delivery instructions */
   strcat(h1String_850,"%-*s");  /* Special freight descript */
   strcat(h1String_850,"%-*s");  /* Discount description */
   strcat(h1String_850,"%0*d");  /* Total qty PO */
   strcat(h1String_850,"%-*s");  /* PO date */
   strcat(h1String_850,"%-*s");  /* PO requested ship */
   strcat(h1String_850,"%-*s");  /* PO ship date */
   strcat(h1String_850,"%-*s");  /* PO recv date */
   strcat(h1String_850,"%-*s");  /* PO cancel after */
   strcat(h1String_850,"%-*s");  /* PO cancel date */
   strcat(h1String_850,"%-*s");  /* PO promo */
   strcat(h1String_850,"%-*s");  /* PO promo date */
   strcat(h1String_850,"%-*s");  /* Terms id qualifier */
   strcat(h1String_850,"%-*s");  /* Terms of purchase 1 */
   strcat(h1String_850,"%-*s");  /* Terms of purchase 2 */
   strcat(h1String_850,"\n");
}

/*---------------------------------------------------------------------------*\
  format H2
\*---------------------------------------------------------------------------*/
void formatH2(void)
{
   strcpy(h2String,"%-*s");        /* Record type 1 */
   strcat(h2String,"%-*s");        /* Record type 2 */
   strcat(h2String,"%0*d");        /* Record sequence */
   strcat(h2String,"%0*d      ");  /* Trading partner id */
   strcat(h2String,"%0*d");        /* Company id */
   strcat(h2String,"%0*d");        /* PO number */
   strcat(h2String,"%0*d");        /* Store */
   strcat(h2String,"%-*s");        /* Charge Indicator */
   strcat(h2String,"%-*s");        /* Vics */
   strcat(h2String,"%-*s");        /* New Store Rush Order */
   strcat(h2String,"%-*s");        /* Sac Description */
   strcat(h2String,"\n");

}

/*---------------------------------------------------------------------------*\
  format H3
\*---------------------------------------------------------------------------*/
void formatH3(void)
{
   strcpy(h3String,"%-*s");        /* Record type 1 */
   strcat(h3String,"%-*s");        /* Record type 2 */
   strcat(h3String,"%0*d");        /* Record sequence */
   strcat(h3String,"%0*d      ");  /* Trading partner id */
   strcat(h3String,"%0*d");        /* Company id */
   strcat(h3String,"%0*d");        /* PO number */
   strcat(h3String,"%0*d");        /* Store */
   strcat(h3String,"%-*s");        /* Description Type */
   strcat(h3String,"%-*s");        /* PO Header Comments */
   strcat(h3String,"\n");

}

/*---------------------------------------------------------------------------*\
  format H4
\*---------------------------------------------------------------------------*/
void formatH4(void)
{

      strcpy(h4String_850,"%-*s");        /* Record type 1 */
      strcat(h4String_850,"%-*s");        /* Record type 2 */
      strcat(h4String_850,"%0*d");        /* Record sequence */
      strcat(h4String_850,"%0*d      ");  /* Trading partner id */
      strcat(h4String_850,"%0*d");        /* Company id */
      strcat(h4String_850,"%0*d");        /* PO number */
      strcat(h4String_850,"%0*d");        /* Store */
      strcat(h4String_850,"%-*s");        /* Ship to Mark for */
      strcat(h4String_850,"%-*s");        /* Address 1 */
      strcat(h4String_850,"%-*s");        /* Address 2 */
      strcat(h4String_850,"%-*s");        /* City */
      strcat(h4String_850,"%-*s");        /* State */
      strcat(h4String_850,"%-*s");        /* Zip */
      strcat(h4String_850,"%-*s");        /* Country */
      strcat(h4String_850,"%-*s");        /* Warehouse Decription */
      strcat(h4String_850,"\n");
}

/*---------------------------------------------------------------------------*\
  format D1
  Note: output format for D1 record for 850 and 860 are different
        make sure when validating that using correct layout 
\*---------------------------------------------------------------------------*/
void formatD1(void)
{
   /* format string for 850 */
   strcpy(d1String850,"%-*s");        /* Record type 1 */
   strcat(d1String850,"%-*s");        /* Record type 2 */
   strcat(d1String850,"%0*d");        /* Record sequence */
   strcat(d1String850,"%0*d      ");  /* Trading partner id */
   strcat(d1String850,"%0*d");        /* Company id */
   strcat(d1String850,"%0*d");        /* PO number */
   strcat(d1String850,"%0*d");        /* Store */
   strcat(d1String850,"%0*ld");       /* Item_sku_number */
   strcat(d1String850,"%0*d");        /* Item Store # */
   strcat(d1String850,"%0*d");        /* Detail Record Sub Seq */
   strcat(d1String850,"%-*s");        /* Vendor Model Number */
   strcat(d1String850,"%0*d");        /* Item Quantity */
   strcat(d1String850,"%-*s");        /* UOM Identifier */
   strcat(d1String850,"%0*ld");       /* Gross Unit Cost */
   strcat(d1String850,"%-*s");        /* UPC */
   strcat(d1String850,"%-*s");        /* Retail Price Identifier */
   strcat(d1String850,"%0*ld");       /* Retail Price */
   strcat(d1String850,"%-*s");        /* Buyers Color Qualifier */
   strcat(d1String850,"%-*s");        /* Buyers Color Description */
   strcat(d1String850,"%-*s");        /* Buyers Size Qualifier */
   strcat(d1String850,"%-*s");        /* Buyers Size Description */
   strcat(d1String850,"%-*s");        /* Compare_to_price_id */
   strcat(d1String850,"%0*ld");       /* Compare_to_price */
   strcat(d1String850,"\n");
}

/*---------------------------------------------------------------------------*\
  format D2
\*---------------------------------------------------------------------------*/
void formatD2(void)
{
   strcpy(d2String,"%-*s");        /* Record type 1 */
   strcat(d2String,"%-*s");        /* Record type 2 */
   strcat(d2String,"%0*d");        /* Record sequence */
   strcat(d2String,"%0*d      ");  /* Trading partner id */
   strcat(d2String,"%0*d");        /* Company id */
   strcat(d2String,"%0*d");        /* PO number */
   strcat(d2String,"%0*d");        /* Store */
   strcat(d2String,"%0*ld");       /* Item_sku_number */
   strcat(d2String,"%-*s");        /* UPC */
   strcat(d2String,"%-*s");        /* Vendor Model Number */
   strcat(d2String,"%0*d");        /* Detail Record Sub Set */
   strcat(d2String,"%-*s");        /* Charge Indicator */
   strcat(d2String,"%-*s");        /* Vics */
   strcat(d2String,"%-*s");        /* code - ticket or hanger */
   strcat(d2String,"%-*s");        /* code description - ticket or hanger */
   strcat(d2String,"\n");

}

/*---------------------------------------------------------------------------*\
  format D3 (SDQ rec)
\*---------------------------------------------------------------------------*/
void formatD3(void)
{
   strcpy(d3String,"%-*s");        /* Record type 1 */
   strcat(d3String,"%-*s");        /* Record type 2 */
   strcat(d3String,"%0*d");        /* Record sequence */
   strcat(d3String,"%0*d      ");  /* Trading partner id */
   strcat(d3String,"%0*d");        /* Company id */
   strcat(d3String,"%0*d");        /* PO number */
   strcat(d3String,"%0*d");        /* Store */
   strcat(d3String,"%0*ld");       /* Item_sku_number */
   strcat(d3String,"%-*s");        /* UPC */
   strcat(d3String,"%-*s");        /* Vendor Model Number */
   strcat(d3String,"%-*s");        /* SDQ text */
   strcat(d3String,"%-*s");        /* UOM identifier */
   strcat(d3String,"%0*d");        /* DC number */
   strcat(d3String,"%0*d");        /* Qty ordered */
   strcat(d3String,"%-*s");        /* SA Fill */
}

/*---------------------------------------------------------------------------*\
  format POVNDP
\*---------------------------------------------------------------------------*/
void formatPOVNDP(void)
{
   strcpy(poVndpString,"%-*s");        /* Record type 1 */
   strcat(poVndpString,"%-*s");        /* Record type 2 */
   strcat(poVndpString,"%0*d");        /* Record sequence */
   strcat(poVndpString,"%0*d      ");  /* Trading partner id */
   strcat(poVndpString,"%0*d");        /* Company id */
   strcat(poVndpString,"%0*d");        /* PO number */
   strcat(poVndpString,"%0*d");        /* Store */
   strcat(poVndpString,"%0*ld");       /* Vendor pack item number */
   strcat(poVndpString,"%0*d");        /* Detail Record Sub Seq */
   strcat(poVndpString,"%-*s");        /* Vendor Model Number */
   strcat(poVndpString,"%0*d");        /* Pack Units */
   strcat(poVndpString,"%-*s");        /* UOM identifier */
   strcat(poVndpString,"%0*ld");       /* Pack Unit Cost */
   strcat(poVndpString,"%-*s");        /* Pack UPC */
   strcat(poVndpString,"%0*d");        /* Total_Subline_QTY */
   strcat(poVndpString,"\n");

}

/*===========================================================================*\
  function process() - calls validatePO(), processBulk(), processAlloc()
\*===========================================================================*/
int process(void)
{
   char *function_name = "process";
   char  ls_backhaul_type[2] = "";
   short li_backhaul_type_ind;
   char  ls_old_terms[NULL_TERMS];
   char  ls_new_terms[NULL_TERMS];
   short li_old_terms_ind;

   char poFullAlloc[2] = "";
   char poStandAloneSDC[2] = ""; 
   
/*---------------------------------------------------------------------------*\
  cursor GetStdAloneSDC
\*---------------------------------------------------------------------------*/
   EXEC SQL DECLARE cursorGetStdAloneSDC CURSOR FOR
   SELECT to_char(count(*))
     FROM ordhead oh,
          v_smr_stand_alone_wh wh
    WHERE wh.wh = oh.location
      and oh.order_no = TO_NUMBER(:orderNo);

/*---------------------------------------------------------------------------*\
  cursor GetRevNo
\*---------------------------------------------------------------------------*/
   EXEC SQL DECLARE cursorGetRevNo CURSOR FOR
   SELECT NVL(max(rev_no),0)
     FROM ordhead_rev ohr
    WHERE ohr.order_no = TO_NUMBER(:orderNo)
      AND ohr.origin_type = 'V';


/*---------------------------------------------------------------------------*\
  cursor GetGroupID
\*---------------------------------------------------------------------------*/
/***************
   po_seq++;
   EXEC SQL DECLARE cursorGetGroupID CURSOR FOR
     SELECT '106_EDI_850_860_'||to_char(v.vdate,'YYYYMMDD')||'_'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.nextval),10,'0') 
       FROM period v;
       
   EXEC SQL EXECUTE
     SMR_LEAP_INTERFACE_SQL.GENERATE_GROUP_ID(O_error_message,
                                                 L_interface_Id,
                                                 L_group_id);
****************/     
/*---------------------------------------------------------------------------*\
  cursor NewLocToAlloc
\*---------------------------------------------------------------------------*/
   EXEC SQL DECLARE c_cursor_NewLocToAlloc CURSOR FOR
   SELECT NVL(NewLoc,0)
     FROM (
     SELECT DISTINCT (to_loc) NewLoc
       FROM alloc_detail
      WHERE alloc_no IN (SELECT alloc_no FROM alloc_header WHERE order_no = TO_NUMBER(:orderNo))
        AND qty_allocated > 0 
       MINUS
      SELECT DISTINCT (alc_to_loc)NewLoc
       FROM smr_edi_ord_extract_hist
      WHERE order_no = TO_NUMBER(:orderNo));

/*---------------------------------------------------------------------------*\
  cursor POInfo
\*---------------------------------------------------------------------------*/
   EXEC SQL DECLARE cursorPOInfo CURSOR FOR
   /*------------------------------------------------------------------------*\
     pull 850 bulk or stand alone orders only
   \*------------------------------------------------------------------------*/
  SELECT ordhead_rowid,
          order_no,
          status,
          supplier,
          orig_approval_date,
          dept,
          buyer,
          not_before_date,
          not_after_date,
          buyer_name,
          buyer_phone,
          terms_code,
          start_date,
          location,
          wh_name,
          total_po_qty,
          edi_po_ind,
          comment_desc,
          qc_ind,
          last_sent_rev_no,
          po_full_alloc
  FROM (
   SELECT ROWIDTOCHAR(oh.rowid) ordhead_rowid,
          oh.order_no order_no,
          oh.status status,
          to_char(oh.supplier) supplier,
          to_char(oh.orig_approval_date,'YYYYMMDD') orig_approval_date,
          oh.dept dept,
          nvl(oh.buyer,d.buyer) buyer,
          to_char(oh.not_before_date,'YYYYMMDD') not_before_date,
          to_char(oh.not_after_date,'YYYYMMDD') not_after_date,
          substr(nvl(b.buyer_name,b1.buyer_name),1,60) buyer_name,
          nvl(b.buyer_phone,b1.buyer_phone) buyer_phone,
          substr(t.terms_code,1,30) terms_code,
          to_char(p.start_date, 'YYYYMMDD') start_date,
          oh.location location,
          substr(w.wh_name,1,25) wh_name,
          to_char(d.total_po_qty) total_po_qty,
          oh.edi_po_ind edi_po_ind,
          substr(rtrim(REPLACE(oh.comment_desc, chr(10), null)),1,length(rtrim(REPLACE(oh.comment_desc, chr(10), null)))) comment_desc,
          oh.qc_ind qc_ind,
          oh.last_sent_rev_no last_sent_rev_no,
          'N' po_full_alloc
     FROM ordhead oh,
          smr_ord_extract soe,
          sups s,
          buyer b,
          terms_head t,
          rpm_promo p,
          period v,
          deps d,
          buyer b1,
          wh w,
          (select sum(total_po_qty) total_po_qty ,order_no from( 
            select b.order_no, sum( qty_ordered*pack_qty) total_po_qty     -- for B and V Packs  
            from packitem a,  ordloc b,  ordsku c,item_master i
           where b.item = c.item
             and a.pack_no = c.item
             and i.item= c.item
             and i.pack_ind = 'Y'
             and i.pack_type = 'B'
             and b.qty_ordered > 0      
             and b.order_no = c.order_no
           group by b.order_no
           union                                                          -- for non Packs 
           select order_no, sum(qty_ordered) total_po_qty
             from ordloc b,item_master i
            where b.item = i.item
              and ((i.pack_ind = 'N') or (i.pack_ind = 'Y' and i.pack_type = 'V'))
              and b.qty_ordered > 0
            group by order_no ) group by order_no ) d, 
          v_restart_supplier v
    WHERE oh.status = 'A'
          AND oh.order_no = soe.order_no
          AND soe.extract_850_ind = 'N'
          -- Do not pull E3 bulk orders
          AND NOT EXISTS (select 'x'
                            from ordhead oh,
                                 alloc_header ah
                           where oh.order_no = ah.order_no
                             and oh.order_no = soe.order_no
                             and oh.vendor_order_no is not null
                             and oh.order_type = 'ARB'
                             and oh.orig_ind = 5
                             and oh.location = :ps_bk_wh
                             and ah.po_type = 'RO'
                             and ah.alloc_desc like 'createordlib%')
          /*-----------------------------------------------------------------*\
            do not pull orders if already received
          \*-----------------------------------------------------------------*/
          AND NOT EXISTS (select 'Y' from ordloc l
                           where l.order_no = oh.order_no and l.qty_received > 0)
          /*-----------------------------------------------------------------*\
            cannot extract if no location specified on header for PO 
            sometimes orders create incorrectly from allocation; is a problem
          \*-----------------------------------------------------------------*/
          AND oh.location is not null
          AND oh.supplier = s.supplier
          AND oh.buyer = b.buyer(+)
          AND oh.terms = t.terms
          AND oh.location = w.wh
          AND oh.promotion = p.promo_id(+)
          AND oh.order_no = d.order_no
          AND oh.dept = d.dept
          AND d.buyer = b1.buyer
          /* restart recovery */
          AND v.driver_value = oh.supplier
          AND v.num_threads = TO_NUMBER(:restartNumThreads)
          AND v.thread_val = TO_NUMBER(:restartThreadVal)
   UNION
   /*------------------------------------------------------------------------*\
     pull 850 release orders only 
   \*------------------------------------------------------------------------*/
   SELECT ROWIDTOCHAR(oh.rowid),
          oh.order_no,
          oh.status,
          to_char(oh.supplier),
          to_char(oh.orig_approval_date,'YYYYMMDD'),
          oh.dept,
          nvl(oh.buyer,d.buyer),
          to_char(oh.not_before_date,'YYYYMMDD'),
          to_char(oh.not_after_date,'YYYYMMDD'),
          substr(nvl(b.buyer_name,b1.buyer_name),1,60),
          nvl(b.buyer_phone,b1.buyer_phone),
          substr(t.terms_code,1,30),
          to_char(p.start_date, 'YYYYMMDD'),
          oh.location,
          substr(w.wh_name,1,25),
          to_char(d.total_po_qty),
          oh.edi_po_ind,
          substr(rtrim(REPLACE(oh.comment_desc, chr(10), null)),1,length(rtrim(REPLACE(oh.comment_desc, chr(10), null)))),
          oh.qc_ind,                                                                        
          oh.last_sent_rev_no,
          'Y'
     FROM ordhead oh,
          smr_ord_extract soe,
          sups s,
          buyer b,
          terms_head t,
          rpm_promo p,
          deps d,
          buyer b1,
          wh w,
          (select sum(total_po_qty) total_po_qty ,order_no from( 
            select b.order_no, sum( qty_ordered*pack_qty) total_po_qty     -- for B and V Packs 
            from packitem a,  ordloc b,  ordsku c,item_master i
           where b.item = c.item
             and a.pack_no = c.item
             and i.item= c.item
             and i.pack_ind = 'Y'
             and i.pack_type = 'B'
             and b.qty_ordered > 0  
             and b.order_no = c.order_no
           group by b.order_no
           union                                                          -- for non Packs 
           select order_no, sum(qty_ordered) total_po_qty
             from ordloc b,item_master i
            where b.item = i.item
              and ((i.pack_ind = 'N') or (i.pack_ind = 'Y' and i.pack_type = 'V'))
              and b.qty_ordered > 0
            group by order_no ) group by order_no ) d, 
           v_smr_unallocated_order v_o, 
           v_restart_supplier v
    WHERE oh.status = 'A'
          AND oh.order_no = soe.order_no
          /*------------------------------------------------------------------------*\
            pull only non-E3 bulk orders which have been extracted
            or pull release order info for E3 bulk orders which have not extracted yet
          \*------------------------------------------------------------------------*/
          AND ((soe.extract_850_ind = 'Y' and soe.extract_850_rel_ind ='N' and oh.location != :ps_bk_wh)
           OR  (soe.extract_850_ind = 'N' and extract_850_rel_ind='N' 
                                          and EXISTS (select 'x' -- and is an E3 bulk order
                                                        from ordhead oh1,
                                                             alloc_header ah1
                                                       where oh1.order_no = ah1.order_no
                                                         and oh1.order_no = soe.order_no
                                                         and oh1.vendor_order_no is not null
                                                         and oh1.order_type = 'ARB'
                                                         and oh1.orig_ind = 5
                                                         and oh1.location = :ps_bk_wh
                                                         and ah1.po_type = 'RO'
                                                         and ah1.alloc_desc like 'createordlib%')))
          /*------------------------------------------------------------------------*\
            not a stand alone order
          \*------------------------------------------------------------------------*/
          AND oh.location not in (select wh from v_smr_stand_alone_wh) 
          /*------------------------------------------------------------------------*\
            do not pull orders that already have receipts
          \*------------------------------------------------------------------------*/
          AND NOT EXISTS (select 'Y' from ordloc l
                          where l.order_no = oh.order_no and l.qty_received > 0)
          AND oh.order_no = v_o.order_no (+) 
          AND v_o.order_no is null           
          /*-----------------------------------------------------------------*\
            cannot extract if no location specified on header for PO 
            sometimes orders create incorrectly from allocation; is a problem
          \*-----------------------------------------------------------------*/
          AND oh.location is not null
          AND oh.supplier = s.supplier
          AND oh.buyer = b.buyer(+)
          AND oh.terms = t.terms
          AND oh.location = w.wh
          AND oh.promotion = p.promo_id(+)
          AND oh.order_no = d.order_no
          AND oh.dept = d.dept
          AND d.buyer = b1.buyer
          /* restart recovery */
          AND v.driver_value = oh.supplier
          AND v.num_threads = TO_NUMBER(:restartNumThreads)
          AND v.thread_val = TO_NUMBER(:restartThreadVal)
UNION
   /*------------------------------------------------------------------------*\
     Process orders to be re-sent
   \*------------------------------------------------------------------------*/
     SELECT ROWIDTOCHAR(oh.rowid),
          oh.order_no,
          oh.status,
          to_char(oh.supplier),
          to_char(oh.orig_approval_date,'YYYYMMDD'),
          oh.dept,
          nvl(oh.buyer,deps.buyer),
          to_char(oh.not_before_date,'YYYYMMDD'),
          to_char(oh.not_after_date,'YYYYMMDD'),
          substr(nvl(b.buyer_name,b1.buyer_name),1,60),
          nvl(b.buyer_phone,b1.buyer_phone),
          substr(t.terms_code,1,30),
          to_char(p.start_date, 'YYYYMMDD'),
          oh.location,
          substr(w.wh_name,1,25),
          to_char(d.total_po_qty),
          oh.edi_po_ind,
          substr(rtrim(REPLACE(oh.comment_desc, chr(10), null)),1,length(rtrim(REPLACE(oh.comment_desc, chr(10), null)))),
          oh.qc_ind,
          oh.last_sent_rev_no,
          'N'
     FROM ordhead oh,
          smr_ord_extract soe,
          smr_850_resend sor,
          sups s,
          buyer b,
          terms_head t,
          rpm_promo p,
          deps,
          buyer b1,
          wh w,
          (select sum(total_po_qty) total_po_qty ,order_no from( 
            select b.order_no, sum( qty_ordered*pack_qty) total_po_qty     -- for B and V Packs  
            from packitem a,  ordloc b,  ordsku c,item_master i
           where b.item = c.item
             and a.pack_no = c.item
             and i.item= c.item
             and i.pack_ind = 'Y'
             and i.pack_type = 'B'
             and b.qty_ordered > 0 
             and b.order_no = c.order_no
           group by b.order_no
           union                                                          -- for non Packs 
           select order_no, sum(qty_ordered) total_po_qty
             from ordloc b,item_master i
            where b.item = i.item
              and ((i.pack_ind = 'N') or (i.pack_ind = 'Y' and i.pack_type = 'V'))
              and b.qty_ordered > 0
            group by order_no ) group by order_no ) d,
           v_restart_supplier v
    WHERE oh.status = 'A'
          AND oh.order_no = soe.order_no
          AND oh.order_no = sor.order_no
          AND soe.extract_850_ind = 'Y'
          AND nvl(extract_850_rel_ind,'N')='N' 
          and exists (select order_details.order_no unallocated
                        from
                              (
                              SELECT oh2.order_no, NVL(pb.item,ol.item) item, sum(NVL(pb.pack_item_qty,1) * ol.qty_ordered) * decode(oh2.status, 'A', 1, -1) as qty
                                FROM ordloc ol
                                    ,ordhead oh2
                                    ,packitem_breakout pb
                                    ,smr_850_resend sor2
                               WHERE ol.order_no = oh2.order_no
                                 AND ol.qty_ordered > 0
                                 AND ol.item = pb.pack_no (+)
                                 AND oh2.order_no = sor2.order_no
                               GROUP by oh2.order_no, NVL(pb.item,ol.item), oh2.status
                              ) order_details,
                              (
                              SELECT ah.order_no, NVL(pb.item,ah.item) item, sum(NVL(pb.pack_item_qty,1) * ad.qty_allocated) qty
                                FROM alloc_header ah,
                                     alloc_detail ad,
                                     packitem_breakout pb,
                                     smr_850_resend sor2
                               WHERE ad.alloc_no = ah.alloc_no
                                 AND ah.order_no IS NOT NULL
                                 AND ah.status IN ('A','C')    
                                 AND ad.qty_allocated > 0
                                 AND ah.item = pb.pack_no (+)
                                 AND ah.order_no = sor2.order_no
                               GROUP by ah.order_no, NVL(pb.item,ah.item)
                              ) allocation_details
                       where order_details.order_no = allocation_details.order_no (+)
                         and order_details.item     = allocation_details.item     (+)
                         and order_details.qty      > nvl(allocation_details.qty,0)
                         and order_details.order_no = oh.order_no)         
          /*------------------------------------------------------------------------*\
            Do not pull E3 bulk orders
          \*------------------------------------------------------------------------*/
          AND NOT EXISTS (select 'x' -- and is an E3 bulk order
                            from ordhead oh1,
                                 alloc_header ah1
                           where oh1.order_no = ah1.order_no
                             and oh1.order_no = soe.order_no
                             and oh1.vendor_order_no is not null
                             and oh1.order_type = 'ARB'
                             and oh1.orig_ind = 5
                             and oh1.location = :ps_bk_wh
                             and ah1.po_type = 'RO'
                             and ah1.alloc_desc like 'createordlib%')
          /*-----------------------------------------------------------------*\
            do not pull orders that already have receipts
            cannot extract if no location specified on header for PO 
            sometimes orders create incorrectly from allocation; is a problem
          \*-----------------------------------------------------------------*/
          AND oh.location is not null
          AND oh.supplier = s.supplier
          AND oh.buyer = b.buyer(+)
          AND oh.terms = t.terms
          AND oh.location = w.wh
          AND oh.promotion = p.promo_id(+)
          AND oh.order_no = d.order_no
          AND oh.dept = deps.dept
          AND deps.buyer = b1.buyer
          /* restart recovery */
          AND v.driver_value = oh.supplier
          AND v.num_threads = TO_NUMBER(:restartNumThreads)
          AND v.thread_val = TO_NUMBER(:restartThreadVal)
  UNION
   /*------------------------------------------------------------------------*\
     pull 850 release orders only in second part 
   \*------------------------------------------------------------------------*/
   SELECT ROWIDTOCHAR(oh.rowid),
          oh.order_no,
          oh.status,
          to_char(oh.supplier),
          to_char(oh.orig_approval_date,'YYYYMMDD'),
          oh.dept,
          nvl(oh.buyer,deps.buyer),
          to_char(oh.not_before_date,'YYYYMMDD'),
          to_char(oh.not_after_date,'YYYYMMDD'),
          substr(nvl(b.buyer_name,b1.buyer_name),1,60),
          nvl(b.buyer_phone,b1.buyer_phone),
          substr(t.terms_code,1,30),
          to_char(p.start_date, 'YYYYMMDD'),
          oh.location,
          substr(w.wh_name,1,25),
          to_char(d.total_po_qty),
          oh.edi_po_ind,
          substr(rtrim(REPLACE(oh.comment_desc, chr(10), null)),1,length(rtrim(REPLACE(oh.comment_desc, chr(10), null)))),
          oh.qc_ind,
          oh.last_sent_rev_no,
          'Y'
     FROM ordhead oh,
          smr_850_resend sor,
          smr_ord_extract soe,
          sups s,
          buyer b,
          terms_head t,
          rpm_promo p,
          deps,
          buyer b1,
          wh w,
          (select sum(total_po_qty) total_po_qty ,order_no from(
            select b.order_no, sum( qty_ordered*pack_qty) total_po_qty     -- for B and V Packs  
            from packitem a,  ordloc b,  ordsku c,item_master i
           where b.item = c.item
             and a.pack_no = c.item
             and i.item= c.item
             and i.pack_ind = 'Y'
             and i.pack_type = 'B'
             and b.qty_ordered > 0 
             and b.order_no = c.order_no
           group by b.order_no
           union                                                          -- for non Packs 
           select order_no, sum(qty_ordered) total_po_qty
             from ordloc b,item_master i
            where b.item = i.item
              and ((i.pack_ind = 'N') or (i.pack_ind = 'Y' and i.pack_type = 'V'))
              and b.qty_ordered > 0
            group by order_no ) group by order_no ) d, 
          v_restart_supplier v
    WHERE oh.status = 'A'
          AND oh.order_no = soe.order_no
          AND oh.order_no = sor.order_no
          /*-----------------------------------------------------------------*\
            for release orders that need 850 sent 
            pull only non-E3 bulk orders which have been extracted or pull
            release order info for E3 bulk orders which have been extracted
          \*-----------------------------------------------------------------*/
          AND ((soe.extract_850_ind = 'Y' and soe.extract_850_rel_ind ='N' and oh.location != :ps_bk_wh)
--          AND ((soe.extract_850_ind = 'Y' and extract_850_rel_ind='Y')
           OR (soe.extract_850_ind = 'N' and extract_850_rel_ind='Y' 
                                         AND EXISTS (select 'x' -- and is an E3 bulk order
                                                       from ordhead oh1,
                                                            alloc_header ah1
                                                      where oh1.order_no = ah1.order_no
                                                        and oh1.order_no = soe.order_no
                                                        and oh1.vendor_order_no is not null
                                                        and oh1.order_type = 'ARB'
                                                        and oh1.orig_ind = 5
                                                        and oh1.location = :ps_bk_wh
                                                        and ah1.po_type = 'RO'
                                                        and ah1.alloc_desc like 'createordlib%')))
          AND oh.location not in (select wh from v_smr_stand_alone_wh) /* not stand alone order */ 
          /*-----------------------------------------------------------------*\
            for release orders that need 850 sent 
            pull only non-E3 bulk orders which have been extracted or pull
            release order info for E3 bulk orders which have been extracted
          \*-----------------------------------------------------------------*/
          /* do not pull orders that already have receipts */
          and not exists (select order_details.order_no unallocated
                            from
                                  (
                                  SELECT oh2.order_no, NVL(pb.item,ol.item) item, sum(NVL(pb.pack_item_qty,1) * ol.qty_ordered) * decode(oh2.status, 'A', 1, -1) as qty
                                    FROM ordloc ol
                                        ,ordhead oh2
                                        ,packitem_breakout pb
                                        ,smr_850_resend sor2
                                   WHERE ol.order_no = oh2.order_no
                                     AND ol.qty_ordered > 0
                                     AND ol.item = pb.pack_no (+)
                                     AND oh2.order_no = sor2.order_no
                                   GROUP by oh2.order_no, NVL(pb.item,ol.item), oh2.status
                                  ) order_details,
                                  (
                                  SELECT ah.order_no, NVL(pb.item,ah.item) item, sum(NVL(pb.pack_item_qty,1) * ad.qty_allocated) qty
                                    FROM alloc_header ah,
                                         alloc_detail ad,
                                         packitem_breakout pb,
                                         smr_850_resend sor2
                                   WHERE ad.alloc_no = ah.alloc_no
                                     AND ah.order_no IS NOT NULL
                                   --AND ah.status IN ('A','R','C')
                                     AND ah.status IN ('A','C')    
                                     AND ad.qty_allocated > 0
                                     AND ah.item = pb.pack_no (+)
                                     AND ah.order_no = sor2.order_no
                                   GROUP by ah.order_no, NVL(pb.item,ah.item)
                                  ) allocation_details
                           where order_details.order_no = allocation_details.order_no (+)
                             and order_details.item     = allocation_details.item     (+)
                             and order_details.qty      > nvl(allocation_details.qty,0)
                             and order_details.order_no = oh.order_no)         
          /* cannot extract if no location specified on header for PO - sometimes
             order created incorrectly from allocation that is problem             */
          AND oh.location is not null
          AND oh.supplier = s.supplier
          AND oh.buyer = b.buyer(+)
          AND oh.terms = t.terms
          AND oh.location = w.wh
          AND oh.promotion = p.promo_id(+)
          AND oh.order_no = d.order_no
          AND oh.dept = deps.dept
          AND deps.buyer = b1.buyer
          /* restart recovery */
          AND v.driver_value = oh.supplier
          AND v.num_threads = TO_NUMBER(:restartNumThreads)
          AND v.thread_val = TO_NUMBER(:restartThreadVal) 
   UNION
   /* pick orders to add locations to allocations */
   SELECT ROWIDTOCHAR(oh.rowid),
          oh.order_no,
          oh.status,
          to_char(oh.supplier),
          to_char(oh.orig_approval_date,'YYYYMMDD'),
          oh.dept,
          nvl(oh.buyer,d.buyer),
          to_char(oh.not_before_date,'YYYYMMDD'),
          to_char(oh.not_after_date,'YYYYMMDD'),
          substr(nvl(b.buyer_name,b1.buyer_name),1,60),
          nvl(b.buyer_phone,b1.buyer_phone),
          substr(t.terms_code,1,30),
          to_char(p.start_date, 'YYYYMMDD'),
          oh.location,
          substr(w.wh_name,1,25),
          to_char(d.total_po_qty),
          oh.edi_po_ind,
          substr(rtrim(REPLACE(oh.comment_desc, chr(10), null)),1,length(rtrim(REPLACE(oh.comment_desc, chr(10), null)))),
          oh.qc_ind,
          oh.last_sent_rev_no,
          'Y'
     FROM ordhead oh,
          ordhead_rev ohr,
          smr_ord_extract soe,
          sups s,
          buyer b,
          terms_head t,
          rpm_promo p,
          deps d,
          buyer b1,
          wh w,
          (select sum(total_po_qty) total_po_qty ,order_no from(
            select b.order_no, sum( qty_ordered*pack_qty) total_po_qty
            from packitem a,  ordloc b,  ordsku c,item_master i
           where b.item = c.item
             and a.pack_no = c.item
             and i.item= c.item
             and i.pack_ind = 'Y'
             and i.pack_type = 'B'
             and b.qty_ordered > 0
             and b.order_no = c.order_no
           group by b.order_no
           union
           select order_no, sum(qty_ordered) total_po_qty
             from ordloc b,item_master i
            where b.item = i.item
              and ((i.pack_ind = 'N') or (i.pack_ind = 'Y' and i.pack_type = 'V'))
              and b.qty_ordered > 0
            group by order_no ) group by order_no ) d,
          v_smr_unallocated_order v_o,
          v_restart_supplier v
    WHERE oh.status = 'A'
          AND oh.order_no = soe.order_no
          and ohr.order_no = soe.order_no
          AND ohr.rev_no = soe.last_extract_rev_no
          -- AND soe.extract_850_ind = 'Y' and extract_850_rel_ind='Y'
          -- Pull only non-E3 bulk orders which have been extracted
          -- or pull release order info for E3 bulk orders which have been extracted
          AND ((soe.extract_850_ind = 'Y' and soe.extract_850_rel_ind ='N' and oh.location != :ps_bk_wh)
--          AND ((soe.extract_850_ind = 'Y' and extract_850_rel_ind='Y')
           OR (soe.extract_850_ind = 'N' and extract_850_rel_ind='Y' 
                                         AND EXISTS (select 'x' -- and is an E3 bulk order
                                                       from ordhead oh1,
                                                            alloc_header ah1
                                                      where oh1.order_no = ah1.order_no
                                                        and oh1.order_no = soe.order_no
                                                        and oh1.vendor_order_no is not null
                                                        and oh1.order_type = 'ARB'
                                                        and oh1.orig_ind = 5
                                                        and oh1.location = :ps_bk_wh
                                                        and ah1.po_type = 'RO'
                                                        and ah1.alloc_desc like 'createordlib%')))
          AND oh.location not in (select wh from v_smr_stand_alone_wh) /* not stand alone order */ 
          AND NOT EXISTS (select 'Y' from ordloc l
                          WHERE l.order_no = oh.order_no and l.qty_received > 0)
          AND EXISTS (SELECT DISTINCT (to_loc)
                        FROM alloc_detail ad ,alloc_header ah
                       WHERE ah.alloc_no = ad.alloc_no
                         AND ah.order_no =oh.order_no
                         AND ad.qty_allocated > 0 
                       MINUS
                      SELECT DISTINCT (alc_to_loc)
                        FROM smr_edi_ord_extract_hist sh
                       WHERE sh.order_no =oh.order_no)
          and oh.order_no = v_o.order_no (+) 
          and v_o.order_no is null           
          AND oh.location is not null
          AND oh.supplier = s.supplier
          AND oh.buyer = b.buyer(+)
          AND oh.terms = t.terms
          AND oh.location = w.wh
          AND oh.promotion = p.promo_id(+)
          AND oh.order_no = d.order_no
          AND oh.dept = d.dept
          AND d.buyer = b1.buyer
          /* restart recovery */
          AND v.driver_value = oh.supplier
          AND v.num_threads = TO_NUMBER(:restartNumThreads)
          AND v.thread_val = TO_NUMBER(:restartThreadVal))
   WHERE supplier not in (select supplier from smr_no_sdq_edi_sup)
   ORDER BY 2, 3;

/*---------------------------------------------------------------------------*\
  cursor lock_po
\*---------------------------------------------------------------------------*/
   EXEC SQL DECLARE c_lock_po CURSOR FOR
   SELECT 'x'
     FROM ordhead
    WHERE rowid = CHARTOROWID(:ps_rowid)
      FOR update nowait;

   EXEC SQL OPEN cursorPOInfo;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorPOInfo");
      strcpy(table, "ordhead,ordhead_rev,sups,v_restart_supplier");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }


   EXEC SQL OPEN c_cursor_NewLocToAlloc;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_cursor_NewLocToAlloc");
      strcpy(table, "alloc_detail,smr_edi_ord_extract_hist");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }


   #ifdef DEBUG
   printf("Loop through fetches of cursorPOInfo next\n");
   #endif

   while (1)
   {
      EXEC SQL FETCH cursorPOInfo INTO  :ps_rowid,
                                        :orderNo,
                                        :orderStatus,
                                        :supplier,
                                        :originalApproveDate,
                                        :orderDept:orderDeptInd,
                                        :buyer:buyerInd,
                                        :newNotBeforeDate,
                                        :newNotAfterDate,
                                        :buyerName:buyerInd,
                                        :buyerPhone:buyerPhoneInd,
                                        :termsCode,
                                        :promoStartDate:promoStartDateInd,
                                        :orderLocation:orderLocationInd,
                                        :whName:whNameInd,
                                        :orderTotalQty,
                                        :orderEDIPOInd,
                                        :poHeaderComments:poHeaderCommentsInd,
                                        :orderQCInd,  
                                        :lastSentRevNo:lastSentRevNoInd,
                                        :poFullAlloc;


      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorPOInfo");
         strcpy(table, "ordhead,ordhead_rev,sups,v_restart_supplier");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }
      if NO_DATA_FOUND break;


      EXEC SQL FETCH c_cursor_NewLocToAlloc INTO :NewLoc;

      #ifdef DEBUG
      printf("  order number is <%s>\n", orderNo);
      printf("  NewLoc is <%s>\n", NewLoc);
      #endif


      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=c_cursor_NewLocToAlloc");
         strcpy(table, "alloc_detail,smr_edi_ord_extract_hist");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }

      #ifdef DEBUG
      printf("Lock PO next\n");
      #endif

      EXEC SQL OPEN c_lock_po;
      if SQL_ERROR_FOUND
      {


         if (SQLCODE == -1*RECORD_LOCKED)
            continue;
         else
         {
            strcpy(err_data, "CURSOR OPEN: cursor=c_lock_po");
            strcpy(table, "ordhead");
            WRITE_ERROR(SQLCODE,function_name,table,err_data);
            return(FATAL);
         }
      }

      #ifdef DEBUG
      printf("Order Number = %s\n",orderNo);
      #endif

      pi_edi_to_send_flag = 1;

         /* update record descriptions appropriately for 850 */
         strcpy(recTypeDescH1,"S850H1");
         strcpy(recTypeDescH2,"S850H2");
         strcpy(recTypeDescH3,"S850H3");
         strcpy(recTypeDescH4,"S850H4");
         strcpy(recTypeDescD1,"S850D1");
         strcpy(recTypeDescD2,"S850D2");
         strcpy(recTypeDescD3,"S850D3");
         strcpy(recTypeDescD4,"S850D4");
         strcpy(recTypeDescVP,"SPOVND");

      EXEC SQL OPEN cursorGetStdAloneSDC;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR OPEN: cursor=cursorGetStdAloneSDC, order_no=%s", orderNo);
         strcpy(table, "v_smr_stand_alone_wh");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorGetStdAloneSDC INTO :poStandAloneSDC;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR FETCH: cursor=cursorGetStdAloneSDC, order_no=%s", orderNo);
         strcpy(table, "v_smr_stand_alone_wh");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorGetStdAloneSDC;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorGetStdAloneSDC, order_no=%s", orderNo);
         strcpy(table, "v_smr_stand_alone_wh");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }               

      ps_hdr_record_id = 0;
      ps_dtl_record_id = 0; /* back to 1 rec_id for hdr and dtl (just using hdr for now)*/

/************* automate generate group_id
      #ifdef DEBUG
      printf("Fetch of cursorGetGroupID next\n");
      #endif

      EXEC SQL FETCH cursorGetGroupID INTO :ps_group_id;

      #ifdef DEBUG
      printf("  ps_group_id is <%s>\n", ps_group_id);
      #endif

      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorGetGroupID");
         strcpy(table, "period");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }

      EXEC SQL CLOSE cursorGetGroupID;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorGetGroupID, order_no=%s", orderNo);
         strcpy(table, "period");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }               
******************/
         
      /*---------------------------------------------------------------------------*\
        determine PO type - bulk, stand alone, or alloc/release 
      \*---------------------------------------------------------------------------*/

      if (strcmp(poStandAloneSDC,"0") != 0)
         strcpy(poType,SMR_STANDALONE_PO_TYPE);
      else if (strcmp(poFullAlloc,"Y") == 0)
         strcpy(poType,SMR_ALLOC_PO_TYPE);
      else
         strcpy(poType,SMR_BULK_PO_TYPE);

      #ifdef DEBUG
         printf("PO type is %s\n", poType);
      #endif
      strcpy( UOM_D3, "EA" ); /* default D3 to eaches */

      /* get maximum revision number from ordrev */
      if (getMaxRevNo() < OK)
         return(FATAL);

      /*---------------------------------------------------------------------------*\
        validate PO 
      \*---------------------------------------------------------------------------*/
      if (validatePO() == OK)
      {
         #ifdef DEBUG
         printf("RMS order <%s>\n", orderNo);
         printf("order location <%s>\n",orderLocation);
         printf("File pointer is <%ld>\n",ftell(ediFilePtr));
         #endif
         
         /*---------------------------------------------------------------------------*\
           update smr_ord_extract; set wo_860_update_ind = 'N'
         \*---------------------------------------------------------------------------*/
         EXEC SQL update smr_ord_extract
                     set wo_860_update_ind = 'N'
                   WHERE ORDER_NO = TO_NUMBER(:orderNo)
                     AND EXISTS (select 'x' FROM smr_850_resend where order_no = TO_NUMBER(:orderNo));

         /*---------------------------------------------------------------------------*\
           Process Bulk or Alloc 
         \*---------------------------------------------------------------------------*/
         if (strcmp(poType,"BK") == 0 || strcmp(poType,"SA") == 0)
         {
            if (processBulk() < OK)
               return(FATAL);
         }
         else if (strcmp(poType,"RL") == 0)
         {
            EXEC SQL UPDATE smr_ord_extract
                        SET wo_860_update_ind = 'N'
                      WHERE ORDER_NO = TO_NUMBER(:orderNo)
                        AND wo_860_update_ind = 'Y'
                        AND NOT EXISTS (select 'x' FROM smr_edi_ord_extract_hist where order_no = TO_NUMBER(:orderNo));

            /*---------------------------------------------------------------------------*\
              remove history of release to be resent
            \*---------------------------------------------------------------------------*/
            EXEC SQL DELETE FROM smr_edi_ord_extract_hist
                      WHERE ORDER_NO = TO_NUMBER(:orderNo)
                        AND EXISTS (select 'x' FROM smr_850_resend  where order_no = TO_NUMBER(:orderNo))
                        AND EXISTS (SELECT 'X' FROM smr_ord_extract where order_no = TO_NUMBER(:orderNo) and extract_850_rel_ind = 'Y');

       #ifdef DEBUG
          printf("orderLocation is %s\n", orderLocation);
          printf("ps_dd_wh is %s\n", ps_dd_wh);
       #endif

 
            if (strcmp(orderLocation, ps_dd_wh) == 0)
            {
      #ifdef DEBUG
         printf("calling processDDAlloc\n");
      #endif
              if (processDDAlloc() < OK)
                 return(FATAL);
            }
            else
            {
      #ifdef DEBUG
         printf("calling processAlloc\n");
      #endif
              if (processAlloc() < OK)
                 return(FATAL);
            }
         }

      }
      else /* found problem with data;  write error and continue with processing other records */
      {
         return(FATAL);
      }

      #ifdef DEBUG
         printf("%s -  orderEDIPOInd is <%s>\n", function_name, orderEDIPOInd);
         printf("%s -  compare result is <%d>\n", function_name, strcmp(orderEDIPOInd,"Y"));
      #endif

      /*---------------------------------------------------------------------------*\
        update RMS edi order information 
      \*---------------------------------------------------------------------------*/
      if (strcmp(orderEDIPOInd,"Y")==0)
      {
         #ifdef DEBUG
         printf("%s -  update ordhead for EDI order\n", function_name);
         #endif

         /*---------------------------------------------------------------------------*\
           update sent EDI order
         \*---------------------------------------------------------------------------*/         
         EXEC SQL UPDATE ordhead
                     SET po_ack_recvd_ind = 'N',
                         edi_sent_ind = 'Y'
                   WHERE rowid = CHARTOROWID(:ps_rowid);
         
         if (SQL_ERROR_FOUND || NO_DATA_FOUND)
         {
            sprintf(err_data, "UPDATE: po_ack_recvd_ind='N' & edi_sent_ind='Y' for order no %s",
                    orderNo);
            strcpy(table, "ordhead");
            WRITE_ERROR(SQLCODE,function_name,table,err_data);
            return(-1);
         }
         
         EXEC SQL UPDATE ordhead
                     SET last_sent_rev_no = (SELECT NVL(max(rev_no),0)
                                               FROM ordhead_rev ohr
                                              WHERE ohr.order_no = TO_NUMBER(:orderNo)
                                                AND ohr.origin_type = 'V')
                   WHERE order_no = TO_NUMBER(:orderNo)
                     AND ( order_no IN (SELECT order_no FROM smr_850_resend)
                           or
                           order_no IN (SELECT order_no FROM smr_ord_extract WHERE order_no = TO_NUMBER(:orderNo) AND nvl(extract_850_rel_ind,'N') = 'N'));
                           
         if (SQL_ERROR_FOUND )
         {
            sprintf(err_data, "UPDATE: last_sent_rev_no %s",
                    orderNo);
            strcpy(table, "ordhead");
            WRITE_ERROR(SQLCODE,function_name,table,err_data);
            return(-1);
         }                                    
      }

      if (strcmp(poType,"BK") == 0 || strcmp(poType,"SA") == 0)
      {
         #ifdef DEBUG
         printf("%s -  update smr_ord_extract for bulk or stand alone order\n", function_name);
         #endif

         /*---------------------------------------------------------------------------*\
           update smr_ord_extract for bulk or stand alone order
         \*---------------------------------------------------------------------------*/                    
         
         EXEC SQL UPDATE smr_ord_extract
                     SET extract_850_ind = 'Y',
                         extract_850_date = sysdate,
                         last_extract_rev_no = (  SELECT NVL(max(rev_no),0)
                                                    FROM ordhead_rev ohr
                                                   WHERE ohr.order_no = TO_NUMBER(:orderNo)
                                                     AND ohr.origin_type = 'V'),
                         last_update_id = user,
                         last_update_datetime = sysdate
                   WHERE order_no = TO_NUMBER(:orderNo);
       }
      else
      {
         #ifdef DEBUG
         printf("%s -  update smr_ord_extract for release order\n", function_name);
         #endif
         
         /* only set last_extract_rev_no to max if not sending new location for allocation */
         EXEC SQL UPDATE smr_ord_extract
                     SET last_extract_rev_no = (SELECT NVL(max(rev_no),0)
                                                  FROM ordhead_rev ohr
                                                 WHERE ohr.order_no = TO_NUMBER(:orderNo)
                                                   AND ohr.origin_type = 'V')
                   WHERE order_no = TO_NUMBER(:orderNo)
                     AND ( order_no IN (SELECT order_no FROM smr_850_resend)
                           or
                           order_no IN (SELECT order_no FROM smr_ord_extract WHERE order_no = TO_NUMBER(:orderNo) AND extract_850_rel_ind = 'N'));

         EXEC SQL UPDATE smr_ord_extract
                     SET extract_850_rel_ind = 'Y',
                         extract_850_rel_date = sysdate,
                         last_update_id = user,
                         last_update_datetime = sysdate
                   WHERE order_no = TO_NUMBER(:orderNo);

        /* close bulk alloc on RMS-side (this was in alc_alloc approval trigger but mutated on alloc_header) 
         EXEC SQL UPDATE alloc_header
                     SET status = 'C'
                   WHERE order_no = TO_NUMBER(substr(:orderNo,1,6)); */                           
      }

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         sprintf(err_data, "UPDATE: extract indicator for order no %s", orderNo);
         strcpy(table, "smr_ord_extract");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      #ifdef DEBUG
      printf("process - before retek_force_commit for poNumber <%s>\n",poNumber);
      #endif

      #ifdef DEBUG
      printf("File pointer is <%ld>\n",ftell(ediFilePtr));
      #endif

      if (retek_force_commit(1, poNumber) < 0)
         return(FATAL);

   } /* end of po loop */

    EXEC SQL DELETE from smr_850_resend; 

    return(0);

} /* end process */

/**********************************************************************************/
/* getMaxRevNo() -
/**********************************************************************************/
int getMaxRevNo(void)
{
   char *function_name = "getMaxRevNo";

      EXEC SQL OPEN cursorGetRevNo;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR OPEN: cursor=cursorGetRevNo, order_no=%s", orderNo);
         strcpy(table, "ordhead_rev");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorGetRevNo INTO :maxRevNo;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR FETCH: cursor=cursorGetRevNo, order_no=%s", orderNo);
         strcpy(table, "ordhead_rev");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      else if (NO_DATA_FOUND)
      {
         strcpy(err_data, "No rev data found for update.");
         strcpy(table, "ordhead_rev");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorGetRevNo;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorGetRevNo, order_no=%s", orderNo);
         strcpy(table, "ordhead_rev");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

   return(OK);
}

/**********************************************************************************/
/* Process a new bulk PO and create the output records                            */
/**********************************************************************************/
int processBulk()
{
   char *function_name = "processBulk";

   /* populate DC Store Number field */
   strncpy(dcStoreNumber,orderLocation,3);

   #ifdef DEBUG
   printf("in processBulk - dcStoreNumber is <%s> orderLocation is <%s>\n",
          dcStoreNumber,orderLocation);
   #endif

   /* store number for H4 record is same as dcStoreNumber always */
   strcpy(h4StoreNumber, dcStoreNumber);

   /* populate master po number - null/empty for bulk*/
   strcpy(masterPONumber,"");

   strcpy(shipToMarkFor,"ST");

   #ifdef DEBUG
   printf("write rec fields for H1 next\n");
   #endif

   recSequence = 1;
   ps_hb_release = 0;
   if (strlen(orderNo) <= LEN_BULK_ORDER_PO) /* create SMR EDI PO number concatinate with first 3 digits of location */
   {     
     if (strcmp(poType,SMR_STANDALONE_PO_TYPE) == 0)
       sprintf(poNumber,"%d%3s",atoi(orderNo), strndup(orderLocation+1,3));
     else /* SMR_BULK_PO_TYPE */
       sprintf(poNumber,"%d%3s",atoi(orderNo), strndup(orderLocation,3));
   }
   else /* a split order */
   {
     sprintf(poNumber,"%d",atoi(orderNo));
     if (strcmp(poType,SMR_STANDALONE_PO_TYPE) == 0) /* holdback PO -> H1 masterPO, no H3, 'RL' */
     {
       ps_hb_release = 1;
       strcpy(poType, SMR_ALLOC_PO_TYPE);
       masterPONumber[LEN_BULK_ORDER_PO]='\0';
       strncpy(masterPONumber,orderNo,LEN_BULK_ORDER_PO);
       sprintf(masterPONumber,"%d000",atoi(masterPONumber));
     }       
   }     

   strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_00); /* default H1 record PO purpose code to default 0 */
   if (writeH1(ediFilePtr) < OK)
      return(FATAL);
   recSequence++;

   if (processH2(ediFilePtr) < OK)
      return(FATAL);

   if ( ps_hb_release ) /* no H3 rec */
   {
     ps_hb_release = 0;
     strcpy(poType, SMR_STANDALONE_PO_TYPE);
   }
   else 
   {
      /* Write H3 for All POs witht standard message  */
      if (writeH3_All_POs(ediFilePtr) < OK)
         return(FATAL); 
  
     /* Write H3 record with standard message if QC_IND on the order head is Y */
     if (strcmp(orderQCInd,"Y")==0)
     {
       if (writeH3_QCInd(ediFilePtr) < OK)
         return(FATAL);
     } 
   }
   
   #ifdef DEBUG
   printf("poHeaderCommentsInd is %d\n", poHeaderCommentsInd);
   #endif

   /* if new PO and no header comments
      or change PO and header comments different */
   if (poHeaderCommentsInd != -1)
   {
      if (splitwritecomments(ediFilePtr) < OK)
         return(FATAL);
   }

   /* output H4 record for stand alone order;  not needed for bulk order */
   if (strcmp(poType,SMR_STANDALONE_PO_TYPE) == 0)
   {
      /* location is same for stand alone order */
      strcpy(h4StoreNumber, dcStoreNumber);

      /* populate wh name field for h4 record - same on stand alone for ship and mark */
      strcpy(h4WhName, whName);

      /* ship to location */
      strcpy(shipToMarkFor,"ST");
      if (writeH4(ediFilePtr) < OK)
         return(FATAL);
      recSequence++;
   }
   
   recSequence = 0;
   if (processBulkDetail() < OK)
      return(FATAL);

   return(0);
}


/**********************************************************************************/
/* processAlloc() -                                                               */
/* Do all of the steps to process an alloc PO and create the output records       */
/**********************************************************************************/
int processAlloc()
{
   char *function_name = "processAlloc";

   char currentStore[NULL_LOC] = "";

   /* track current item so can increment d1RecSequence correctly */
   char currentItem[NULL_ITEM] = "";

   #ifdef DEBUG
   printf("processAlloc - starting processing of Allocation\n");
   #endif

   int firsttime = 1;
   recSequence = 1;

   /* gets detail for SMR release order type;  uses a view
      v_ord_alloc_extract_dtl_smr that has embedded logic for getting correct
      unit cost and ref item for buyer packs which are exploded to pack item
      detail;  this simplifies query here and allows me to use subquery in
      select fields                                                             */
   EXEC SQL DECLARE cursorAlloc CURSOR FOR
       SELECT distinct v.item,
             v.wh,
             substr(sp.vpn,1,15),                                                                    
             to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,                                
             to_char(v.unit_cost*10000) unit_cost,
             CASE WHEN v.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(v.ref_item,u.item),1,15),15,'0')  
                  ELSE DECODE(u.item_number_type,'SMRBC','               ', LPAD(u.item,15,'0')) 
             END upc,
             v.pack_type,
             substr(dc.diff_desc,1,15) color_desc, 
             substr(ds.diff_desc,1,15) size_desc,
             to_char(im.mfg_rec_retail*10000) mfg_rec_retail
        from v_ord_alloc_extract_dtl_smr v,
--             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             --and sp.primary_supp_ind = 'Y' 
             and sp.supplier = oh.supplier   
             and oh.order_no = v.order_no    
    GROUP BY v.item,v.ref_item, u.item_number_type,u.item, v.wh, v.to_loc, 
--             substr(st.store_name,1,25), st.default_wh,
--             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N'), 
             sp.vpn,
             to_char(il.unit_retail*10000), to_char(v.unit_cost*10000),
             nvl(v.ref_item,u.item), v.pack_type, substr(dc.diff_desc,1,15),
             substr(ds.diff_desc,1,15), to_char(im.mfg_rec_retail*10000),il.unit_retail 
      HAVING sum(v.qty_allocated) > 0  
    ORDER BY 1; /* item -
                      needed to create new PO 850 trans for each to loc and
                      to reset d1RecSequence correctly for each item on order */

   EXEC SQL DECLARE cursorAllocSt CURSOR FOR
       SELECT v.to_loc,
             substr(st.store_name,1,25),
             st.default_wh,
             to_char(v.qty_allocated),
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N') newstore
        from v_ord_alloc_extract_dtl_smr v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
             and im.item = :allocRec.allocItem
             and v.to_loc = st.store
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier   
             and oh.order_no = v.order_no    
             and v.qty_allocated > 0  
    ORDER BY 1; /* order by to_loc -
                      needed to create new PO 850 trans for each to loc and
                      to reset d1RecSequence correctly for each item on order */
      
      
    EXEC SQL DECLARE cursorAllocForNewLoc CURSOR FOR
        SELECT distinct v.item,
             v.wh,
             substr(sp.vpn,1,15),                                                                    
             to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,                               
             to_char(v.unit_cost*10000) unit_cost,
             CASE WHEN v.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(v.ref_item,u.item),1,15),15,'0')  
                  ELSE DECODE(u.item_number_type,'SMRBC','               ', LPAD(u.item,15,'0')) 
             END upc,
             v.pack_type,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(im.mfg_rec_retail*10000) mfg_rec_retail 
        from v_ord_alloc_extract_dtl_smr v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
             and v.to_loc = st.store
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier
             and oh.order_no = v.order_no
    GROUP BY v.item, v.ref_item,u.item_number_type,u.item, v.wh, v.to_loc, substr(st.store_name,1,25), st.default_wh,
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N'), sp.vpn,
             to_char(il.unit_retail*10000), to_char(v.unit_cost*10000),
             nvl(v.ref_item,u.item), v.pack_type, substr(dc.diff_desc,1,15),
             substr(ds.diff_desc,1,15), to_char(im.mfg_rec_retail*10000),il.unit_retail                       
      HAVING sum(v.qty_allocated) > 0 
 INTERSECT 
  /* ADD DETAILS FOR LOCATION TO AN ALLOCATION */
   SELECT distinct v.item,
             v.wh,
             substr(sp.vpn,1,15),                                                                   
             to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,                             
             to_char(v.unit_cost*10000) unit_cost,
             CASE WHEN v.ref_item is not NULL 
                     THEN LPAD(SUBSTR(NVL(v.ref_item,u.item),1,15),15,'0')  
                     ELSE DECODE (u.item_number_type,'SMRBC','               ', LPAD(u.item,15,'0')) 
             END upc,
             v.pack_type,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(im.mfg_rec_retail*10000) mfg_rec_retail 
        from v_ord_alloc_extract_dtl_smr v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
      where  v.order_no = TO_NUMBER(:orderNo)
             and v.to_loc = st.store
             and v.to_loc not in ( select distinct alc_to_loc from smr_edi_ord_extract_hist where order_no=v.order_no)
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier   
             and oh.order_no = v.order_no    
      GROUP BY v.item, v.ref_item,u.item_number_type,u.item, v.wh, v.to_loc, substr(st.store_name,1,25), st.default_wh,
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N'), substr(sp.vpn,1,15),
             to_char(il.unit_retail*10000), to_char(v.unit_cost*10000),
             nvl(v.ref_item,u.item), v.pack_type, substr(dc.diff_desc,1,15),
             substr(ds.diff_desc,1,15), to_char(im.mfg_rec_retail*10000),il.unit_retail                        
     HAVING sum(v.qty_allocated) > 0  
      ORDER BY 1;

   /* did a seperate query to pull total allocation quantity for H1 rec  */
   EXEC SQL DECLARE cursorAllocPOTotal CURSOR FOR
      SELECT sum(qtyalloc)
        FROM (SELECT ad.qty_allocated*p.pack_qty qtyalloc
                FROM alloc_header ah,
                     alloc_detail ad,
                     item_master i,
                     item_master i2,
                     packitem p
               WHERE ah.order_no = TO_NUMBER(:orderNo)
                     AND ah.alloc_no = ad.alloc_no
--                     AND ad.to_loc = TO_NUMBER(:allocRec.allocStore)
                     AND ah.item = i.item
                     AND i.pack_ind = 'Y'
                     AND i.pack_type = 'B'
                     AND i.item = p.pack_no
                     AND p.item = i2.item
              UNION ALL
              SELECT ad.qty_allocated qtyalloc
                FROM alloc_header ah,
                     alloc_detail ad,
                     item_master i
               WHERE ah.order_no = TO_NUMBER(:orderNo)
                     AND ah.item = i.item
                     AND ah.alloc_no = ad.alloc_no
--                     AND ad.to_loc = TO_NUMBER(:allocRec.allocStore)
                     AND (i.pack_ind = 'N' or (i.pack_ind = 'Y' and i.pack_type = 'V')));

   #ifdef DEBUG
   printf("processAlloc - cursor open next\n");
   #endif


   EXEC SQL OPEN cursorAlloc;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorAlloc");
      strcpy(table, "alloc_header,alloc_detail,store");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   EXEC SQL OPEN cursorAllocForNewLoc;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorAllocForNewLoc");
      strcpy(table, "alloc_header,alloc_detail,store");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorAlloc next\n");
   printf("  order number is <%s>\n", orderNo);
   printf("  supplier is <%s>\n", supplier);
   #endif

   /* populate master po number - RMS order number for full alloc PO */
   masterPONumber[LEN_BULK_ORDER_PO]='\0';
   strncpy(masterPONumber,orderNo,LEN_BULK_ORDER_PO);
   sprintf(masterPONumber,"%d000",atoi(masterPONumber));

   #ifdef DEBUG
   printf("masterPONumber   is <%s> NewLoc is <%s>\n", masterPONumber, NewLoc);
   #endif

   /* Reset item sequence number for each PO */
   d1RecSequence=0;

   while (1)
   {
      #ifdef DEBUG
      printf("NewLoc is <%s>\n", NewLoc);
      #endif

      if (NewLoc == 0)
      {
          #ifdef DEBUG
          printf("NewLoc ==0? is <%s>\n", NewLoc);
          #endif
          
          EXEC SQL FETCH cursorAlloc INTO :allocRec.allocItem,
                                      :allocRec.allocWh,
                                      :allocRec.supVPN:allocRec.supVPNInd,
                                      :allocRec.itemUnitRetail,
                                      :allocRec.itemUnitCost,
                                      :allocRec.itemUPC:allocRec.itemUPCInd,
                                      :allocRec.itemPackType:allocRec.itemPackTypeInd,
                                      :allocRec.itemColorDesc:allocRec.itemColorDescInd,
                                      :allocRec.itemSizeDesc:allocRec.itemSizeDescInd,
                                      :allocRec.itemMfgRecRetail:itemMfgRecRetailInd;
          if SQL_ERROR_FOUND
          {
             strcpy(err_data, "CURSOR FETCH: cursor=cursorAlloc");
             strcpy(table, "alloc_header,alloc_detail,store");
             WRITE_ERROR(SQLCODE,function_name,table,err_data);
             return(FATAL);
          }

          if NO_DATA_FOUND break;

      }
      else
      {

          #ifdef DEBUG
          printf("fetching cursorAllocForNewLoc\n");
          #endif

          EXEC SQL FETCH cursorAllocForNewLoc INTO :allocRec.allocItem,
                                      :allocRec.allocWh,
                                      :allocRec.supVPN:allocRec.supVPNInd,
                                      :allocRec.itemUnitRetail,
                                      :allocRec.itemUnitCost,
                                      :allocRec.itemUPC:allocRec.itemUPCInd,
                                      :allocRec.itemPackType:allocRec.itemPackTypeInd,
                                      :allocRec.itemColorDesc:allocRec.itemColorDescInd,
                                      :allocRec.itemSizeDesc:allocRec.itemSizeDescInd,
                                      :allocRec.itemMfgRecRetail:itemMfgRecRetailInd;

          if SQL_ERROR_FOUND
          {
             strcpy(err_data, "CURSOR FETCH: cursor=cursorAllocForNewLoc");
             strcpy(table, "alloc_header,alloc_detail,store");
             WRITE_ERROR(SQLCODE,function_name,table,err_data);
             return(FATAL);
          }
          if NO_DATA_FOUND break;
          
          /* use allocation store default warehouse for dc store number and ship to wh */
          strncpy(dcStoreNumber,allocRec.allocWh,3);

          #ifdef DEBUG
           printf("the dcStoreNumber is <%s>\n", dcStoreNumber);
          #endif

          if (strlen(orderNo) <= LEN_BULK_ORDER_PO) 
          {
             /* create SMR EDI PO number */
             sprintf(poNumber,"%d%03d",atoi(orderNo), atoi(allocRec.allocStore));
          }      
          else
            sprintf(poNumber,"%d",atoi(orderNo));

          #ifdef DEBUG
          printf("poNumber is <%s>\n", poNumber);
          #endif


      /* for H2 record */
      if (strcmp(allocRec.newStore,"Y") == 0)  /* <- moved to d3 rec */
         strcpy(newStoreRushOrder,"OHNS");
      else
         strcpy(newStoreRushOrder,"");

      /* default H1 record PO purpose code to 0 */
      strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_00);

      /* populate H1 record PO total quantity */
      EXEC SQL OPEN cursorAllocPOTotal;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorAllocPOTotal");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorAllocPOTotal INTO :totalQtyAlloc;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorAllocPOTotal");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorAllocPOTotal;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorAllocPOTotal, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      strcpy(orderTotalQty, totalQtyAlloc);

      recSequence = 1;
      d1RecSequence=0;
      
      if ( firsttime )
      {         
         if (writeH1(ediFilePtr) < OK) /* write header records */
            return(FATAL);

         recSequence++;
         if (processH2(ediFilePtr) < OK)
            return(FATAL);

         if (poHeaderCommentsInd != -1) /* only write H3 record if comments exist */
         {
            if (splitwritecomments(ediFilePtr) < OK)
               return(FATAL);
         }         
         strcpy(h4StoreNumber, dcStoreNumber); /* ship to location */         
         strcpy(h4WhName, whName); /* populate wh name field for h4 record */
         strcpy(shipToMarkFor,"ST");

         if (writeH4(ediFilePtr) < OK)
            return(FATAL);
         recSequence = 1;
      } 
      firsttime = 0;      
      strcpy(item, allocRec.allocItem); /* populate item field for writeD1 rec */      

      if (strcmp(currentItem, item))
      {
         strcpy(currentItem, item);
         d1RecSequence=1;
      }
      else
         d1RecSequence++;

      if (allocRec.supVPNInd == -1)                   /* vpn */
         strcpy(itemSupVPN,"               ");        /* 15 spaces */
      else
         strcpy(itemSupVPN,allocRec.supVPN);

      strcpy(orderUnitCost,allocRec.itemUnitCost);
      strcpy(orderUnitRetail,allocRec.itemUnitRetail);
      strcpy(itemMfgRecRetail,allocRec.itemMfgRecRetail);

      #ifdef DEBUG
         printf("processAlloc - before order no <%s> store <%s> item <%s> upc ind <%d> upc <%s>\n",
         orderNo, allocRec.allocStore, item, allocRec.itemUPCInd, allocRec.itemUPC);
      #endif
      
      if (allocRec.itemUPCInd == -1)                    /* upc */
         strcpy(allocRec.itemUPC,"               ");    /* 15 spaces */
      else
         strcpy(upc, allocRec.itemUPC);

      #ifdef DEBUG
         printf("processAlloc - before order no <%s> store <%s> item <%s> upc ind <%d> upc <%s>\n",
         orderNo, allocRec.allocStore, item, allocRec.itemUPCInd, allocRec.itemUPC);
      #endif

      if (allocRec.itemColorDescInd == -1)             /* color and size desc */
         strcpy(itemColorDesc,"               ");      /* 15 spaces */
      else
         strcpy(itemColorDesc,allocRec.itemColorDesc);

      if (allocRec.itemSizeDescInd == -1)
         strcpy(itemSizeDesc,"               ");       /* 15 spaces */
      else
         strcpy(itemSizeDesc,allocRec.itemSizeDesc);

      /* write po vendor pack records */
      if (allocRec.itemPackTypeInd != -1 && !strcmp(allocRec.itemPackType,"V"))
      {
         if (writePOVNDP(ediFilePtr) < OK)
            return(FATAL);         
      }
      else
      {
         if (writeD1(ediFilePtr) < OK)
            return(FATAL);

         d1RecSequence++;

         if (writeD2(ediFilePtr) < OK)
            return(FATAL);

         if (writeD3(ediFilePtr) < OK)
            return(FATAL);
      }
      d1RecSequence++;

      /* log release alloc version information for this PO extracted */
      if (insertPOAllocRevInfo() < OK)
         return(FATAL);

    } /* new loc */
  } /* while */

   return(OK);
}

/**********************************************************************************/
/* processDDAlloc() -                                                             */
/* Do all of the steps to process a alloc for DD PO and create the output records */
/**********************************************************************************/
int processDDAlloc()
{
   char *function_name = "processDDAlloc";

   char currentStore[NULL_LOC] = "";

   /* track current item so can increment d1RecSequence correctly */
   char currentItem[NULL_ITEM] = "";

   #ifdef DEBUG
   printf("processDDAlloc - starting processing of DD Allocation\n");
   #endif

   recSequence = 1;

   /* gets detail for SMR release order type;  uses a view
      v_ord_alloc_extract_dtl_smr that has embedded logic for getting correct
      unit cost and ref item for buyer packs which are exploded to pack item
      detail;  this simplifies query here and allows me to use subquery in
      select fields                                                             */
   EXEC SQL DECLARE cursorDDAlloc CURSOR FOR
       SELECT v.item,
             v.wh,
             v.to_loc,
             substr(st.store_name,1,25),
             st.default_wh,
             to_char(sum(v.qty_allocated)),
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N') newstore,
             substr(sp.vpn,1,15),                                                                    
             to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,                                
             to_char(v.unit_cost*10000) unit_cost,
             CASE WHEN v.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(v.ref_item,u.item),1,15),15,'0')  
                  ELSE DECODE(u.item_number_type,'SMRBC','               ', LPAD(u.item,15,'0')) 
             END upc,
             v.pack_type,
             substr(dc.diff_desc,1,15) color_desc, 
             substr(ds.diff_desc,1,15) size_desc,
             to_char(im.mfg_rec_retail*10000) mfg_rec_retail
        from v_ord_alloc_extract_dtl_smr v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
             and v.to_loc = st.store
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier
             and oh.order_no = v.order_no
    GROUP BY v.item,v.ref_item, u.item_number_type,u.item, v.wh, v.to_loc, substr(st.store_name,1,25), st.default_wh,
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N'), sp.vpn,
             to_char(il.unit_retail*10000), to_char(v.unit_cost*10000),
             nvl(v.ref_item,u.item), v.pack_type, substr(dc.diff_desc,1,15),
             substr(ds.diff_desc,1,15), to_char(im.mfg_rec_retail*10000),il.unit_retail
      HAVING sum(v.qty_allocated) > 0  
    ORDER BY 3, 1; /* order by to location and item -
                      needed to create new PO 850 trans for each to loc and
                      to reset d1RecSequence correctly for each item on order */

    EXEC SQL DECLARE cursorDDAllocForNewLoc CURSOR FOR
        SELECT v.item,
             v.wh,
             v.to_loc,
             substr(st.store_name,1,25),
             st.default_wh,
             to_char(sum(v.qty_allocated)),
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N') newstore,
             substr(sp.vpn,1,15),                                                                    
             to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,                               
             to_char(v.unit_cost*10000) unit_cost,
             CASE WHEN v.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(v.ref_item,u.item),1,15),15,'0')  
                  ELSE DECODE(u.item_number_type,'SMRBC','               ', LPAD(u.item,15,'0')) 
             END upc,
             v.pack_type,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(im.mfg_rec_retail*10000) mfg_rec_retail
        from v_ord_alloc_extract_dtl_smr v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
             and v.to_loc = st.store
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier
             and oh.order_no = v.order_no
    GROUP BY v.item, v.ref_item,u.item_number_type,u.item, v.wh, v.to_loc, substr(st.store_name,1,25), st.default_wh,
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N'), sp.vpn,
             to_char(il.unit_retail*10000), to_char(v.unit_cost*10000),
             nvl(v.ref_item,u.item), v.pack_type, substr(dc.diff_desc,1,15),
             substr(ds.diff_desc,1,15), to_char(im.mfg_rec_retail*10000),il.unit_retail                       
      HAVING sum(v.qty_allocated) > 0  
 INTERSECT
  /* ADD DETAILS FOR LOCATION TO AN ALLOCATION */
   SELECT v.item,
             v.wh,
             v.to_loc,
             substr(st.store_name,1,25),
             st.default_wh,
             to_char(sum(v.qty_allocated)),
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N') newstore,
             substr(sp.vpn,1,15),                                                                   
             to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,                             
             to_char(v.unit_cost*10000) unit_cost,
             CASE WHEN v.ref_item is not NULL 
                     THEN LPAD(SUBSTR(NVL(v.ref_item,u.item),1,15),15,'0')  
                     ELSE DECODE (u.item_number_type,'SMRBC','               ', LPAD(u.item,15,'0')) 
             END upc,
             v.pack_type,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(im.mfg_rec_retail*10000) mfg_rec_retail
        from v_ord_alloc_extract_dtl_smr v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
      where  v.order_no = TO_NUMBER(:orderNo)
             and v.to_loc = st.store
             and V.TO_LOC not in (  select  distinct alc_to_loc from   smr_edi_ord_extract_hist where order_no=v.order_no)
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier
             and oh.order_no = v.order_no
      GROUP BY v.item, v.ref_item,u.item_number_type,u.item, v.wh, v.to_loc, substr(st.store_name,1,25), st.default_wh,
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N'), substr(sp.vpn,1,15),
             to_char(il.unit_retail*10000), to_char(v.unit_cost*10000),
             nvl(v.ref_item,u.item), v.pack_type, substr(dc.diff_desc,1,15),
             substr(ds.diff_desc,1,15), to_char(im.mfg_rec_retail*10000),il.unit_retail                        
     HAVING sum(v.qty_allocated) > 0  
      ORDER BY 3, 1;
      
   /* did a seperate query to pull total allocation quantity for H1 rec  */
   EXEC SQL DECLARE cursorDDAllocPOTotal CURSOR FOR
      SELECT sum(qtyalloc)
        FROM (SELECT ad.qty_allocated*p.pack_qty qtyalloc
                FROM alloc_header ah,
                     alloc_detail ad,
                     item_master i,
                     item_master i2,
                     packitem p
               WHERE ah.order_no = TO_NUMBER(:orderNo)
                     AND ah.alloc_no = ad.alloc_no
                     AND ad.to_loc = TO_NUMBER(:allocRec.allocStore)
                     AND ah.item = i.item
                     AND i.pack_ind = 'Y'
                     AND i.pack_type = 'B'
                     AND i.item = p.pack_no
                     AND p.item = i2.item
              UNION ALL
              SELECT ad.qty_allocated qtyalloc
                FROM alloc_header ah,
                     alloc_detail ad,
                     item_master i
               WHERE ah.order_no = TO_NUMBER(:orderNo)
                     AND ah.item = i.item
                     AND ah.alloc_no = ad.alloc_no
                     AND ad.to_loc = TO_NUMBER(:allocRec.allocStore)
                     AND (i.pack_ind = 'N' or (i.pack_ind = 'Y' and i.pack_type = 'V')));

   #ifdef DEBUG
   printf("processDDAlloc - cursor open next\n");
   #endif


   EXEC SQL OPEN cursorDDAlloc;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDDAlloc");
      strcpy(table, "alloc_header,alloc_detail,store");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   EXEC SQL OPEN cursorDDAllocForNewLoc;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDDAllocForNewLoc");
      strcpy(table, "alloc_header,alloc_detail,store");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorDDAlloc next\n");
   printf("  order number is <%s>\n", orderNo);
   printf("  supplier is <%s>\n", supplier);
   #endif

   /* populate master po number - RMS order number for full alloc PO */
   sprintf(masterPONumber,"%06d000",atoi(orderNo));

   #ifdef DEBUG
   printf("masterPONumber   is <%s>\n", masterPONumber);
   #endif

   /* Reset item sequence number for each PO */
   d1RecSequence=0;



   while (1)
   {
      if (NewLoc == 0)
      {
   #ifdef DEBUG
   printf("fetching cursorDDAlloc\n");
   #endif

      EXEC SQL FETCH cursorDDAlloc INTO :allocRec.allocItem,
                                      :allocRec.allocWh,
                                      :allocRec.allocStore,
                                      :allocRec.storeName,
                                      :allocRec.storeDefaultWh:storeDefaultWhInd,
                                      :allocRec.qtyAlloc,
                                      :allocRec.newStore,
                                      :allocRec.supVPN:allocRec.supVPNInd,
                                      :allocRec.itemUnitRetail,
                                      :allocRec.itemUnitCost,
                                      :allocRec.itemUPC:allocRec.itemUPCInd,
                                      :allocRec.itemPackType:allocRec.itemPackTypeInd,
                                      :allocRec.itemColorDesc:allocRec.itemColorDescInd,
                                      :allocRec.itemSizeDesc:allocRec.itemSizeDescInd,
                                      :allocRec.itemMfgRecRetail:itemMfgRecRetailInd;         
                                      
                                      
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDDAlloc");
         strcpy(table, "alloc_header,alloc_detail,store");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

   #ifdef DEBUG
   printf("fetched cursorDDAllocForNewLoc\n");
   #endif

      }
      else
      {

   #ifdef DEBUG
   printf("fetching cursorDDAllocForNewLoc\n");
   #endif

      EXEC SQL FETCH cursorDDAllocForNewLoc INTO :allocRec.allocItem,
                                      :allocRec.allocWh,
                                      :allocRec.allocStore,
                                      :allocRec.storeName,
                                      :allocRec.storeDefaultWh:storeDefaultWhInd,
                                      :allocRec.qtyAlloc,
                                      :allocRec.newStore,
                                      :allocRec.supVPN:allocRec.supVPNInd,
                                      :allocRec.itemUnitRetail,
                                      :allocRec.itemUnitCost,
                                      :allocRec.itemUPC:allocRec.itemUPCInd,
                                      :allocRec.itemPackType:allocRec.itemPackTypeInd,
                                      :allocRec.itemColorDesc:allocRec.itemColorDescInd,
                                      :allocRec.itemSizeDesc:allocRec.itemSizeDescInd,
                                      :allocRec.itemMfgRecRetail:itemMfgRecRetailInd;         

      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDDAllocForNewLoc");
         strcpy(table, "alloc_header,alloc_detail,store");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
   #ifdef DEBUG
   printf("fetched cursorDDAllocForNewLoc\n");
   #endif
      if NO_DATA_FOUND break;

      }

   #ifdef DEBUG
   printf("orderLocation\n");
   #endif

      if (strcmp(orderLocation, ps_dd_wh) == 0)
      {
         #ifdef DEBUG
         printf("ps_dd_wh=%s\n, ps_dd_wh");
         #endif
         
         /* for release order where loc ps_dd_wh for direct to store order use
            allocation store                                                  */
         #ifdef DEBUG
         printf("strcpy(dcStoreNumber,allocRec.allocStore)\n");
         #endif

         strcpy(dcStoreNumber,allocRec.allocStore);
      }

   #ifdef DEBUG
   printf("create SMR EDI PO number\n");
   #endif
      /* create SMR EDI PO number */
      sprintf(poNumber,"%d%03d",atoi(orderNo), atoi(allocRec.allocStore));

   #ifdef DEBUG
   printf("for H2 record \n");
   #endif
      /* for H2 record */
      if (strcmp(allocRec.newStore,"Y") == 0)
         strcpy(newStoreRushOrder,"OHNS");
      else
         strcpy(newStoreRushOrder,"");

   #ifdef DEBUG
   printf("default H1 record PO purpose code\n");
   #endif
      /* default H1 record PO purpose code to default 0 */
      strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_00);

      /* populate H1 record PO total quantity */
      EXEC SQL OPEN cursorDDAllocPOTotal;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorDDAllocPOTotal");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

   #ifdef DEBUG
   printf("FETCH cursorDDAllocPOTotal\n");
   #endif
      EXEC SQL FETCH cursorDDAllocPOTotal INTO :totalQtyAlloc;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDDAllocPOTotal");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorDDAllocPOTotal;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursoDDrAllocPOTotal, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      strcpy(orderTotalQty, totalQtyAlloc);

   #ifdef DEBUG
   printf("orderTotalQty=%s\n", orderTotalQty);
   #endif
      

      /* for H4 record - set store and ship to mark for values */

      /* check if same store - could be multiple items for store/PO */
      /* only want header recs once for each PO - store/PO combination */
      if (strcmp(currentStore, allocRec.allocStore) != 0)
      {
         /* since treat each new po/store combination as new PO will need to reset
            sequence                                                                 */
         recSequence = 1;
         d1RecSequence=0;

   #ifdef DEBUG
   printf("write header records\n");
   #endif

         /* write header records */
         if (writeH1(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

   #ifdef DEBUG
   printf("processH2(ediFilePtr)\n");
   #endif
         if (processH2(ediFilePtr) < OK)
            return(FATAL);

         /* only write H3 record if comments exist */
         if (poHeaderCommentsInd != -1)                                                  
         {
            if (splitwritecomments(ediFilePtr) < OK)
               return(FATAL);
         }

         /* ship to location */
         strcpy(h4StoreNumber, dcStoreNumber);
         /* populate wh name field for h4 record */
         strcpy(h4WhName, whName);
         strcpy(shipToMarkFor,"ST");

   #ifdef DEBUG
   printf("writeH4(ediFilePtr)\n");
   #endif


         if (writeH4(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

/***
         /* mark for location - store 
         strcpy(h4StoreNumber, allocRec.allocStore);
         /* populate wh name field for h4 record 
         strcpy(h4WhName, allocRec.storeName);
         strcpy(shipToMarkFor,"Z7");
         if (writeH4(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;
***/
         strcpy(currentStore, allocRec.allocStore);

      }

      recSequence = 1;

      /* populate item field for writeD1 rec */
      strcpy(item, allocRec.allocItem);

      /* check if need to increment d1RecSequence for new item -
                                                  increment if does not match */
      if (strcmp(currentItem, item))
      {
         /* reset to 1 for each new item */
         strcpy(currentItem, item);
         d1RecSequence=1;
      }
      else
         d1RecSequence++;

      /* vpn */
      if (allocRec.supVPNInd == -1)
         strcpy(itemSupVPN,"               ");        /* 15 spaces */
      else
         strcpy(itemSupVPN,allocRec.supVPN);

      /* qty alloc/ordered, unit cost, unit retail */
      strcpy(qtyOrdered,allocRec.qtyAlloc);
      strcpy(orderUnitCost,allocRec.itemUnitCost);
      strcpy(orderUnitRetail,allocRec.itemUnitRetail);
      strcpy(itemMfgRecRetail,allocRec.itemMfgRecRetail);

      #ifdef DEBUG
      printf("processAlloc - before order no <%s> store <%s> item <%s> upc ind <%d> upc <%s>\n",
              orderNo, allocRec.allocStore, item, allocRec.itemUPCInd, allocRec.itemUPC);
      #endif
      /* upc */
      if (allocRec.itemUPCInd == -1)
         strcpy(allocRec.itemUPC,"               ");    /* 15 spaces */
      else
         strcpy(upc, allocRec.itemUPC);
      #ifdef DEBUG
      printf("processAlloc - before order no <%s> store <%s> item <%s> upc ind <%d> upc <%s>\n",
              orderNo, allocRec.allocStore, item, allocRec.itemUPCInd, allocRec.itemUPC);
      #endif

      /* color and size desc */
      if (allocRec.itemColorDescInd == -1)
         strcpy(itemColorDesc,"               ");      /* 15 spaces */
      else
         strcpy(itemColorDesc,allocRec.itemColorDesc);

      if (allocRec.itemSizeDescInd == -1)
         strcpy(itemSizeDesc,"               ");       /* 15 spaces */
      else
         strcpy(itemSizeDesc,allocRec.itemSizeDesc);

   #ifdef DEBUG
   printf("if pack type is not null and pack type\n");
   #endif
      /* if pack type is not null and pack type is vendor write po vendor pack records */
      if (allocRec.itemPackTypeInd != -1 && !strcmp(allocRec.itemPackType,"V"))
      {
   #ifdef DEBUG
   printf("writePOVNDP(ediFilePtr)\n");
   #endif
         if (writePOVNDP(ediFilePtr) < OK)
            return(FATAL);         
      }
      else
      {
   #ifdef DEBUG
   printf("writeD1(ediFilePtr)\n");
   #endif
         if (writeD1(ediFilePtr) < OK)
            return(FATAL);

      d1RecSequence++;

   #ifdef DEBUG
   printf("writeD2(ediFilePtr)\n");
   #endif
         if (writeD2(ediFilePtr) < OK)
            return(FATAL);

   #ifdef DEBUG
   printf("writeD3(ediFilePtr)\n");
   #endif
         if (writeD3(ediFilePtr) < OK)
            return(FATAL);
      }
      d1RecSequence++;

   #ifdef DEBUG
   printf("insertPOAllocRevInfo()\n");
   #endif

      /* log release alloc version information for this PO extracted */
      if (insertPOAllocRevInfo() < OK)
         return(FATAL);

   }

   return(OK);
}

/*------------------------------------------------------*\
* function validatePO()                                 *
\*------------------------------------------------------*/
int validatePO(void)
{
   char *function_name = "validatePO";

   /* validate location exists on PO */
   if (orderLocationInd == -1)
   {
      sprintf(err_data,"RMS PO location is null on PO header record for PO number <%s>",
              orderNo);
      WRITE_ERROR(RET_FUNCTION_ERR, function_name, "", err_data);
      return(NON_FATAL);
   }

   if (strlen(orderLocation) != 4)
   {
      sprintf(err_data,"RMS PO location appears to be a physical warehouse for PO number <%s>",
              orderNo);
      WRITE_ERROR(RET_FUNCTION_ERR, function_name, "", err_data);
      return(NON_FATAL);
   }

   return(OK);
}

/*-----------------------------------------------------------------------------------*\
* function insertPOAllocRevInfo()                                                    *
* Need to do custom revision logging of PO extract info for extract at PO/store/item *
\*-----------------------------------------------------------------------------------*/
int insertPOAllocRevInfo(void)
{
   char *function_name = "insertPOAllocRevInfo";

   #ifdef DEBUG
   printf("insertPOAllocRevInfo - insert order no <%s> store <%s> item <%s> rev <%s>\n",
              orderNo, allocRec.allocStore, item, maxRevNo);
   #endif

     /* set rev_no = last_extract_rev_no if sending new location for allocation */
     /*If resending whole order, use max revision*/
     EXEC SQL INSERT INTO smr_edi_ord_extract_hist
                         (order_no,
                          alc_to_loc,
                          item,
                          rev_no,
                          wh,
                          loc_type,
                          qty_allocated,
                          last_extract_date)
                   SELECT :orderNo,
                          :allocRec.allocStore,
                          :item,
                          max_rev.rev_no,
                          :allocRec.allocWh,
                          'W',
                          :qtyOrdered,
                          sysdate
                     FROM (SELECT NVL(max(rev_no),0) rev_no
                             FROM ordhead_rev ohr
                            WHERE ohr.order_no = TO_NUMBER(:orderNo)
                              AND ohr.origin_type = 'V') max_rev
                    WHERE NOT EXISTS (SELECT 1
                                        FROM smr_edi_ord_extract_hist
                                       WHERE order_no = :orderNo
                                         AND rev_no = max_rev.rev_no
                                         AND item = :item
                                         AND alc_to_loc = :allocRec.allocStore )
                      AND ( :orderNo IN (SELECT order_no FROM smr_850_resend)
                            or
                            :orderNo IN (SELECT order_no FROM smr_ord_extract WHERE order_no = TO_NUMBER(:orderNo) AND extract_850_rel_ind = 'N'));

    /*If sending just some locations, use last sent revision*/
    EXEC SQL INSERT INTO smr_edi_ord_extract_hist
                         (order_no,
                          alc_to_loc,
                          item,
                          rev_no,
                          wh,
                          loc_type,
                          qty_allocated,
                          last_extract_date)
                   SELECT :orderNo,
                          :allocRec.allocStore,
                          :item,
                          last_rev.rev_no,
                          :allocRec.allocWh,
                          'W',
                          :qtyOrdered,
                          sysdate
                     FROM (SELECT last_extract_rev_no rev_no
                             FROM smr_ord_extract
                            WHERE order_no = TO_NUMBER(:orderNo)) last_rev
                    WHERE NOT EXISTS (SELECT 1
                                        FROM smr_edi_ord_extract_hist
                                       WHERE order_no = :orderNo
                                         AND rev_no = last_rev.rev_no
                                         AND item = :item
                                         AND alc_to_loc = :allocRec.allocStore)
                      AND :orderNo NOT IN (SELECT order_no FROM smr_850_resend)
                      AND :orderNo NOT IN (SELECT order_no FROM smr_ord_extract WHERE order_no = TO_NUMBER(:orderNo) AND extract_850_rel_ind = 'N');   

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "INSERT: for order no <%s> store <%s> item <%s> rev <%s>",
              orderNo, allocRec.allocStore, item, maxRevNo);
      strcpy(table, "smr_edi_ord_extract_hist");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   return(OK);
}

/*------------------------------------------------------*\
* function writeH1()                                 *
\*------------------------------------------------------*/
int writeH1(FILE *outRtkFilePtr)
{
   char *function_name = "writeH1";

   #ifdef DEBUG
   printf("writeH1 - main write next\n");
   #endif

   /* if no promo start date initialize promo start date to all zeroes */
   if (promoStartDateInd == -1)
   {
      strcpy(promoQualifier,"");
      strcpy(promoStartDate,"00000000");
   }
   else
      strcpy(promoQualifier,"015");

   strcpy(termsOfPurch1,SMR_TERMS1);
   strcpy(termsOfPurch2,SMR_TERMS2);

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,           		
   				  rec_type2,           		
   				  rec_seq,             		
   				  supplier_nmbr,       		
   				  company_id,          		
   				  po_type,             		
   				  po_nmbr,             		
   				  po_purpose_code,     		
   				  dc_store_nmbr,       		
   				  master_po_nmbr,             	
   				  vendor_nmbr_ref,     		
   				  vendor_nmbr,         		
   				  dept_nmbr_ref,       		
   				  dept_nmbr,           		
   				  buyer_nmbr_ref,      		
   				  buyer_fnctn_code,    		
   				  buyer_nmbr,          		
   				  buyer_contact_name,  		
   				  buyer_comm_qualfr,   		
   				  buyer_phone_nmbr,    		
   				  dc_function_code,    		
   				  dc_contact_name,     		
   				  dc_comm_qualifer,    		
   				  dc_phone_nmbr,       		
   				  cash_req_code1,       	
   				  cash_req_code2,       	
   				  delivery_instruct,   		
   				  special_freight_desc,		
   				  discount_desc,       		
   				  total_qty_po,    		
   				  po_approve_date,             	
   				  po_requested_ship,   		
   				  po_ship_date,        		
   				  po_rcv_date,         		
   				  po_cancel_after,     		
   				  po_cancel_date,      		
   				  po_promo,            		
   				  po_promo_date,       		
   				  terms_id_qualifer,   		
   				  terms_of_purch1,   		
   				  terms_of_purch2,
   				  create_datetime) values ( 
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.nextval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH1,				
   				  'H',				
   				  :recSequence,				
   				  to_number(:supplier),				/*atoi*/
   				  1,				
   				  :poType,				
   				  to_number(:poNumber),				/*atoi*/
   				  :poPurposeCode,				
   				  to_number(:dcStoreNumber),			/*atoi*/
   				  :masterPONumber,				
   				  'IA',				
   				  to_number(:supplier),				/*atoi*/
   				  'DP',				
   				  to_number(:orderDept),			/*atoi*/	
   				  'BY',
   				  'BD',
   				  to_number(:buyer),				/*atoi*/
   				  :buyerName,
   				  'TE',
   				  :buyerPhone,
   				  'DC',
   				  '',
   				  'TE',
   				  '',
   				  'NS',
   				  'SC',
   				  '',
   				  '',
   				  :termsCode,
   				  to_number(:orderTotalQty),			/*atoi*/
   				  :originalApproveDate,
   				  '010',
   				  :newNotBeforeDate,
   				  '00000000',
   				  '001',
   				  :newNotAfterDate,
   				  :promoQualifier, /*'015',*/
   				  :promoStartDate,
   				  'ME',
   				  :termsOfPurch1,
   				  :termsOfPurch2,
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));
   
   
   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   EXEC SQL insert into SMR_RMS_INT_QUEUE( INTERFACE_QUEUE_ID,
                                  INTERFACE_ID,
                                  GROUP_ID,
                                  CREATE_DATETIME,
                                  PROCESSED_DATETIME,
                                  STATUS ) values (
                                  RMS13.SMR_RMS_INT_QUEUE_SEQ.nextval,
                                  :ps_interface_id,
                                  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
                                  sysdate ,
                                  null ,
                                  'N' );

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP INT_QUEUE INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   
   if (fprintf(outRtkFilePtr, h1String_850,
                        LEN_SMR_REC_TYPE1,            recTypeDescH1,
                        LEN_SMR_REC_TYPE2,            "H",
                        LEN_SMR_REC_SEQ,              recSequence,
                        LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
                        LEN_SMR_COMPANY_ID,           1,
                        LEN_SMR_PO_TYPE,              poType,
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_PO_PURPOSE_CODE,      poPurposeCode,
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                        LEN_SMR_PO_NMBR,              masterPONumber,
                        LEN_SMR_VENDOR_NMBR_REF,      "IA",
                        LEN_SMR_VENDOR_NMBR,          atoi(supplier),
                        LEN_SMR_DEPT_NMBR_REF,        "DP",
                        LEN_SMR_DEPT_NMBR,            atoi(orderDept),
                        LEN_SMR_BUYER_NMBR_REF,       "BY",
                        LEN_SMR_BUYER_FNCTN_CODE,     "BD",
                        LEN_SMR_BUYER_NMBR,           atoi(buyer),
                        LEN_SMR_BUYER_CONTACT_NAME,   buyerName,
                        LEN_SMR_BUYER_COMM_QUALFR,    "TE",
                        LEN_SMR_BUYER_PHONE_NMBR,     buyerPhone,
                        LEN_SMR_DC_FUNCTION_CODE,     "DC",
                        LEN_SMR_DC_CONTACT_NAME,      "",
                        LEN_SMR_DC_COMM_QUALIFER,     "TE",
                        LEN_SMR_DC_PHONE_NMBR,        "",
                        LEN_SMR_CASH_REQ_CODE,        "NS",
                        LEN_SMR_CASH_REQ_CODE,        "SC",
                        LEN_SMR_DELIVERY_INSTRUCT,    "",
                        LEN_SMR_SPECIAL_FREIGHT_DESC, "",
                        LEN_SMR_DISCOUNT_DESC,        termsCode,
                        LEN_SMR_850_TOTAL_QTY_PO,     atoi(orderTotalQty),
                        LEN_SMR_PO_DATE,              originalApproveDate,
                        LEN_SMR_PO_REQUESTED_SHIP,    "010",
                        LEN_SMR_PO_SHIP_DATE,         newNotBeforeDate,
                        LEN_SMR_PO_RCV_DATE,          "00000000",
                        LEN_SMR_PO_CANCEL_AFTER,      "001",
                        LEN_SMR_PO_CANCEL_DATE,       newNotAfterDate,
                        LEN_SMR_PO_PROMO,             promoQualifier, 
                        LEN_SMR_PO_PROMO_DATE,        promoStartDate,
                        LEN_SMR_TERMS_ID_QUALIFER,    "ME",
                        LEN_SMR_TERMS_OF_PURCHASE,    SMR_TERMS1,
                        LEN_SMR_TERMS_OF_PURCHASE,    SMR_TERMS2) < OK)
      return(FATAL);

    return(0);

}

/*------------------------------------------------------*\
* function processH2() - Write allowance/charge 850       *
*                      h2 header record.  Format of H2  *
*                      different on 850 and 860.        *
\*------------------------------------------------------*/
int processH2(FILE *outRtkFilePtr)
{
   char *function_name = "processH2";

   char vicCode[NULL_SMR_VICS];
   char sacCode[NULL_SMR_NEW_STORE_RUSH];
   char sacDesc[NULL_SMR_SAC_DESC];

   EXEC SQL DECLARE cursorWorkOrders CURSOR FOR
      SELECT DISTINCT 'VI' vics_code, s.sac_code, s.sac_desc
        FROM wo_head wh,
             wo_detail wd,
             smr_sac_codes s
      WHERE wh.wo_id = wd.wo_id
            and wd.wip_code = s.wip_code
            and wh.order_no = TO_NUMBER(:orderNo)
      UNION
      SELECT 'ZZ', s.sac_code, s.sac_desc
        FROM smr_sac_codes s
       WHERE s.sac_code = 'HAY'
             and not exists (select 'Y' from wo_head wh, wo_detail wd
                              where wh.wo_id = wd.wo_id
                                    and wd.wip_code in ('HANGEX','NOHANG','SEED')
                                    and wh.order_no = TO_NUMBER(:orderNo))
      UNION
      SELECT 'TC', s.sac_code, s.sac_desc
        FROM smr_sac_codes s
       WHERE s.sac_code = 'TCY' /* add ticketing service if no TICKEX NOTICK */
             and not exists (select 'Y' from wo_head wh, wo_detail wd
                              where wh.wo_id = wd.wo_id
                                    and wd.wip_code in ('TICKEX','NOTICK')
                                    and wh.order_no = TO_NUMBER(:orderNo));

   #ifdef DEBUG
   printf("%s - main write next\n", function_name);
   #endif

   /* if new store rush order write that record */
   if (strlen(newStoreRushOrder) > 0)
   {
      #ifdef DEBUG
      printf("%s - write H2 rec for new store rush order\n", function_name);
      #endif

      if (writeH2(outRtkFilePtr, "VI", newStoreRushOrder, "New Store Order") < OK)
         return(FATAL);
      recSequence++;
   }

   EXEC SQL OPEN cursorWorkOrders;
   if (SQL_ERROR_FOUND)
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorWorkOrders");
      strcpy(table, "wo_head,wo_detail,smr_sac_codes");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   /* process for work orders that PO has */
   while (1)
   {
      #ifdef DEBUG
      printf("%s - fetch work order info next\n", function_name);
      #endif

      EXEC SQL FETCH cursorWorkOrders INTO :vicCode,
                                           :sacCode,
                                           :sacDesc;

      #ifdef DEBUG
      printf("%s - after fetch work order info\n", function_name);
      #endif

      if (SQL_ERROR_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorWorkOrders");
         strcpy(table, "wo_head,wo_detail");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("%s - write H2 rec for work order sacCode is <%s>\n", function_name, sacCode);
      #endif

      if (writeH2(outRtkFilePtr, vicCode, sacCode, sacDesc) < OK)
         return(FATAL);
      recSequence++;
   }

   return(OK);
}

/*--------------------------------------------------------------------------------*\
*  function get_substr(int ipos, int fpos,char *ptr, char *ptr1)                  *
\*--------------------------------------------------------------------------------*/

int get_substr(int ipos, int fpos,char *ptr, char *ptr1)
{
            long index;
            long aux_index;

            aux_index = 0;
            for (index=ipos;index<=fpos;index++)
            {
            *(ptr1 +aux_index) = *(ptr+index);
                        aux_index++;
            }
            return;
}


/*------------------------------------------------------*\
* function writeH2() - Write allowance/charge 850       *
*                      h2 header record. Format same    *
*                      on 850 and 860.                  *
\*------------------------------------------------------*/
int writeH2(FILE *outRtkFilePtr, char *vicCode, char *sacCode, char *sacDesc)
{
   char *function_name = "writeH2";

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  charge_ind,
      				  vics,
      				  new_store_rush,
      				  sac_desc,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH2,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  'N',
   				  :vicCode,
   				  :sacCode,
   				  :sacDesc,
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H2 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   if (fprintf(outRtkFilePtr, h2String,
               LEN_SMR_REC_TYPE1,            recTypeDescH2,
               LEN_SMR_REC_TYPE2,            "H",
               LEN_SMR_REC_SEQ,              recSequence,
               LEN_SMR_VENDOR_NMBR,          atoi(supplier),
               LEN_SMR_COMPANY_ID,           1,
               LEN_SMR_PO_NMBR,              atoi(poNumber),
               LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
               LEN_SMR_CHARGE_IND,           "N",
               LEN_SMR_VICS,                 vicCode,
               LEN_SMR_NEW_STORE_RUSH,       sacCode,
               LEN_SMR_SAC_DESC,             sacDesc) < OK)
      return(FATAL);
    return(OK);
}


/*------------------------------------------------------*\
* function splitwritecomments()                         *
\*------------------------------------------------------*/
int splitwritecomments(FILE *outRtkFilePtr)
{
    char *function_name = "splitwritecomments";

      poHeaderComments1[0] ='\0';
      poHeaderComments2[0] ='\0';
      poHeaderComments3[0] ='\0';
      poHeaderComments4[0] ='\0';
      poHeaderComments5[0] ='\0';
      poHeaderComments6[0] ='\0';


      if (strlen(poHeaderComments) <= 50 )
      {
         get_substr(0,49,poHeaderComments,poHeaderComments1);

         strcpy(poHeaderComments,poHeaderComments1);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;
      }

      else if (strlen(poHeaderComments) <= 100 )
      {
         get_substr(0,49,poHeaderComments,poHeaderComments1);
         get_substr(50,99,poHeaderComments,poHeaderComments2);

         strcpy(poHeaderComments,poHeaderComments1);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments2);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;
      }

      else if (strlen(poHeaderComments) <= 150 )
      {

         get_substr(0,49,poHeaderComments,poHeaderComments1);
         get_substr(50,99,poHeaderComments,poHeaderComments2);
         get_substr(100,149,poHeaderComments,poHeaderComments3);

         strcpy(poHeaderComments,poHeaderComments1);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments2);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments3);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;
      }

      else if (strlen(poHeaderComments) <= 200 )
      {

         get_substr(0,49,poHeaderComments,poHeaderComments1);
         get_substr(50,99,poHeaderComments,poHeaderComments2);
         get_substr(100,149,poHeaderComments,poHeaderComments3);
         get_substr(150,199,poHeaderComments,poHeaderComments4);

         strcpy(poHeaderComments,poHeaderComments1);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments2);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments3);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments4);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;
      }

      else if (strlen(poHeaderComments) <= 250 )
      {

         get_substr(0,49,poHeaderComments,poHeaderComments1);
         get_substr(50,99,poHeaderComments,poHeaderComments2);
         get_substr(100,149,poHeaderComments,poHeaderComments3);
         get_substr(150,199,poHeaderComments,poHeaderComments4);
         get_substr(200,249,poHeaderComments,poHeaderComments5);

         strcpy(poHeaderComments,poHeaderComments1);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments2);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments3);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments4);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments5);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;
      }

      else if (strlen(poHeaderComments) <= 300 )
      {
         get_substr(0,49,poHeaderComments,poHeaderComments1);
         get_substr(50,99,poHeaderComments,poHeaderComments2);
         get_substr(100,149,poHeaderComments,poHeaderComments3);
         get_substr(150,199,poHeaderComments,poHeaderComments4);
         get_substr(200,249,poHeaderComments,poHeaderComments5);
         get_substr(250,299,poHeaderComments,poHeaderComments6);

         strcpy(poHeaderComments,poHeaderComments1);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments2);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments3);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments4);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments5);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;

         strcpy(poHeaderComments,poHeaderComments6);
         if (writeH3(ediFilePtr) < OK)
            return(FATAL);
         recSequence++;
      }

    return(0);
}


/*------------------------------------------------------*\
* function writeH3()                                 *
\*------------------------------------------------------*/
int writeH3(FILE *outRtkFilePtr)
{
   char *function_name = "writeH3";

   #ifdef DEBUG
   printf("writeH3 - main write next\n");
   #endif

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  desc_type,
      				  split_comments,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH3,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  'F',
   				  :poHeaderComments,
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H3 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   if (fprintf(outRtkFilePtr, h3String,
                        LEN_SMR_REC_TYPE1,            recTypeDescH3,
                        LEN_SMR_REC_TYPE2,            "H",
                        LEN_SMR_REC_SEQ,              recSequence,
                        LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
                        LEN_SMR_COMPANY_ID,           1,
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                        LEN_SMR_DESC_TYPE,            "F",
                        LEN_SMR_SPLIT_COMMENTS,       poHeaderComments) < 0)
      return(FATAL);
    return(0);

}

/*------------------------------------------------------*\
* function writeH3_All_POs()                            *
\*------------------------------------------------------*/
int writeH3_All_POs(FILE *outRtkFilePtr)
{
   char *function_name = "writeH3_All_POs"; 

   #ifdef DEBUG
   printf("writeH3_All_POs - main write next\n");
   #endif

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  desc_type,
      				  split_comments,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH3,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  'F',
   				  'If not shipped complete within the time window, St',
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H3_1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }
   if (fprintf(outRtkFilePtr, h3String,
                        LEN_SMR_REC_TYPE1,            recTypeDescH3,
                        LEN_SMR_REC_TYPE2,             "H",
                        LEN_SMR_REC_SEQ,              recSequence++,
                        LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
                        LEN_SMR_COMPANY_ID,           1,
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                        LEN_SMR_DESC_TYPE,            "F",
                        LEN_SMR_SPLIT_COMMENTS,       "If not shipped complete within the time window, St") < 0)
      return(FATAL);
   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  desc_type,
      				  split_comments,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH3,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  'F',
   				  'ein Mart may assess charges or reject all or part',
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H3_2 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


    if (fprintf(outRtkFilePtr, h3String,
                        LEN_SMR_REC_TYPE1,            recTypeDescH3,
                        LEN_SMR_REC_TYPE2,             "H",
                        LEN_SMR_REC_SEQ,              recSequence++,
                        LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
                        LEN_SMR_COMPANY_ID,           1,
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                        LEN_SMR_DESC_TYPE,            "F",
                        LEN_SMR_SPLIT_COMMENTS,       "ein Mart may assess charges or reject all or part") < 0)
      return(FATAL);
   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  desc_type,
      				  split_comments,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH3,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  'F',
   				  'of the shipment.',
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H3_3 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

      if (fprintf(outRtkFilePtr, h3String,
                        LEN_SMR_REC_TYPE1,            recTypeDescH3,
                        LEN_SMR_REC_TYPE2,             "H",
                        LEN_SMR_REC_SEQ,              recSequence++,
                        LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
                        LEN_SMR_COMPANY_ID,           1,
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                        LEN_SMR_DESC_TYPE,            "F",
                        LEN_SMR_SPLIT_COMMENTS,       "of the shipment.") < 0)
      return(FATAL);
    return(0);

}

/*------------------------------------------------------*\
* function writeH3_QCInd()                              *
\*------------------------------------------------------*/
int writeH3_QCInd(FILE *outRtkFilePtr)
{
   char *function_name = "writeH3_QCInd";

   #ifdef DEBUG
   printf("writeH3_QCInd - main write next\n");
   #endif

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  desc_type,
      				  split_comments,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH3,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  'F',
   				  'Pending Approval of TOP Sample',
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H3_QC INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   if (fprintf(outRtkFilePtr, h3String,
                        LEN_SMR_REC_TYPE1,            recTypeDescH3,
                        LEN_SMR_REC_TYPE2,             "H",
                        LEN_SMR_REC_SEQ,              recSequence++,
                        LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
                        LEN_SMR_COMPANY_ID,           1,
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                        LEN_SMR_DESC_TYPE,            "F",
                        LEN_SMR_SPLIT_COMMENTS,       "Pending Approval of TOP Sample") < 0)
      return(FATAL);
    return(0);

}


/*------------------------------------------------------*\
* function writeH4()                                 *
\*------------------------------------------------------*/
int writeH4(FILE *outRtkFilePtr)
{
   char *function_name = "writeH4";

   #ifdef DEBUG
   printf("writeH4 - main write next\n");
   #endif


   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  ship_to_mark_for,
      				  address1,
      				  address2,
      				  city,    
      				  state,
      				  zip,
      				  country,
      				  wh_desc,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH4,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  :shipToMarkFor,
   				  null,
   				  null,
   				  null,    
   				  null,   
   				  null,     
   				  null, 
   				  :h4WhName,
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H4 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


   fprintf(outRtkFilePtr, h4String_850,
           LEN_SMR_REC_TYPE1,            recTypeDescH4,
           LEN_SMR_REC_TYPE2,             "H",
           LEN_SMR_REC_SEQ,              recSequence,
           LEN_SMR_VENDOR_NMBR,          atoi(supplier),
           LEN_SMR_COMPANY_ID,           1,
           LEN_SMR_PO_NMBR,              atoi(poNumber),
           LEN_SMR_DC_STORE_NMBR,        atoi(h4StoreNumber),
           LEN_SMR_SHIP_TO_MARK_FOR,     shipToMarkFor,
           LEN_SMR_ADDRESS,              "",
           LEN_SMR_ADDRESS,              "",
           LEN_SMR_CITY,                 "",
           LEN_SMR_STATE,                "",
           LEN_SMR_ZIP,                  "",
           LEN_SMR_COUNTRY,              "",
           LEN_SMR_WH_DESC,              h4WhName);

   return(0);
}

/*------------------------------------------------------*\
 * function writeD1()                                   *
\*------------------------------------------------------*/
int writeD1(FILE *outRtkFilePtr)
{
   char *function_name = "writeD1";

   int i = 0;

   EXEC SQL DECLARE cursorD1Qty CURSOR FOR
     SELECT sum(v.qty_allocated) item_qty
       from v_ord_alloc_extract_dtl_smr v
      where v.order_no = TO_NUMBER(:orderNo)
        and ((v.item = :item) or (v.item in (select item from packitem where pack_no = :item)))
        and ((v.order_no in (select order_no from ordhead where location in     (select wh from wh_attributes where wh_type_code = 'DD') and v.to_loc = :allocRec.allocStore))
          or (v.order_no in (select order_no from ordhead where location not in (select wh from wh_attributes where wh_type_code = 'DD'))))
        and qty_allocated > 0;
        
   EXEC SQL DECLARE cursorD4Qty CURSOR FOR
       SELECT pack_qty
        from packitem p
       where p.item = :item
         and p.pack_no in (select item from ordloc where order_no = TO_NUMBER(:orderNo)) ;
      
            
   #ifdef DEBUG
   printf("writeD1 - poType=%s\n",poType);
   #endif

   if (strcmp(poType,SMR_ALLOC_PO_TYPE) == 0) 
   {
    if (strcmp(recTypeDescD1, recTypeDescD4) == 0) /* then Vendor Pack D4 */
    {
      EXEC SQL OPEN cursorD4Qty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorD4Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorD4Qty INTO :totalD1Qty;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorD4Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorD4Qty;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorD4Qty, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      #ifdef DEBUG
      printf("cursorD4Qty totalD1Qty order_no=%s, item=%s, totalD1Qty=%s\n", orderNo, item, totalD1Qty);
      #endif
      
    }
    else
    {
      EXEC SQL OPEN cursorD1Qty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorD1Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorD1Qty INTO :totalD1Qty;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorD1Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorD1Qty;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorD1Qty, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      #ifdef DEBUG
      printf("cursorD1Qty totalD1Qty order_no=%s, item=%s, totalD1Qty=%s\n", orderNo, item, totalD1Qty);
      #endif
    }
   }
   else /* not RL */
      strcpy(totalD1Qty, qtyOrdered);

   ps_hdr_record_id++;

   #ifdef DEBUG
   printf("totalD1Qty=%s\n", totalD1Qty);
   #endif

   EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,            
      				  REC_TYPE2,            
      				  REC_SEQ,              
      				  SUPPLIER_NMBR,          
      				  COMPANY_ID,           
      				  PO_NMBR,              
      				  DC_STORE_NMBR,        
      				  ITEM_SKU_NMBR,        
      				  ITEM_STORE_NMBR,      
      				  DETAIL_REC_SUB_SEL,   
      				  VPN,                  
      				  ITEM_QTY,
      				  UOM_IDENTIFIER,
      				  UNIT_COST,            
      				  UPC,                  
      				  RETAIL_PRICE_ID,      
      				  RETAIL_PRICE,         
      				  BUYER_COLOR_QUALIFIER,
      				  BUYER_COLOR_DESC,     
      				  BUYER_SIZE_QUALIFIER, 
      				  BUYER_SIZE_DESC,      
      				  COMPARE_TO_PRICE_ID,  
      				  COMPARE_TO_PRICE ,   
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescD1,
   				  'D',
   				  :d1RecSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  to_number(:item),
   				  0,
   				  1,
   				  :itemSupVPN,
   				  to_number(:totalD1Qty),
   				  'EA',
   				  to_number(:orderUnitCost),
   				  :upc,
   				  'MSR',
   				  to_number(:orderUnitRetail),
   				  'BO',
   				  :itemColorDesc,
   				  'IZ',
   				  :itemSizeDesc,
   				  'MSR',
   				  to_number(:itemMfgRecRetail),
   				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }




      /* use format for 850 since order change type is new */
   fprintf(outRtkFilePtr, d1String850,
           LEN_SMR_REC_TYPE1,            recTypeDescD1,
           LEN_SMR_REC_TYPE2,             "D",
           LEN_SMR_REC_SEQ,              d1RecSequence,
           LEN_SMR_VENDOR_NMBR,          atoi(supplier),
           LEN_SMR_COMPANY_ID,           1,
           LEN_SMR_PO_NMBR,              atoi(poNumber),
           LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
           LEN_SMR_ITEM_SKU_NMBR,        atol(item),
           LEN_SMR_ITEM_STORE_NMBR,      0,
           LEN_SMR_DETAIL_REC_SUB_SEL,   1,
           LEN_SMR_VPN,                  itemSupVPN,
           LEN_SMR_ITEM_QTY,             atoi(totalD1Qty),
           LEN_SMR_UOM_IDENTIFIER,       "EA",
           LEN_SMR_UNIT_COST,            atol(orderUnitCost),
           LEN_SMR_UPC,                  upc,
           LEN_SMR_RETAIL_PRICE_ID,      "MSR",
           LEN_SMR_RETAIL_PRICE,         atol(orderUnitRetail),
           LEN_SMR_BUYER_COLOR_QUALIFIER,"BO",
           LEN_SMR_BUYER_COLOR_DESC,     itemColorDesc,
           LEN_SMR_BUYER_SIZE_QUALIFIER, "IZ",
           LEN_SMR_BUYER_SIZE_DESC,      itemSizeDesc,
           LEN_SMR_COMPARE_TO_PRICE_ID,  "MSR",
           LEN_SMR_COMPARE_TO_PRICE,     atol(itemMfgRecRetail));

    return(0);
}

int processBulkDetail(void)
{
   char *function_name = "processBulkDetail";
   /* track current item so can increment d1RecSequence correctly */
   char currentItem[NULL_ITEM] = "";

   /* gets detail for SMR bulk order type;  uses a view v_ord_extract_dtl_smr
      that has embedded logic for getting correct unit cost and ref item for
      buyer packs which are exploded to pack item detail;  this simplifies query
      here and allows me to use subquery in select fields                        */
      
      EXEC SQL DECLARE cursorDetail CURSOR FOR
             SELECT v.item,
             substr(s.vpn,1,15),                                                                    
             to_char(sum(v.qty_ordered)),
             to_char(v.unit_retail*10000),
             to_char(v.unit_cost*10000),
             CASE WHEN v.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(v.ref_item,p.item),1,15),15,'0')  
                  ELSE DECODE(p.item_number_type,'SMRBC','               ', LPAD(p.item,15,'0')) 
             END upc,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(i.mfg_rec_retail*10000),
             i.pack_type
        FROM v_ord_extract_dtl_smr v,
             ordhead oh,
             item_supplier s,
             item_master i,
             item_master p,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
       WHERE v.order_no = TO_NUMBER(:orderNo)
             and v.order_no = oh.order_no
             and oh.order_no = TO_NUMBER(:orderNo)
             and i.item = s.item
             and oh.supplier = s.supplier
             and v.item = i.item
             and v.item = p.item_parent(+)
             and p.primary_ref_item_ind(+) = 'Y'
             and i.item = dc.item(+)
             and i.item = ds.item(+)
    GROUP BY v.item,v.ref_item,p.item_number_type,p.item, s.vpn, v.unit_retail, v.unit_cost, NVL(v.ref_item, p.item),
             substr(dc.diff_desc,1,15), substr(ds.diff_desc,1,15), i.mfg_rec_retail,
             i.pack_type
      HAVING to_char(sum(v.qty_ordered)) > 0
    ORDER BY v.item;
    

   #ifdef DEBUG
   printf("processBulkDetail - cursor open next\n");
   #endif


   EXEC SQL OPEN cursorDetail;
   if (SQL_ERROR_FOUND)
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDetail");
      strcpy(table, "ordhead,ordsku,ordloc,item_supplier,item_master,diff_ids");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorDetail next\n");
   #endif

   /* Reset item sequence number for each PO */
   d1RecSequence=0;

   while (1)
   {
      EXEC SQL FETCH cursorDetail INTO :orderItem,
                                       :itemSupVPN:itemSupVPNInd,
                                       :qtyOrdered,
                                       :orderUnitRetail,
                                       :orderUnitCost,
                                       :upc:upcInd,
                                       :itemColorDesc:itemColorDescInd,
                                       :itemSizeDesc:itemSizeDescInd,
                                       :itemMfgRecRetail:itemMfgRecRetailInd,
                                       :itemPackType:itemPackTypeInd;

      if (SQL_ERROR_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDetail");
         strcpy(table, "ordhead,ordsku,ordloc,item_supplier,item_master,diff_ids");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("process bulk detail for item %s\n", orderItem);
      #endif

      /* validate that data fits into output format */

      /* handle any null values from query */
      if (itemSupVPNInd == -1)
         strcpy(itemSupVPN,"               ");    /* 15 spaces */

      if (upcInd == -1)
         strcpy(upc,"               ");           /* 15 spaces */

      if (itemColorDescInd == -1)
         strcpy(itemColorDesc,"               "); /* 15 spaces */

      if (itemSizeDescInd == -1)
         strcpy(itemSizeDesc,"               ");  /* 15 spaces */   

      if (itemMfgRecRetailInd == -1)
         strcpy(itemMfgRecRetail,"0");

      recSequence++;

      /* populate item field for writeD1 rec */
      strcpy(item, orderItem);
      strcpy(recTypeDescD1,"S850D1");
      strcpy(recTypeDescD2,"S850D2");
      strcpy(recTypeDescD3,"S850D3");

      /* check if need to increment d1RecSequence for new item - increment if does not match */
      if (strcmp(currentItem, orderItem))
      {
         /* reset to 1 for each new item */
         strcpy(currentItem, orderItem);
         d1RecSequence=0;
      }

   #ifdef DEBUG
   printf("itemPackTypeInd=%d\n", itemPackTypeInd);
   printf("itemPackType=%s\n", itemPackType);
   #endif
      
      if (itemPackTypeInd != -1 && !strcmp(itemPackType,"V"))
      {
         if (writePOVNDP(ediFilePtr) < OK)
            return(FATAL);
      }
      else /* not a vendor pack */
      {
      
   #ifdef DEBUG
   printf("not a vendor pack - writing D1\n");
   #endif
      
         d1RecSequence++;

         if (writeD1(ediFilePtr) < OK)
            return(FATAL);

         d1RecSequence++;

         if (writeD2(ediFilePtr) < OK)
            return(FATAL);

         /* output D3 record for stand alone order;  not needed for bulk order */
         if (strcmp(poType,SMR_STANDALONE_PO_TYPE) == 0) 
         {
   /*          d1RecSequence++; */

            if (writeD3(ediFilePtr) < OK)
               return(FATAL);  
         }
      }
   }
   return(0);

}

/*------------------------------------------------------*\
 * function writeD2()                                   *
\*------------------------------------------------------*/
int writeD2(FILE *outRtkFilePtr)
{
   char *function_name = "writeD2";

   int i = 0;

   EXEC SQL DECLARE cursorDetail2 CURSOR FOR
        SELECT s.item,
             substr(s.vpn,1,15),                                                                  
             CASE WHEN sk.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(sk.ref_item,p.item),1,15),15,'0')  
                  ELSE DECODE (p.item_number_type,'SMRBC','               ', LPAD(p.item,15,'0')) 
             END upc,
             t.ticket_type_id,
             substr(th.ticket_type_desc,1,10),
             substr(uv.uda_value_desc,1,instr(uv.uda_value_desc,',',1)-1),
             trim(substr(uv.uda_value_desc,instr(uv.uda_value_desc,',',1)+1,instr(uv.uda_value_desc,',',1)+10))
        FROM item_supplier s,
             item_master p,
             item_ticket t,
             ticket_type_head th,
             uda_item_lov u,
             uda_values uv,
             ordhead o,
             ordsku sk
       WHERE s.item = :item
             and o.order_no = TO_NUMBER(:orderNo)
             and sk.item(+) = s.item
             and sk.order_no(+) = TO_NUMBER(:orderNo)
             and s.supplier = o.supplier
             and s.item = p.item_parent(+)
             and p.primary_ref_item_ind(+) = 'Y'
             and s.item = t.item
             and t.ticket_type_id = th.ticket_type_id
             and s.item = u.item
             and u.uda_id = 1
             and u.uda_id = uv.uda_id
             and u.uda_value = uv.uda_value;

   #ifdef DEBUG
   printf("writeD2 - cursor open next\n");
   printf("writeD2 - order number is %s\n", orderNo);
   printf("writeD2 - item is %s\n", item);
   #endif

   EXEC SQL OPEN cursorDetail2;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDetail2");
      strcpy(table, "ordhead,ordsku,item_supplier,item_master,item_ticket,ticket_type_head,uda_item_loc,uda_values");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorDetail2 next\n");
   #endif

   while (1)
   {
      EXEC SQL FETCH cursorDetail2 INTO :orderItem,
                                            :itemSupVPN:itemSupVPNInd,
                                            :upc:upcInd,
                                            :itemTicketTypeId:itemTicketTypeIdInd,
                                            :itemTicketTypeDesc:itemTicketTypeDescInd,
                                            :itemHangerCode:itemHangerCodeInd,
                                            :itemHangerCodeDesc:itemHangerCodeDescInd;

      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDetail2");
         strcpy(table, "ordhead,ordsku,item_supplier,item_master,item_ticket,ticket_type_head,uda_item_loc,uda_values");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("  item is %s\n", orderItem);
      #endif

      /* validate that data fits into output format */

      /* handle any null values from query */
      if (itemSupVPNInd == -1)
         strcpy(itemSupVPN,"               ");   /* 15 spaces */

      if (upcInd == -1)
         strcpy(upc,"               ");          /* 15 spaces */

      if (itemTicketTypeIdInd == -1)
         strcpy(itemTicketTypeId,"          ");  /* 10 spaces */

      if (itemTicketTypeDescInd == -1)
         strcpy(itemTicketTypeDesc,"          ");  /* 10 spaces */

      if (itemHangerCodeInd == -1)
         strcpy(itemHangerCode,"          ");      /* 10 spaces */

      if (itemHangerCodeDescInd == -1)
         strcpy(itemHangerCodeDesc,"          ");  /* 10 spaces */

      i++;
      recSequence++;

      #ifdef DEBUG
      printf("writeD2 - main write next\n");
      #endif


   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
      				  REC_TYPE2,         
      				  REC_SEQ,           
      				  SUPPLIER_NMBR,       
      				  COMPANY_ID,        
      				  PO_NMBR,           
      				  DC_STORE_NMBR,     
      				  ITEM_SKU_NMBR,     
      				  UPC,               
      				  VPN,               
      				  DETAIL_REC_SUB_SEL,
      				  CHARGE_IND,        
      				  VICS,              
      				  TCKT_HANG_CODE,              
      				  TCKT_HANG_DESC,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
      				  :recTypeDescD2,
      				  'D',
      				  :d1RecSequence,
      				  to_number(:supplier),
      				  1,
      				  to_number(:poNumber),
      				  to_number(:dcStoreNumber),
      				  to_number(:orderItem),
      				  :upc,
      				  :itemSupVPN,
      				  1,
      				  'N',
      				  'VI',
      				  :itemTicketTypeId,
      				  :itemTicketTypeDesc,
      				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D2_1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


      /* write for D2 with ticket type */
      fprintf(outRtkFilePtr, d2String,
                           LEN_SMR_REC_TYPE1,            recTypeDescD2,
                           LEN_SMR_REC_TYPE2,             "D",
                           LEN_SMR_REC_SEQ,              d1RecSequence,
                           LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
                           LEN_SMR_COMPANY_ID,           1,
                           LEN_SMR_PO_NMBR,              atoi(poNumber),
                           LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                           LEN_SMR_ITEM_SKU_NMBR,        atol(orderItem),
                           LEN_SMR_UPC,                  upc,
                           LEN_SMR_VPN,                  itemSupVPN,
                           LEN_SMR_DETAIL_REC_SUB_SEL,   1,
                           LEN_SMR_CHARGE_IND,           "N",
                           LEN_SMR_VICS,                 "VI",
                           LEN_SMR_CODE,                 itemTicketTypeId,
                           LEN_SMR_CODE_DESC,            itemTicketTypeDesc);

      recSequence++;
      d1RecSequence++; 
      ps_hdr_record_id++;
      EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
      				  REC_TYPE2,         
      				  REC_SEQ,           
      				  SUPPLIER_NMBR,       
      				  COMPANY_ID,        
      				  PO_NMBR,           
      				  DC_STORE_NMBR,     
      				  ITEM_SKU_NMBR,     
      				  UPC,               
      				  VPN,               
      				  DETAIL_REC_SUB_SEL,
      				  CHARGE_IND,        
      				  VICS,              
      				  TCKT_HANG_CODE,              
      				  TCKT_HANG_DESC,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
      				  :recTypeDescD2,
      				  'D',
      				  :d1RecSequence,
      				  to_number(:supplier),
      				  1,
      				  to_number(:poNumber),
      				  to_number(:dcStoreNumber),
      				  to_number(:orderItem),
      				  :upc,
      				  :itemSupVPN,
      				  1,
      				  'N',
      				  'VI',
      				  :itemHangerCode,
      				  :itemHangerCodeDesc,
      				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D2_2 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }



      /* write for D2 with hanger type */
      fprintf(outRtkFilePtr, d2String,
                           LEN_SMR_REC_TYPE1,            recTypeDescD2,
                           LEN_SMR_REC_TYPE2,            "D",
                           LEN_SMR_REC_SEQ,              d1RecSequence,
                           LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
                           LEN_SMR_COMPANY_ID,           1,
                           LEN_SMR_PO_NMBR,              atoi(poNumber),
                           LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                           LEN_SMR_ITEM_SKU_NMBR,        atol(orderItem),
                           LEN_SMR_UPC,                  upc,
                           LEN_SMR_VPN,                  itemSupVPN,
                           LEN_SMR_DETAIL_REC_SUB_SEL,   1,
                           LEN_SMR_CHARGE_IND,           "N",
                           LEN_SMR_VICS,                 "VI",
                           LEN_SMR_CODE,                 itemHangerCode,
                           LEN_SMR_CODE_DESC,            itemHangerCodeDesc);

/*      d1RecSequence++; */
   }

   return(0);
}

/*------------------------------------------------------*\
* function writeD3()                                    *
\*------------------------------------------------------*/
int writeD3(FILE *outRtkFilePtr)
{
   char *function_name = "writeD3";

   int i = 0; 
   int j = 0;

   EXEC SQL DECLARE cursorDetail3 CURSOR FOR
        SELECT s.item,
             substr(s.vpn,1,15),                                                                  
             CASE WHEN sk.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(sk.ref_item,p.item),1,15),15,'0')  
                  ELSE DECODE (p.item_number_type,'SMRBC','               ', LPAD(p.item,15,'0')) 
             END upc,
             to_char(v.qty_ordered)
        FROM item_supplier s,
             item_master p,
             ordhead o,
             ordsku sk,
             v_ord_extract_dtl_smr v             
       WHERE v.order_no = TO_NUMBER(:orderNo)
             and v.order_no = o.order_no
             and s.item = :item
             and o.order_no = TO_NUMBER(:orderNo)
             and sk.item(+) = s.item
             and sk.order_no(+) = TO_NUMBER(:orderNo)
             and s.supplier = o.supplier
             and s.item = p.item_parent(+)
             and p.primary_ref_item_ind(+) = 'Y'
             and v.item = s.item;

    EXEC SQL DECLARE cursorAllocForNewLocSt CURSOR FOR
        SELECT v.to_loc,
             substr(st.store_name,1,25),
             st.default_wh,
             to_char(v.qty_allocated),
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N') newstore
        from v_ord_alloc_extract_dtl_smr v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
             and ((oh.location     in (select wh from wh_attributes where wh_type_code = 'DD') and v.to_loc = :allocRec.allocStore)
               or (oh.location not in (select wh from wh_attributes where wh_type_code = 'DD')))
             and im.item = :allocRec.allocItem
             and v.to_loc = st.store
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier
             and oh.order_no = v.order_no
             and v.qty_allocated > 0 
      ORDER BY 1;


   #ifdef DEBUG
   printf("writeD3 - cursor open next\n");
   printf("writeD3 - order number is %s\n", orderNo);
   printf("writeD3 - item is %s\n", item);
   #endif

if (strcmp(poType,SMR_STANDALONE_PO_TYPE) == 0) 
{
   /* ship to location */
   strcpy(d3StoreNumber, dcStoreNumber);

   EXEC SQL OPEN cursorDetail3;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDetail3");
      strcpy(table, "ordhead,ordsku,item_supplier,item_master");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorDetail3 next\n");
   #endif

      EXEC SQL FETCH cursorDetail3 INTO :orderItem,
                                        :itemSupVPN:itemSupVPNInd,
                                        :upc:upcInd,
                                        :qtyOrdered;


      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDetail3");
         strcpy(table, "ordhead,ordsku,item_supplier,item_master");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }

      #ifdef DEBUG
      printf("  item is %s\n", orderItem);
      #endif

      /* validate that data fits into output format */
      /* handle any null values from query          */
      if (itemSupVPNInd == -1)
         strcpy(itemSupVPN,"               ");   /* 15 spaces */

      if (upcInd == -1)
         strcpy(upc,"               ");          /* 15 spaces */

      recSequence++;

      #ifdef DEBUG
      printf("writeD3 - main write next\n");
      #endif


   ps_hdr_record_id++;
   d1RecSequence++;
   EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
      				  REC_TYPE2,         
      				  REC_SEQ,           
      				  SUPPLIER_NMBR,       
      				  COMPANY_ID,        
      				  PO_NMBR,           
      				  DC_STORE_NMBR,     
      				  ITEM_SKU_NMBR,     
      				  UPC,               
      				  VPN,               
      				  SDQ_TEXT,
      				  UOM_IDENTIFIER,        
      				  STORE,
      				  STORE_QUANTITY,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
      				  :recTypeDescD3,
      				  'D',
      				  :d1RecSequence,
      				  to_number(:supplier),
      				  1,
      				  to_number(:poNumber),
      				  to_number(:dcStoreNumber),
      				  to_number(:orderItem),
      				  :upc,
      				  :itemSupVPN,
      				  'SDQ',
      				  :UOM_D3,
      				  :d3StoreNumber,
      				  to_number(:qtyOrdered),
      				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D3 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

      /* write for D3 */
      fprintf(outRtkFilePtr, d3String,
                           LEN_SMR_REC_TYPE1,            recTypeDescD3,
                           LEN_SMR_REC_TYPE2,             "D",
                           LEN_SMR_REC_SEQ,              d1RecSequence,
                           LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
                           LEN_SMR_COMPANY_ID,           1,
                           LEN_SMR_PO_NMBR,              atoi(poNumber),
                           LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                           LEN_SMR_ITEM_SKU_NMBR,        atol(orderItem),
                           LEN_SMR_UPC,                  upc,
                           LEN_SMR_VPN,                  itemSupVPN,
                           LEN_SDQ_TEXT,                 "SDQ",
                           LEN_SMR_UOM_IDENTIFIER,       "EA",
                           LEN_SMR_DC_STORE_NMBR,        atoi(d3StoreNumber),
                           LEN_SMR_ITEM_QTY,             atoi(qtyOrdered),
                           LEN_SDQ_SA_FILL,              " 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 ");

      fprintf(outRtkFilePtr, "%s", "\n");
      recSequence++;
 }
 else if (strcmp(poType,SMR_ALLOC_PO_TYPE) == 0)
 {
       #ifdef DEBUG
       printf("  item333 is <%s>\n", allocRec.allocItem);
       #endif
 
       /* validate that data fits into output format */
 
       /* handle any null values from query */
       if (itemSupVPNInd == -1)
          strcpy(itemSupVPN,"               ");   /* 15 spaces */
 
       if (upcInd == -1)
          strcpy(upc,"               ");          /* 15 spaces */
 
       #ifdef DEBUG
       printf("writeD3333 - main write next\n");
       #endif
 
      EXEC SQL OPEN cursorAllocForNewLocSt;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorAllocForNewLoc");
         strcpy(table, "alloc_header,alloc_detail,store");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      while( 1 )
      {            
	 EXEC SQL FETCH cursorAllocForNewLocSt INTO :allocRec.allocStore,
					      :allocRec.storeName,
					      :allocRec.storeDefaultWh:storeDefaultWhInd,
					      :allocRec.qtyAlloc,
					      :allocRec.newStore;

	 if SQL_ERROR_FOUND
	 {
	   strcpy(err_data, "CURSOR FETCH: cursor=cursorAllocForNewLocSt");
	   strcpy(table, "alloc_header,alloc_detail,store");
	   WRITE_ERROR(SQLCODE,function_name,table,err_data);
	   return(FATAL);
	 }
	 if NO_DATA_FOUND break;

         #ifdef DEBUG
         printf("WhInd=<%d> as=<%s> asn=<%s> dw=<%s> qty=<%s> ns=<%s>\n", storeDefaultWhInd,allocRec.allocStore,allocRec.storeName,allocRec.storeDefaultWh,allocRec.qtyAlloc,allocRec.newStore);
         #endif
       
    
         /* ship to location */
         strcpy(d3StoreNumber, allocRec.allocStore);

         if (strcmp(orderLocation, ps_dd_wh) == 0)
           strcpy(dcStoreNumber,allocRec.allocStore);
         else         
         {
           strncpy(dcStoreNumber,allocRec.storeDefaultWh,3);
           dcStoreNumber[3] = '\0';
         }
         strcpy(qtyOrdered,allocRec.qtyAlloc);

         #ifdef DEBUG
         printf("d3s=<%s> dcs=<%s> qty=<%s>\n", d3StoreNumber,dcStoreNumber,qtyOrdered);
         #endif
       
        
         if (SQL_ERROR_FOUND)
         {
            sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D333 INSERT: for order no <%s>",poNumber);
            strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
            WRITE_ERROR(SQLCODE,function_name,table,err_data);
            return(FATAL);
         }
 
         i++;
         if ( i == 9 )
         {
            i = 1;
            fprintf(outRtkFilePtr, "%s", "\n");
         }

         #ifdef DEBUG
         printf("i=<%d> po=<%s> item=<%s> store=<%s> qty=<%s>\n", i,poNumber,allocRec.allocItem,d3StoreNumber,qtyOrdered);
         #endif
       
         if ( i == 1 ) 
         {
            recSequence++;
            d1RecSequence++;
            ps_hdr_record_id++;
            EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
       				  REC_TYPE2,         
       				  REC_SEQ,
       				  SUPPLIER_NMBR,       
       				  COMPANY_ID,        
       				  PO_NMBR,           
       				  DC_STORE_NMBR,     
       				  ITEM_SKU_NMBR,     
       				  UPC,               
       				  VPN,               
       				  SDQ_TEXT,
       				  UOM_IDENTIFIER,        
       				  SDQ1_STORE,
       				  SDQ1_STORE_QUANTITY,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
       				  :recTypeDescD3,
       				  'D',
       				  :d1RecSequence,
       				  to_number(:supplier),
       				  1,
       				  to_number(:poNumber),
       				  to_number(:dcStoreNumber),
       				  to_number(:allocRec.allocItem),
       				  :upc,
       				  :itemSupVPN,
       				  'SDQ',
       				  :UOM_D3,
       				  :d3StoreNumber,
       				  to_number(:qtyOrdered),
       				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));


            /* write for D3 */
            fprintf(outRtkFilePtr, d3String,
                         LEN_SMR_REC_TYPE1,            recTypeDescD3,
                         LEN_SMR_REC_TYPE2,             "D",
                         LEN_SMR_REC_SEQ,              d1RecSequence,
                         LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
                         LEN_SMR_COMPANY_ID,           1,
                         LEN_SMR_PO_NMBR,              atoi(poNumber),
                         LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                         LEN_SMR_ITEM_SKU_NMBR,        atol(allocRec.allocItem),
                         LEN_SMR_UPC,                  upc,
                         LEN_SMR_VPN,                  itemSupVPN,
                         LEN_SDQ_TEXT,                 "SDQ",
                         LEN_SMR_UOM_IDENTIFIER,       "EA",
                         LEN_SMR_DC_STORE_NMBR,        atoi(d3StoreNumber),
                         LEN_SMR_ITEM_QTY,             atoi(qtyOrdered),
                         1,                            " ");
            
         } 
         else 
         {
           if ( i == 2 )
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ2_STORE = :d3StoreNumber, SDQ2_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 3 )
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ3_STORE = :d3StoreNumber, SDQ3_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 4 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ4_STORE = :d3StoreNumber, SDQ4_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 5 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ5_STORE = :d3StoreNumber, SDQ5_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 6 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ6_STORE = :d3StoreNumber, SDQ6_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 7 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ7_STORE = :d3StoreNumber, SDQ7_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 8 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ8_STORE = :d3StoreNumber, SDQ8_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
         
           fprintf(outRtkFilePtr, "%05d%07d%s",atoi(d3StoreNumber),atoi(qtyOrdered)," ");
         }
       
      } /* while */
  
      if ( i > 0 ) for (j = i; j < 8; j++) fprintf(outRtkFilePtr, "%s","000000000000 ");      
      fprintf(outRtkFilePtr, "%s", "\n");
      
      EXEC SQL CLOSE cursorAllocForNewLocSt;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR CLOSE: cursor=cursorAllocForNewLoc");
         strcpy(table, "alloc_header,alloc_detail,store");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
   }

   return(0);
}


/*------------------------------------------------------*\
* function writePOVNDP()                                *
\*------------------------------------------------------*/
int writePOVNDP(FILE *outRtkFilePtr)
{
   char *function_name = "writePOVNDP";

   char componentItem[LEN_SMR_ITEM_SKU_NMBR+1];
   char packQty[LEN_SMR_ITEM_QTY+1];
   
   char sublineQty[LEN_SMR_PACK_SUBLINE_QTY+1];

   EXEC SQL DECLARE cursorPackDetail CURSOR FOR
             SELECT pk.item,
             substr(s.vpn,1,15),                                                                    
             to_char(pk.pack_qty),
             to_char(il.unit_retail*10000),
             to_char(ils.unit_cost*10000),
             LPAD(p.item,15,'0') upc,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(i.mfg_rec_retail*10000)
        FROM ordhead oh,
             item_loc il,
             item_loc_soh ils,
             item_supplier s,
             item_master i,
             item_master p,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds,
             packitem pk
       WHERE pk.pack_no = :item
             and oh.order_no = TO_NUMBER(:orderNo)
             and il.item = pk.item
             and il.loc = oh.location
             and ils.item = il.item
             and ils.loc = il.loc
             and i.item = pk.item
             and s.supplier = oh.supplier
             and s.item = pk.item
             and pk.item = p.item_parent(+)
             and p.primary_ref_item_ind(+) = 'Y'
             and i.item = dc.item(+)
             and i.item = ds.item(+)
    ORDER BY pk.item;

   EXEC SQL DECLARE cursorSubline CURSOR FOR
      SELECT to_char(sum(pack_qty))
        FROM packitem
       WHERE pack_no = :item
         and pack_no in (select item from ordloc where order_no = TO_NUMBER(:orderNo)) ;

   EXEC SQL DECLARE cursorVPItemQty CURSOR FOR
     SELECT sum(v.qty_allocated) item_qty
       from v_ord_alloc_extract_dtl_smr v
      where v.order_no = TO_NUMBER(:orderNo)
        and v.item = :item
        and qty_allocated > 0;
        

   EXEC SQL OPEN cursorSubline;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorSubline");
      strcpy(table, "packitem");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   EXEC SQL FETCH cursorSubline INTO :sublineQty;

   #ifdef DEBUG
   printf("cursorSubline is %s\n",sublineQty);
   #endif


   EXEC SQL CLOSE cursorSubline;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR CLOSE: cursor=cursorSubline");
      strcpy(table, "packitem");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   if ( strcmp(poType, SMR_ALLOC_PO_TYPE) == 0) 
   {
      EXEC SQL OPEN cursorVPItemQty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorVPItemQty");
         strcpy(table, "packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
   
      EXEC SQL FETCH cursorVPItemQty INTO :qtyVPItem;

      EXEC SQL CLOSE cursorVPItemQty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR CLOSE: cursor=cursorVPItemQty");
         strcpy(table, "packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }      
   }
   else
      strcpy( qtyVPItem, qtyOrdered );


   EXEC SQL OPEN cursorPackDetail;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorPackDetail");
      strcpy(table, "packitem");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


            recSequence++;
            d1RecSequence=1;
            ps_hdr_record_id++;
            EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
       				  REC_TYPE2,         
       				  REC_SEQ,           
       				  SUPPLIER_NMBR,      
       				  COMPANY_ID,        
       				  PO_NMBR,           
       				  DC_STORE_NMBR,     
       				  PACK_SKU_NMBR,     
       				  DETAIL_REC_SUB_SEL,
       				  VPN,               
       				  PACK_UNITS,
       				  UOM_IDENTIFIER,       
       				  PACK_UNIT_COST,         
       				  PACK_UPC,               
   				  TOTAL_SUBLINE_QTY,  
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
       				  :recTypeDescVP,
       				  'P',
       				  :d1RecSequence,
       				  to_number(:supplier),
       				  1,
       				  to_number(:poNumber),
       				  to_number(:dcStoreNumber),
       				  to_number(:item),
       				  1,
       				  :itemSupVPN,
       				  to_number(:qtyVPItem),
       				  'AS',
       				  to_number(:orderUnitCost),
       				  :upc,
       				  to_number(:sublineQty),
       				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));


   /* write for POVNDP ...
   fprintf(outRtkFilePtr, poVndpString,
                        LEN_SMR_REC_TYPE1,            "POVNDP",
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_ITEM_SKU_NMBR,        atol(item),
                        LEN_SMR_ITEM_SKU_NMBR,        atol(componentItem),
                        LEN_SMR_PACK_QTY,             atoi(packQty)); */
                        
   fprintf(outRtkFilePtr, poVndpString,
                        LEN_SMR_REC_TYPE1,            "SPOVND",	          /* RMS_Record_Type      */
                        LEN_SMR_REC_TYPE2,            "P",		  /* Record_Type          */
                        LEN_SMR_REC_SEQ,              d1RecSequence,	  /* Record_Sequence      */
                        LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),	  /* Trading_Partner_Id   */
                        LEN_SMR_COMPANY_ID,           1,		  /* Company_Id           */
                        LEN_SMR_PO_NMBR,              atoi(poNumber),	  /* PO_Number            */
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),/* Store                */
                        LEN_SMR_ITEM_SKU_NMBR,        atol(item),	  /* Pack_Sku		  */
                        LEN_SMR_DETAIL_REC_SUB_SEL,   1,		  /* Detail_Record_Sub_Seq*/
                        LEN_SMR_VPN,                  itemSupVPN,	  /* Vendor_Model_Number  */
                        LEN_SMR_PACK_QTY,             atoi(qtyVPItem),	  /* Pack_Units		  */
                        LEN_SMR_UOM_IDENTIFIER,       "AS",		  /* UOM_Identifier	  */
                        LEN_SMR_UNIT_COST,            atol(orderUnitCost),/* Pack_Unit_Cost       */
                        LEN_SMR_UPC,                  upc,		  /* Pack_UPC		  */
                        LEN_SMR_PACK_SUBLINE_QTY,     atoi(sublineQty));  /* Total_Subline_QTY    */

   if (!strcmp(poType,"BK") == 0 )
   {
      strcpy( UOM_D3, "AS" );
      if (writeD3(ediFilePtr) < OK)
         return(FATAL);
      strcpy( UOM_D3, "EA" );
   }
         
   #ifdef DEBUG
   printf("Loop through fetches of cursorPackDetail next\n");
   #endif

   while (1)
   {
      EXEC SQL FETCH cursorPackDetail INTO :componentItem,
                                       :itemSupVPN:itemSupVPNInd,
                                       :packQty,
                                       :orderUnitRetail:orderUnitRetailInd,
                                       :orderUnitCost,
                                       :upc:upcInd,
                                       :itemColorDesc:itemColorDescInd,
                                       :itemSizeDesc:itemSizeDescInd,
                                       :itemMfgRecRetail:itemMfgRecRetailInd;


      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorPackDetail");
         strcpy(table, "packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("  writing vendor D4,D2\n");
      #endif

      #ifdef DEBUG
      printf("  component item is %s\n", componentItem);
      #endif

      strcpy(item, componentItem);
      strcpy(recTypeDescD1, recTypeDescD4);
      strcpy(qtyOrdered, packQty);


      d1RecSequence++;
      if (writeD1(ediFilePtr) < OK)
         return(FATAL);

      d1RecSequence++;
      if (writeD2(ediFilePtr) < OK)
         return(FATAL);

      #ifdef DEBUG
      printf("  finished writing vendor D4,D2\n");
      #endif

   }

   return(OK);
}

/*------------------------------------------------------*\
* function final()                                       *
\*------------------------------------------------------*/

int final(void)
{
    int finalReturnInt = 0;
    char *function_name = "final";


    if (retek_close() < 0)
        finalReturnInt = -1;

    return(finalReturnInt);

} /* end final */
