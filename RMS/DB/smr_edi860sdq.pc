/*-----------------------------------------------------------------------------------------------------------------------
* Module Name:  smr_edi860dl
* Module Description:  Stein Mart custom extract program to create the SMR PO edi 860
*                      download file.
*                      There is logic in this program that is the same as smr_edi850dl.
*                      Make sure that updates are done to both programs or any shared
*                      logic is moved to a shared library.
*
* Dependency Notes:    Need to run ordrev to update order revision to latest before running.
*
* Restart Notes:       If program fails in middle of processing PO number, you should be
*                      able to determine po number from restart bookmark and clean file up.
*                      No need to restart after that since will pick up partial process PO
*                      if not updated at end of file writes.  So can remove bookmark and run
*                      from top.
* Change History
* Version Date      Developer       Issue   Description
* ======= ========= =============== ======= =============================================================================
*    1.00 27-Mar-15 S. Fehr                   re-write for SDQ (Store Delivery Quantity)
*--------------------------------------------------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------------*\
  Includes                                               
\*------------------------------------------------------*/

#include <errno.h>
#include <retek_2.h>
#include <intrface.h>
#include <std_rest.h>
#include <string.h>
#include <math.h>


EXEC SQL INCLUDE SQLCA.H;


/*------------------------------------------------------*\
  Defines                                                
\*------------------------------------------------------*/

#define DEBUG 1
/*#undef DEBUG*/

#define NUM_INIT_PARAMETERS                4
#define LEN_OUTFILE_NAME                   1024

/* defines for SMR output format - H1 */
#define LEN_SMR_REC_TYPE1                  6
#define LEN_SMR_REC_TYPE2                  2
#define LEN_SMR_REC_SEQ                    4
#define LEN_SMR_TRADING_PTNR              15
#define LEN_SMR_COMPANY_ID                 3
#define LEN_SMR_PO_TYPE                    2
#define LEN_SMR_PO_NMBR                    9
#define LEN_SMR_PO_PURPOSE_CODE            2
#define LEN_SMR_DC_STORE_NMBR              5
#define LEN_SMR_VENDOR_NMBR_REF            2
#define LEN_SMR_VENDOR_NMBR                9
#define LEN_SMR_SUPPLIER_NMBR              9
#define LEN_SMR_DEPT_NMBR_REF              2
#define LEN_SMR_DEPT_NMBR                  3
#define LEN_SMR_BUYER_NMBR_REF             2
#define LEN_SMR_BUYER_FNCTN_CODE           2
#define LEN_SMR_BUYER_NMBR                 3
#define LEN_SMR_BUYER_CONTACT_NAME        60
#define LEN_SMR_BUYER_COMM_QUALFR          2
#define LEN_SMR_BUYER_PHONE_NMBR          80
#define LEN_SMR_DC_FUNCTION_CODE           2
#define LEN_SMR_DC_CONTACT_NAME           60
#define LEN_SMR_DC_COMM_QUALIFER           2
#define LEN_SMR_DC_PHONE_NMBR             80
#define LEN_SMR_CASH_REQ_CODE              2
#define LEN_SMR_DELIVERY_INSTRUCT         35
#define LEN_SMR_SPECIAL_FREIGHT_DESC      20
#define LEN_SMR_DISCOUNT_DESC             30
#define LEN_SMR_860_TOTAL_QTY_PO           8
#define LEN_SMR_PO_DATE                    8
#define LEN_SMR_PO_CHANGE_DATE             8

#define LEN_SMR_PO_REQUESTED_SHIP          3
#define LEN_SMR_PO_SHIP_DATE               8
#define LEN_SMR_PO_RCV_DATE                8
#define LEN_SMR_PO_CANCEL_AFTER            3
#define LEN_SMR_PO_CANCEL_DATE             8
#define LEN_SMR_PO_PROMO                   3
#define LEN_SMR_PO_PROMO_DATE              8
#define LEN_SMR_TERMS_ID_QUALIFER          2
#define LEN_SMR_TERMS_OF_PURCHASE        170

#define LEN_SMR_CHARGE_IND                 1
#define LEN_SMR_VICS                       2
#define LEN_SMR_NEW_STORE_RUSH            10
#define LEN_SMR_SAC_DESC                  40

#define LEN_SMR_DESC_TYPE                  1
#define LEN_SMR_COMMENTS                  50

#define LEN_SMR_SHIP_TO_MARK_FOR           2
#define LEN_SMR_ADDRESS                   55
#define LEN_SMR_CITY                      30
#define LEN_SMR_COUNTRY                    3
#define LEN_SMR_STATE                      2
#define LEN_SMR_ZIP                       10
#define LEN_SMR_WH_DESC                   25
#define LEN_SMR_STORE_NAME                25
#define LEN_SMR_WH_NAME                   25

/* defines for SMR output format - D1 */
#define LEN_SMR_PO_CHANGE_CODE             2


#define NULL_SMR_REC_TYPE1            (LEN_SMR_REC_TYPE1 + 1)
#define NULL_SMR_TRADING_PTNR         (LEN_SMR_TRADING_PTNR + 1)
#define NULL_SMR_COMPANY_ID           (LEN_SMR_COMPANY_ID + 1)
#define NULL_SMR_PO_TYPE              (LEN_SMR_PO_TYPE + 1)
#define NULL_SMR_PO_NMBR              (LEN_SMR_PO_NMBR + 1)
#define NULL_SMR_PO_PURPOSE_CODE      (LEN_SMR_PO_PURPOSE_CODE + 1)
#define NULL_SMR_DC_STORE_NMBR        (LEN_SMR_DC_STORE_NMBR + 1)
#define NULL_SMR_SHIP_TO_MARK_FOR     (LEN_SMR_SHIP_TO_MARK_FOR + 1)
#define NULL_SMR_VENDOR_NMBE_REF      (LEN_SMR_VENDOR_NMBE_REF + 1)
#define NULL_SMR_VENDOR_NMBR          (LEN_SMR_VENDOR_NMBR + 1)
#define NULL_SMR_DEPT_NMBR_REF        (LEN_SMR_DEPT_NMBR_REF + 1)
#define NULL_SMR_DEPT_NMBR            (LEN_SMR_DEPT_NMBR + 1)
#define NULL_SMR_BUYER_NMBR_REF       (LEN_SMR_BUYER_NMBR_REF + 1)
#define NULL_SMR_BUYER_FNCTN_CODE     (LEN_SMR_BUYER_FNCTN_CODE + 1)
#define NULL_SMR_BUYER_NMBR           (LEN_SMR_BUYER_NMBR + 1)
#define NULL_SMR_BUYER_CONTACT_NAME   (LEN_SMR_BUYER_CONTACT_NAME + 1)
#define NULL_SMR_BUYER_COMM_QUALFR    (LEN_SMR_BUYER_COMM_QUALFR + 1)
#define NULL_SMR_BUYER_PHONE_NMBR     (LEN_SMR_BUYER_PHONE_NMBR + 1)
#define NULL_SMR_DC_FUNCTION_CODE     (LEN_SMR_DC_FUNCTION_CODE + 1)
#define NULL_SMR_DC_CONTACT_NAME      (LEN_SMR_DC_CONTACT_NAME + 1)
#define NULL_SMR_DC_COMM_QUALIFER     (LEN_SMR_DC_COMM_QUALIFER + 1)
#define NULL_SMR_DC_PHONE_NMBR        (LEN_SMR_DC_PHONE_NMBR + 1)
#define NULL_SMR_CASH_REQ_CODE        (LEN_SMR_CASH_REQ_CODE + 1)
#define NULL_SMR_DELIVERY_INSTRUCT    (LEN_SMR_DELIVERY_INSTRUCT + 1)
#define NULL_SMR_SPECIAL_FREIGHT_DESC (LEN_SMR_SPECIAL_FREIGHT_DESC + 1)
#define NULL_SMR_DISCOUNT_DESC        (LEN_SMR_DISCOUNT_DESC + 1)
#define NULL_SMR_TOTAL_QTY_PO         (LEN_SMR_860_TOTAL_QTY_PO + 1)
#define NULL_SMR_PO_DATE              (LEN_SMR_PO_DATE + 1)
#define NULL_SMR_PO_REQUESTED_SHIP    (LEN_SMR_PO_REQUESTED_SHIP + 1)
#define NULL_SMR_PO_SHIP_DATE         (LEN_SMR_PO_SHIP_DATE + 1)
#define NULL_SMR_PO_RCV_DATE          (LEN_SMR_PO_RCV_DATE + 1)
#define NULL_SMR_PO_CANCEL_AFTER      (LEN_SMR_PO_CANCEL_AFTER + 1)
#define NULL_SMR_PO_CANCEL_DATE       (LEN_SMR_PO_CANCEL_DATE + 1)
#define NULL_SMR_PO_PROMO             (LEN_SMR_PO_PROMO + 1)
#define NULL_SMR_PO_PROMO_DATE        (LEN_SMR_PO_PROMO_DATE + 1)
#define NULL_SMR_PO_CHANGE_CODE       (LEN_SMR_PO_CHANGE_CODE + 1)
#define NULL_SMR_TERMS_ID_QUALIFER    (LEN_SMR_TERMS_ID_QUALIFER + 1)
#define NULL_SMR_TERMS_OF_PURCHASE    (LEN_SMR_TERMS_OF_PURCHASE + 1)
#define NULL_SMR_STORE_NAME           (LEN_SMR_STORE_NAME + 1)

#define NULL_SMR_NEW_STORE_RUSH       (LEN_SMR_NEW_STORE_RUSH + 1)
#define NULL_SMR_SAC_DESC             (LEN_SMR_SAC_DESC + 1)
#define NULL_SMR_VICS                 (LEN_SMR_VICS + 1)

#define NULL_SMR_COMMENTS             (LEN_SMR_COMMENTS + 1)

/* the following defines were used to improve readability of the code */
#define SMR_TERMS1 "THIS OFFER TO PURCHASE IS MADE SUBJECT TO STEIN MART'S STANDARD TERMS AND CONDITIONS OF PURCHASE WHICH AR AVAILABLE ON OUR WEB SITE AT HTTP://VENDORS.STEINMART.COM/"
#define SMR_TERMS2 "AND ARE ALSO AVAILABLE VIA FACSIMILE OR MAIL UPON REQUEST BY ANY VENDOR (\"SELLER\") AND WHICH ARE INCORPORATED HEREIN."

#define SMR_BULK_PO_TYPE                 "BK"
#define SMR_ALLOC_PO_TYPE                "RL"
#define SMR_STANDALONE_PO_TYPE           "SA"

#define SMR_PO_PURPOSE_CD_CANCEL         "01"
#define SMR_PO_PURPOSE_CD_CHANGE         "04"
#define SMR_PO_PURPOSE_CD_00             "00"

#define SMR_D1_CHANGE_CODE_ADD_ITEM      "AI"
#define SMR_D1_CHANGE_CODE_DELETE_ITEM   "DI"
#define SMR_D1_CHANGE_CODE_QTY_DECREASE  "QD"
#define SMR_D1_CHANGE_CODE_QTY_INCREASE  "QI"
#define SMR_D1_CHANGE_CODE_PRICE_CHANGE  "PC"
#define SMR_D1_CHANGE_CODE_REPLACE_ALL   "RZ"

#define SMR_15SPACES                     "               "
#define SMR_10SPACES                     "          "

#define LEN_BUYER_NAME                 120
#define LEN_BUYER_PHONE                 20
#define LEN_TERMS_CODE                  50

#define LEN_NEW_STORE_RUSH              10

#define LEN_SMR_ITEM_SKU_NMBR           11
#define LEN_SMR_ITEM_STORE_NMBR          9
#define LEN_SMR_DETAIL_REC_SUB_SEL       5
#define LEN_SMR_VPN                     15
#define LEN_SDQ_TEXT                     3
#define LEN_SDQ_SA_FILL                 92
#define LEN_SMR_ITEM_QTY                 7
#define LEN_SMR_PACK_QTY                 8
#define LEN_SMR_PACK_SUBLINE_QTY         9
#define LEN_QTY_LEFT_TO_RECEIVE          7
#define LEN_SMR_UNIT_COST               10
#define LEN_SMR_UPC                     15
#define LEN_SMR_RETAIL_PRICE_ID          3
#define LEN_SMR_RETAIL_PRICE            10
#define LEN_SMR_BUYER_COLOR_QUALIFIER    2
#define LEN_SMR_BUYER_COLOR_DESC        15
#define LEN_SMR_BUYER_SIZE_QUALIFIER     2
#define LEN_SMR_BUYER_SIZE_DESC         15
#define LEN_SMR_COMPARE_TO_PRICE_ID      3
#define LEN_SMR_COMPARE_TO_PRICE        10

#define LEN_SMR_BUYER_COLOR_DESC        15
#define LEN_SMR_BUYER_SIZE_DESC         15

#define LEN_SMR_CODE                    10
#define LEN_SMR_CODE_DESC               10
#define LEN_INTERFACE_ID                10

#define LEN_SMR_PROMO_QUALIFIER          3
#define LEN_CREATE_DATETIME             14
#define LEN_GROUP_ID                    40

#define NULL_SMR_WH_NAME          (LEN_SMR_WH_NAME + 1)
#define NULL_INTERFACE_ID         (LEN_INTERFACE_ID + 1)

#define NULL_SMR_ITEM_SKU_NMBR    (LEN_SMR_ITEM_SKU_NMBR + 1)
#define NULL_SMR_VPN              (LEN_SMR_VPN + 1)
#define NULL_SMR_UPC              (LEN_SMR_UPC + 1)

#define NULL_BUYER_NAME           (LEN_BUYER_NAME + 1)
#define NULL_BUYER_PHONE          (LEN_BUYER_PHONE + 1)
#define NULL_TERMS_CODE           (LEN_TERMS_CODE + 1)

#define NULL_NEW_STORE_RUSH       (LEN_NEW_STORE_RUSH + 1)

#define NULL_SMR_BUYER_COLOR_DESC (LEN_SMR_BUYER_COLOR_DESC+1)
#define NULL_SMR_BUYER_SIZE_DESC  (LEN_SMR_BUYER_SIZE_DESC+1)

#define NULL_SMR_CODE             (LEN_SMR_CODE + 1)
#define NULL_SMR_CODE_DESC        (LEN_SMR_CODE_DESC + 1)

#define NULL_SMR_PROMO_QUALIFIER  (LEN_SMR_PROMO_QUALIFIER + 1)

#define NULL_SMR_WH_NAME          (LEN_SMR_WH_NAME + 1)
#define NULL_INTERFACE_ID         (LEN_SMR_WH_NAME + 1)

#define LEN_FILE_NAME                    200
#define LEN_SMR_UOM_IDENTIFIER             2
#define NULL_SMR_UOM_IDENTIFIER         (LEN_SMR_UOM_IDENTIFIER + 1)

/* edidlord defines - might not be using much of this anymore */
#define LEN_FLAG_TYPE                      1
#define LEN_ORDER_CHG_TYPE                 2
#define LEN_PACK_SIZE                     12
#define LEN_PACK_TMPL_ID                   8
#define LEN_SUPP_PACK_TEMPL_DESC         250  /* NLS */
#define LEN_PACK_TYPE                      1
#define LEN_PURCHASE_TYPE                  6
#define LEN_TERMS_DES                    240
#define LEN_SHIP_METHOD                    6
#define LEN_MEASUREMENT                   12

#define NULL_FLAG_TYPE                  (LEN_FLAG_TYPE + 1)
#define NULL_ORDER_CHG_TYPE             (LEN_ORDER_CHG_TYPE + 1)
#define NULL_PACK_SIZE                  (LEN_PACK_SIZE + 1)
#define NULL_PACK_TMPL_ID               (LEN_PACK_TMPL_ID + 1)
#define NULL_SUPP_PACK_TEMPL_DESC       (LEN_SUPP_PACK_TEMPL_DESC + 1)
#define NULL_PACK_TYPE                  (LEN_PACK_TYPE + 1)
#define NULL_PURCHASE_TYPE              (LEN_PURCHASE_TYPE + 1)
#define NULL_TERMS_DES                  (LEN_TERMS_DES  + 1)
#define NULL_SHIP_METHOD                (LEN_SHIP_METHOD + 1)
#define NULL_MEASUREMENT                (LEN_MEASUREMENT + 1)
#define NULL_SUP_QTY_LEVEL                 7
#define NULL_SUP_PACK_SIZE                17

/* lengths for global variables */
#define LEN_ST_ARRAY                     250
#define LEN_QTY_DEC                        4
#define LEN_LONG_MESSAGE                 255
#define LEN_BULK_ORDER_PO                  6
#define LEN_NUM_HB_ORDER                   2
#define RECORD_LOCKED                     54


#define NULL_CREATE_DATETIME            (LEN_CREATE_DATETIME + 1)
#define NULL_GROUP_ID                   (LEN_GROUP_ID + 1)


/*------------------------------------------------------*\
* global variables                                       *
\*------------------------------------------------------*/

long    SQLCODE = 0;
long    sql_holder = 0;

char    restart_start_array[1][255];
char    restart_application_image_array[2][255];
char    restart_application_image[255];

extern  long g_l_rec_cnt;

long    pl_line_no = 0;
long    pl_tran_no = 0;
long    pl_no_of_lines = 0;
long    pl_no_tran_lines = 0;
long    pl_terms_count = 0;

int     pi_pkg_fail;
char    ps_error_message[256];

/*program variables*/
char    ps_restart_num_threads[NULL_THREAD];
char    ps_restart_thread_val[NULL_THREAD];
char    ps_restart_driver_name[MAX_DRIVER_NAME_LEN];
int     pi_qty_dec = LEN_QTY_DEC;       /* implied decimal places holder */
char    logmessage[LEN_LONG_MESSAGE];

/* init variable */
char    ps_vdate[NULL_DATE];
char    ps_multichannel_ind[NULL_IND];  /* system variable for multichannel Y or N */
char    ps_qty_type_flag[NULL_FLAG_TYPE];

char    ps_bk_wh[NULL_LOC];
char    ps_dd_wh[NULL_LOC];
char    ps_create_datetime[NULL_DATE];
char    ps_group_id[NULL_GROUP_ID];
char    ps_interface_id[NULL_INTERFACE_ID];

/* new - for updated restart/recovery */
init_parameter parameter[NUM_INIT_PARAMETERS] =
{
  /* Name -------------Type --------- Sub_type */
    "commit_max_ctr",       "uint",        "",
    "thread_val",   "string",      "",
    "num_threads",  "string",      "",
    "restartPoNmbr", "string",     "I"
};

/* Commit max counter used to for array fetch */
uint commitMaxCtr;

/* global variables for threading */
char restartThreadVal[NULL_THREAD];
char restartNumThreads[NULL_THREAD];

/* global variables for restart string */
char restartPO[NULL_ORDER_NO]="";

/* used to copy optional filename from program parameters */
char outFileNameParameter[LEN_OUTFILE_NAME] = "";

/* new - for update file write */
FILE *ediFilePtr;

/* new variables - output format strings */
char h1String[LEN_ST_ARRAY];
char h2String[LEN_ST_ARRAY];
char h3String[LEN_ST_ARRAY];
char h4String[LEN_ST_ARRAY];
char d1String860[LEN_ST_ARRAY];
char d2String[LEN_ST_ARRAY];
char d3String[LEN_ST_ARRAY];
char poVndpString[LEN_ST_ARRAY];
char h1String860[LEN_ST_ARRAY];
char h4String860[LEN_ST_ARRAY];

int po_seq = 0;
int ps_old_item = 0;
int ps_hb_release = 0;
int ps_hdr_record_id;
int recSequence;
int d1RecSequence;
int maxRevNo;

char recTypeDescH1[NULL_SMR_REC_TYPE1];
char recTypeDescH2[NULL_SMR_REC_TYPE1];
char recTypeDescH3[NULL_SMR_REC_TYPE1];
char recTypeDescH4[NULL_SMR_REC_TYPE1];
char recTypeDescD1[NULL_SMR_REC_TYPE1];
char recTypeDescD2[NULL_SMR_REC_TYPE1];
char recTypeDescD3[NULL_SMR_REC_TYPE1];
char recTypeDescD4[NULL_SMR_REC_TYPE1];
char recTypeDescVP[NULL_SMR_REC_TYPE1+1];

/* new variables - header record fields */
char orderNo[NULL_ORDER_NO];
char orderStatus[NULL_IND];
char orderLocation[NULL_LOC];
char supplier[NULL_SUPPLIER];
char dcStoreNumber[NULL_SMR_DC_STORE_NMBR];
char h4StoreNumber[NULL_SMR_DC_STORE_NMBR];
char shipToMarkFor[NULL_SMR_SHIP_TO_MARK_FOR];
char poNumber[NULL_SMR_PO_NMBR];
char masterPONumber[NULL_SMR_PO_NMBR];
char originalApproveDate[NULL_DATE];
char newNotBeforeDate[NULL_DATE];
char newNotAfterDate[NULL_DATE];
char orderChangeDate[NULL_DATE];
char orderDept[NULL_DEPT];
char buyer[NULL_BUYER];
char buyerName[NULL_BUYER_NAME];
char buyerPhone[NULL_BUYER_PHONE];
char termsCode[NULL_TERMS_CODE];
char promoQualifier[NULL_SMR_PROMO_QUALIFIER];
char promoStartDate[NULL_DATE];
char preMarkInd[NULL_IND];
char orderEDIPOInd[NULL_IND];
char orderQCInd[NULL_IND];
char edi850relInd[NULL_IND]; /*OLR v1.19 Inserted*/

char orderTotalQty[NULL_SMR_TOTAL_QTY_PO] = "";
char orderTotalQtyCancelled[NULL_SMR_TOTAL_QTY_PO];
char totalD1Qty[NULL_SMR_TOTAL_QTY_PO];
char qtyVPItem[NULL_SMR_TOTAL_QTY_PO];
char orderTotalQtyH1[NULL_SMR_TOTAL_QTY_PO] = "";
char orderAckRecvdInd[NULL_IND];
char lastSentRevNo[NULL_REV_NO];
char ordItemLocChangeCode[NULL_SMR_PO_CHANGE_CODE];
char poPurposeCode[NULL_SMR_PO_PURPOSE_CODE];
char woChange[NULL_IND];

char poType[NULL_SMR_PO_TYPE];

char poHeaderComments[NULL_SMR_COMMENTS];
char oldPoHeaderComments[NULL_SMR_COMMENTS];

char newStoreRushOrder[NULL_NEW_STORE_RUSH];

/* new variables - detail record fields */
char orderItem[NULL_ITEM];
char item[NULL_ITEM];
char itemSupVPN[NULL_VPN];
char qtyOrdered[NULL_QTY];
int  qtyOrderedWork;
int  orderTotalQtyWork;
int  qtyDiffOrdered;
char oldQtyOrdered[NULL_QTY];
char orderUnitRetail[NULL_AMT];
short orderUnitRetailInd;
char oldOrderUnitRetail[NULL_AMT];
char orderUnitCost[NULL_AMT];
char oldOrderUnitCost[NULL_AMT];
char holdOrderUnitCost[NULL_AMT];  /*OLR V1.29 Inserted*/
char upc[NULL_ITEM];
char itemColorDesc[NULL_SMR_BUYER_COLOR_DESC];
char itemSizeDesc[NULL_SMR_BUYER_SIZE_DESC];
char hbOrder[LEN_NUM_HB_ORDER];

/*OLR v1.19 Insert START*/
/* Variables to hold previous revision VPN/UPC/COLOR/SIZE values */
char oldItemSupVPN[NULL_VPN];
char oldItemColorDesc[NULL_SMR_BUYER_COLOR_DESC];
char oldItemSizeDesc[NULL_SMR_BUYER_SIZE_DESC];
char oldUPC[NULL_ITEM];

/* Variables to temporaily hold current VPN/UPC/COLOR/SIZE values */
/* These are used so we can display the old values in the delete item record when a UPC/VPN/DIFF changes */
char holdItemSupVPN[NULL_AMT];
char holdItemColorDesc[NULL_SMR_BUYER_COLOR_DESC];
char holdItemSizeDesc[NULL_SMR_BUYER_SIZE_DESC];
char holdUPC[NULL_ITEM];
char holdQtyOrdered[NULL_QTY];
/*OLR v1.19 Insert END*/

char itemMfgRecRetail[NULL_AMT];
char itemPackType[NULL_PACK_TYPE];

char itemTicketTypeId[NULL_SMR_CODE];
char itemTicketTypeDesc[NULL_SMR_CODE_DESC];
char itemHangerCode[NULL_SMR_CODE];
char itemHangerCodeDesc[NULL_SMR_CODE_DESC];

/* structure for retrieving alloc info associated with PO */
struct allocStruct
{
   char allocItem[NULL_ITEM];
   short allocItemInd;
   char oldAllocItem[NULL_ITEM];
   short oldAllocItemInd;
   char allocWh[NULL_LOC];
   short allocWhInd;
   char oldAllocWh[NULL_LOC];
   short oldAllocWhInd;
   char allocStore[NULL_LOC];
   short allocStoreInd;
   char oldAllocStore[NULL_LOC];
   short oldAllocStoreInd;
   char allocStoreName[NULL_SMR_STORE_NAME];
   char storeDefaultWh[NULL_LOC];
   short storeDefaultWhInd;
   char qtyAlloc[NULL_QTY];
   short qtyAllocInd;
   char oldQtyAlloc[NULL_QTY];
   short oldQtyAllocInd;
   char newStore[NULL_IND];
   short newStoreInd;
   char supVPN[NULL_VPN];
   short supVPNInd;
   char itemUnitRetail[NULL_AMT];
   short itemUnitRetailInd;
   char itemUnitCost[NULL_AMT];
   short itemUnitCostInd;
   char oldItemUnitCost[NULL_AMT];
   short oldItemUnitCostInd;
   char itemUPC[NULL_ITEM];
   short itemUPCInd;
   char itemPackType[NULL_IND];
   short itemPackTypeInd;
   char itemColorDesc[NULL_SMR_BUYER_COLOR_DESC];
   short itemColorDescInd;
   char itemSizeDesc[NULL_SMR_BUYER_SIZE_DESC];
   short itemSizeDescInd;
   char itemMfgRecRetail[NULL_AMT];
   short itemMfgRecRetailInd;
   /*OLR v1.19 Insert START*/
   char  oldSupVPN[NULL_VPN];
   short oldSupVPNInd;
   char  oldItemUPC[NULL_ITEM];
   short oldItemUPCInd;
   char  oldItemColorDesc[NULL_SMR_BUYER_COLOR_DESC];
   short oldItemColorDescInd;
   char  oldItemSizeDesc[NULL_SMR_BUYER_SIZE_DESC];
   short oldItemSizeDescInd;
   /*OLR v1.19 Insert END*/
} allocRec;

char totalQtyAlloc[NULL_QTY];
char totalQtyCancelledAlloc[NULL_QTY];

char orderHeaderChanged_char[NULL_IND];


/* new variables for query - null indicator */
short orderLocationInd;
short orderDeptInd;
short buyerInd;
short buyerNameInd;
short buyerPhoneInd;
short promoStartDateInd;
short lastSentRevNoInd;
short storeDefaultWhInd;

short poHeaderCommentsInd;
short oldPoHeaderCommentsInd;
short woChangeInd;

short itemSupVPNInd;
short upcInd;
short itemColorDescInd;
short itemSizeDescInd;
short itemMfgRecRetailInd;
short itemPackTypeInd;
short oldQtyOrderedInd;
short oldOrderUnitRetailInd;
short oldOrderUnitCostInd;

short oldItemSupVPNInd;
short oldUPCInd;
short oldItemColorDescInd;
short oldItemSizeDescInd;

short itemHangerCodeInd;
short itemHangerCodeDescInd;
short itemTicketTypeIdInd;
short itemTicketTypeDescInd;

/* process variables */
char ps_rowid[NULL_ROWID];

long pi_err_flag = 0;
long pl_sqlcode = 0;
int  pi_exception = 0;
char ps_err_msg[NULL_ERROR_MESSAGE] = "";

/*------------------------------------------------------*\
* function prototypes                                    *
\*------------------------------------------------------*/

int init(char* argv[]);
int process(void);
int final(void);

/* SMR function prototypes */
void formatH1(void);
void formatH2(void);
void formatH3(void);
void formatH4(void);
void formatD1(void);
void formatD2(void);
void formatD3(void);
void formatPOVNDP(void);

int writeH1(FILE *outRtkFilePtr);
int writeH2(FILE *outRtkFilePtr, char *sacCode, char *sacDesc);
/* int writeH3(FILE *outRtkFilePtr);                                        */
/* int writeH3_All_POs(FILE *outRtkFilePtr);                                */
/* int writeH3_QCInd(FILE *outRtkFilePtr);                                  */
int writeH4(FILE *outRtkFilePtr);
int oldwriteD1(FILE *outRtkFilePtr);
int writeD1(FILE *outRtkFilePtr);
int writeD2(FILE *outRtkFilePtr);
int writeD3(FILE *outRtkFilePtr);
int writeD4(FILE *outRtkFilePtr);
int writePOVNDP(FILE *outRtkFilePtr);

int getMaxRevNo(void);
int insertPOAllocRevInfo(void);

int processBKD1rec(void);
int processRLD1rec(void);

char d3StoreNumber[NULL_SMR_DC_STORE_NMBR];
char UOM_D3[NULL_SMR_UOM_IDENTIFIER];

/*------------------------------------------------------*\
* function main()                                        *
\*------------------------------------------------------*/

int main(int argc, char* argv[])
{
   char* function = "main";
   int   li_init_results;
   char  ls_log_message[NULL_ERROR_MESSAGE];
   int   li_final_return;
   if (argc < 2)
   {
      fprintf(stderr,"Usage: %s userid/passwd outfilename(optional)\n",argv[0]);
      return(FAILED);
   }

   if (LOGON(argc, argv) < 0)
   {
      return(FAILED);
   }

   if (argc == 3)
      strcpy(outFileNameParameter,argv[2]);

   if ((li_init_results = init(argv)) < 0)
      gi_error_flag = 2;
   if (li_init_results != NO_THREAD_AVAILABLE)
   {
      if (li_init_results == OK)
      {
         if (process() < 0)
            gi_error_flag = 1;
      }

      if (final() < 0)
      {
         if (gi_error_flag == 0)
            gi_error_flag = 3;
      }
   }

   if (gi_error_flag == 2)
   {
      LOG_MESSAGE("Aborted in init");
      li_final_return = FAILED;
   }
   else if (gi_error_flag == 1)
   {
      sprintf(ls_log_message,"Thread %s - Aborted in process",restartThreadVal);
      LOG_MESSAGE(ls_log_message);
      li_final_return = FAILED;
   }
   else if (gi_error_flag == 3)
   {
      sprintf(ls_log_message,"Thread %s - Aborted in final",restartThreadVal);
      LOG_MESSAGE(ls_log_message);
      li_final_return = FAILED;
   }
   else if (li_init_results == NO_THREAD_AVAILABLE)
   {
      LOG_MESSAGE("Terminated - No threads available");
      li_final_return = NO_THREADS;
   }
   else
   {
      sprintf(ls_log_message,"Thread %s - Terminated Successfully",restartThreadVal);
      LOG_MESSAGE(ls_log_message);
      li_final_return = SUCCEEDED;
   }

   return(li_final_return);

}  /* End of main() */


/*------------------------------------------------------*\
* function init()                                        *
\*------------------------------------------------------*/

int init(char* argv[])
{
   char *function_name = "init";
   char ls_thread[NULL_THREAD];
   int restartInitResults;

   char    fileName[LEN_OUTFILE_NAME];

   /* variables for date time stamp */
   time_t currentTime;
   struct tm *timeInfo;
   char timeString[20];

/**   char* homeDir = getenv("MMOUT"); **/
   char* homeDir = "/tmp";

   EXEC SQL DECLARE c_date_sys_options CURSOR FOR
      SELECT TO_CHAR(p.vdate,'YYYYMMDDHH24MISS'),
             so.multichannel_ind
        FROM period p,
             system_options so;

   EXEC SQL DECLARE c_count_terms CURSOR FOR
      SELECT count(terms)
        FROM terms;

   EXEC SQL DECLARE c_int_type CURSOR FOR
      SELECT to_char(interface_id)
        FROM smr_rms_int_type
       WHERE interface_name = 'EDI_850_860';
   
   /* get date and timestamp for filename */
   time(&currentTime);
   timeInfo = localtime(&currentTime);
   strftime(timeString, sizeof(timeString), "%Y%m%d%H%M%S", timeInfo);

   #ifdef DEBUG
   printf("Current system date time string is <%s>\n",timeString);
   #endif

   /* setup file names - check if output file name passed as parameter */
   if (strcmp(outFileNameParameter,"") == 0)
      sprintf(fileName, "%s/%s_%s.dat", homeDir, "RMSPOC", timeString);
   else
      sprintf(fileName, "%s/%s", homeDir, outFileNameParameter);


   #ifdef DEBUG
   printf("Output EDI filename is <%s>\n",fileName);
   #endif

   #ifdef DEBUG
   printf("open file\n");
   #endif
   ediFilePtr = fopen(fileName,"w");
   if (ediFilePtr == (FILE *)NULL)
   {
      strcpy(err_data, "Failed opening file");
      strcpy(table, "period, system_options");
      WRITE_ERROR(RET_FUNCTION_ERR,function_name,"",err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("initialize restart process next\n");
   #endif
   /* initialize restart recovery information */
   restartInitResults = retek_init(NUM_INIT_PARAMETERS,
                                   parameter,
                                   &commitMaxCtr,
                                   restartThreadVal,
                                   restartNumThreads,
                                   restartPO);

   #ifdef DEBUG
   printf("look at file pointer next\n");
   printf("File pointer is <%ld>\n",ftell(ediFilePtr));
   #endif

   if (restartInitResults != 0)
       return(restartInitResults);

   if (commitMaxCtr > MAX_ORACLE_ARRAY_SIZE)
   {
      commitMaxCtr = MAX_ORACLE_ARRAY_SIZE;
      if (limit_commit_max_ctr(commitMaxCtr) < 0)
         return (FATAL);
   }

   /* setup output format strings */
   #ifdef DEBUG
   printf("Setup format strings next\n");
   #endif
   formatH1();
   formatH2();
   formatH3();
   formatH4();
   formatD1();
   formatD2();
   formatD3();
   formatPOVNDP();

   #ifdef DEBUG
   printf("Get vdate next\n");
   #endif
   EXEC SQL OPEN c_date_sys_options;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_date_sys_options");
      strcpy(table, "period, system_options");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }
   EXEC SQL FETCH c_date_sys_options INTO :ps_vdate,
                                          :ps_multichannel_ind;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=c_date_sys_options");
      strcpy(table, "period, system_options");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("Get terms next\n");
   #endif
   EXEC SQL OPEN c_count_terms;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_count_terms");
      strcpy(table, "terms");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }
   EXEC SQL FETCH c_count_terms INTO :pl_terms_count;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=c_count_terms");
      strcpy(table, "terms");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

/*---------------------------------------------------------------------------*\
  get interface_id
\*---------------------------------------------------------------------------*/
   #ifdef DEBUG
   printf("Get interface_id next\n");
   #endif
   EXEC SQL OPEN c_int_type;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=c_int_type");
      strcpy(table, "smr_rms_int_type");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }
   EXEC SQL FETCH c_int_type INTO :ps_interface_id;
   if (SQL_ERROR_FOUND || NO_DATA_FOUND)
   {
      strcpy(err_data, "CURSOR FETCH: cursor=c_int_type");
      strcpy(table, "smr_rms_int_type");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }


   return(OK);
}/* end init */

void formatH1(void)
{
        strcpy(h1String860,"%-*s"); /* Record type 1 */
        strcat(h1String860,"%-*s"); /* Record type 2 */
        strcat(h1String860,"%0*d"); /* Record sequence */
        strcat(h1String860,"%0*d      "); /* Trading partner id */
        strcat(h1String860,"%0*d");  /* Company id */
        strcat(h1String860,"%-*s");  /* PO type */
        strcat(h1String860,"%0*d");  /* PO number */
        strcat(h1String860,"%-*s");  /* PO purpose code */
        strcat(h1String860,"%0*d");  /* DC store number */
        strcat(h1String860,"%-*s");  /* Master po number */
        strcat(h1String860,"%-*s");  /* Vendor number ref */
        strcat(h1String860,"%0*d");  /* Vendor number */
        strcat(h1String860,"%-*s");  /* Department number ref */
        strcat(h1String860,"%0*d");  /* Department number */
        strcat(h1String860,"%-*s");  /* Buyer number ref */
        strcat(h1String860,"%0*d");  /* Buyer number */
        strcat(h1String860,"%-*s");  /* Delivery instructions */
        strcat(h1String860,"%-*s");  /* Discount description */
        strcat(h1String860,"%0*d");  /* Total qty PO */
        strcat(h1String860,"%-*s");  /* PO date */
        strcat(h1String860,"%-*s");  /* PO Change date */
        strcat(h1String860,"%-*s");  /* PO requested ship */
        strcat(h1String860,"%-*s");  /* PO ship date     */
        strcat(h1String860,"%-*s");  /* PO cancel after */
        strcat(h1String860,"%-*s");  /* PO cancel date */
        strcat(h1String860,"\n");
}

void formatH2(void)
{
   strcpy(h2String,"%-*s"); /* Record type 1 */
   strcat(h2String,"%-*s"); /* Record type 2 */
   strcat(h2String,"%0*d");        /* Record sequence */
   strcat(h2String,"%0*d      ");  /* Trading partner id */
   strcat(h2String,"%0*d");        /* Company id */
   strcat(h2String,"%0*d");        /* PO number */
   strcat(h2String,"%0*d");        /* Store */
   strcat(h2String,"%-*s");        /* Charge Indicator */
   strcat(h2String,"%-*s");        /* Vics */
   strcat(h2String,"%-*s");        /* New Store Rush Order */
   strcat(h2String,"%-*s");        /* Sac Description */
   strcat(h2String,"\n");

}

void formatH3(void)
{
   strcpy(h3String,"%-*s"); /* Record type 1 */
   strcat(h3String,"%-*s"); /* Record type 2 */
   strcat(h3String,"%0*d");        /* Record sequence */
   strcat(h3String,"%0*d      ");  /* Trading partner id */
   strcat(h3String,"%0*d");        /* Company id */
   strcat(h3String,"%0*d");        /* PO number */
   strcat(h3String,"%0*d");        /* Store */
   strcat(h3String,"%-*s");        /* Description Type */
   strcat(h3String,"%-*s");        /* PO Header Comments */
   strcat(h3String,"\n");

}

void formatH4(void)
{

      strcpy(h4String860,"%-*s"); /* Record type 1 */
      strcat(h4String860,"%-*s");        /* Record type 2 */
      strcat(h4String860,"%0*d");        /* Record sequence */
      strcat(h4String860,"%0*d      ");        /* Trading partner id */
      strcat(h4String860,"%0*d");        /* Company id */
      strcat(h4String860,"%0*d");        /* PO number */
      strcat(h4String860,"%0*d");        /* Store */
      strcat(h4String860,"%-*s");        /* Ship to Mark for */
      strcat(h4String860,"%-*s");        /* Address 1 */
      strcat(h4String860,"%-*s");        /* Address 2 */
      strcat(h4String860,"%-*s");        /* City */
      strcat(h4String860,"%-*s");        /* State */
      strcat(h4String860,"%-*s");        /* Zip */
      strcat(h4String860,"%-*s");        /* Country */
      strcat(h4String860,"%-*s");        /* Warehouse Decription */
      strcat(h4String860,"\n");

}

/***************************************************************
* formatD1() -                                                 *
* output format for D1 record for 850 and 860 are different    *
****************************************************************/
void formatD1(void)
{
   /* format string for 860 */
   strcpy(d1String860,"%-*s");        /* Record type 1 */
   strcat(d1String860,"%-*s");        /* Record type 2 */
   strcat(d1String860,"%0*d");        /* Record sequence */
   strcat(d1String860,"%0*d      ");  /* Trading partner id */
   strcat(d1String860,"%0*d");        /* Company id */
   strcat(d1String860,"%0*d");        /* PO number */
   strcat(d1String860,"%0*d");        /* Store */
   strcat(d1String860,"%0*ld");       /* Item_sku_number */
   strcat(d1String860,"%0*d");        /* Detail Record Sub Seq */
   strcat(d1String860,"%-*s");        /* PO change code */
   strcat(d1String860,"%-*s");        /* Vendor Model Number */
   strcat(d1String860,"%0*d");        /* Ordered Quantity */
   strcat(d1String860,"%0*d");        /* Quantity left to receive */
   strcat(d1String860,"%0*ld");       /* Gross Unit Cost */
   strcat(d1String860,"%-*s");        /* UPC */
   strcat(d1String860,"%-*s");        /* Buyers Color Qualifier */
   strcat(d1String860,"%-*s");        /* Buyers Color Description */
   strcat(d1String860,"%-*s");        /* Buyers Size Qualifier */
   strcat(d1String860,"%-*s");        /* Buyers Size Description */
   strcat(d1String860,"%-*s");        /* Compare_to_price_id */
   strcat(d1String860,"%0*ld");       /* Compare_to_price */
   strcat(d1String860,"\n");
}

void formatD2(void)
{
   strcpy(d2String,"%-*s"); /* Record type 1 */
   strcat(d2String,"%-*s"); /* Record type 2 */
   strcat(d2String,"%0*d");        /* Record sequence */
   strcat(d2String,"%0*d      ");  /* Trading partner id */
   strcat(d2String,"%0*d");        /* Company id */
   strcat(d2String,"%0*d");        /* PO number */
   strcat(d2String,"%0*d");        /* Store */
   strcat(d2String,"%0*ld");        /* Item_sku_number */
   strcat(d2String,"%-*s");        /* UPC */
   strcat(d2String,"%-*s");        /* Vendor Model Number */
   strcat(d2String,"%0*d");        /* Detail Record Sub Set */
   strcat(d2String,"%-*s");        /* Charge Indicator */
   strcat(d2String,"%-*s");        /* Vics */
   strcat(d2String,"%-*s");        /* code - ticket or hanger */
   strcat(d2String,"%-*s");        /* code description - ticket or hanger */
   strcat(d2String,"\n");

}

/*---------------------------------------------------------------------------*\
  format D3 (SDQ rec)
\*---------------------------------------------------------------------------*/
void formatD3(void)
{
   strcpy(d3String,"%-*s");        /* Record type 1 */
   strcat(d3String,"%-*s");        /* Record type 2 */
   strcat(d3String,"%0*d");        /* Record sequence */
   strcat(d3String,"%0*d      ");  /* Trading partner id */
   strcat(d3String,"%0*d");        /* Company id */
   strcat(d3String,"%0*d");        /* PO number */
   strcat(d3String,"%0*d");        /* Store */
   strcat(d3String,"%0*ld");       /* Item_sku_number */
   strcat(d3String,"%-*s");        /* UPC */
   strcat(d3String,"%-*s");        /* Vendor Model Number */
   strcat(d3String,"%-*s");        /* SDQ text */
   strcat(d3String,"%-*s");        /* UOM identifier */
   strcat(d3String,"%0*d");        /* DC number */
   strcat(d3String,"%0*d");        /* Qty ordered */
   strcat(d3String,"%-*s");        /* SA Fill */
}


void formatPOVNDP(void)
{
   strcpy(poVndpString,"%-*s");        /* Record type 1 */
   strcat(poVndpString,"%0*d");        /* PO number */
   strcat(poVndpString,"%0*ld");       /* Vendor pack item number */
   strcat(poVndpString,"%0*ld");       /* Component item number */
   strcat(poVndpString,"%0*d");        /* Component item quantity */
   strcat(poVndpString,"\n");

}

/*------------------------------------------------------*\
* function process()                                     *
\*------------------------------------------------------*/

int process(void)
{
   char *function_name = "process";
   char  ls_backhaul_type[2] = "";
   short li_backhaul_type_ind;
   char  ls_old_terms[NULL_TERMS];
   char  ls_new_terms[NULL_TERMS];
   short li_old_terms_ind;

   char poFullAlloc[2] = "";
   char poStandAloneSDC[2] = "";

   EXEC SQL DECLARE cursorGetStdAloneSDC CURSOR FOR
   SELECT to_char(count(*))
     FROM ordhead oh,
          v_smr_stand_alone_wh wh
    WHERE wh.wh = oh.location
      and oh.order_no = TO_NUMBER(:orderNo);

   EXEC SQL DECLARE cursorPOInfo CURSOR FOR
    SELECT DISTINCT ROWIDTOCHAR(oh.rowid),
          oh.order_no,
          oh.status,
          to_char(oh.supplier),
          to_char(oh.orig_approval_date,'YYYYMMDD'),
          oh.dept,
          nvl(oh.buyer,d.buyer),
          CASE WHEN oh.not_before_date != ohr.not_before_date THEN to_char(oh.not_before_date,'YYYYMMDD') ELSE '00000000' END,
          CASE WHEN oh.not_after_date != ohr.not_after_date THEN to_char(oh.not_after_date,'YYYYMMDD') ELSE '00000000' END,
          to_char(ohr.rev_date,'YYYYMMDD'),
          oh.pre_mark_ind,
          substr(nvl(b.buyer_name,b1.buyer_name),1,60),
          nvl(b.buyer_phone,b1.buyer_phone),
          case when ohr.terms != oh.terms then substr(t.terms_code,1,30)
               else '                              '
               end terms_code,
          to_char(p.start_date, 'YYYYMMDD'),
          oh.location,
          to_char(d.total_po_qty),
          oh.edi_po_ind,
          oh.po_ack_recvd_ind,
          substr(trim(REPLACE(oh.comment_desc, chr(10), null)),1,50),
          substr(trim(REPLACE(ohr.comment_desc, chr(10), null)),1,50),
          soe.last_extract_rev_no,
          decode(nvl(f.order_no,0),0,'N','Y'),
          ohr2.rev_no,
          oh.qc_ind,
          soe.wo_860_update_ind,
          nvl(soe.extract_850_rel_ind,'N') 
     FROM ordhead oh,
          smr_ord_extract soe,
          ordhead_rev ohr,
          ordhead_rev ohr2,
          sups s,
          buyer b,
          terms_head t,
          rpm_promo p,
          deps d,
          buyer b1,
          (select sum(total_po_qty) total_po_qty ,order_no from(
            select b.order_no, sum( qty_ordered*pack_qty) total_po_qty         -- for B Packs
            from packitem a,  ordloc b,  ordsku c,item_master i
           where b.item = c.item
             and a.pack_no = c.item
             and i.item= c.item
             and i.pack_ind = 'Y'
             and i.pack_type = 'B'
             and b.qty_ordered > 0
             and b.order_no = c.order_no
           group by b.order_no
           union                                                               -- for non Packs and V Packs
           select order_no, sum(qty_ordered) total_po_qty
             from ordloc b,item_master i
            where b.item = i.item
              and ((i.pack_ind = 'N') or (i.pack_ind = 'Y' and i.pack_type = 'V'))
              and b.qty_ordered > 0
            group by order_no
             UNION
              SELECT DISTINCT ORDER_NO, 0 TOTAL_PO_QTY
                FROM ORDHEAD
               WHERE STATUS = 'C'
             ) group by order_no ) d,
          /*Get orders that were fully allocated, but now have 0 quantity - for cancel of release*/
          /*FULLY ALLOCATED*/
          (select soe.order_no
             from smr_ord_extract soe,
                  ordhead oh
            where oh.order_no = soe.order_no
              and ((EXTRACT_850_REL_IND = 'Y'
              and not exists (select 'x'
                                from v_smr_unallocated_order v_suo
                               where v_suo.order_no = soe.order_no))
               or (EXTRACT_850_IND = 'Y'
              and  oh.location in (select location from wh_attributes where wh_type_code = 'PA'))) /* holdback put-away */
              and length(soe.order_no) = SMR_LEAP_INTERFACE_SQL.GET_CONSTANT_VALUE('SMR_LEAP_INTERFACE_SQL.SPLIT_PO_ORDER_LENGTH')) f,
          v_restart_supplier v
        WHERE ohr.order_no = oh.order_no
          AND ohr.rev_no = soe.last_extract_rev_no
          AND ohr2.order_no = oh.order_no
          AND ohr2.rev_no = (select max(rev_no) from ordhead_rev r
                              where r.order_no = oh.order_no)
          AND oh.order_no = soe.order_no
          /* if approved or closed and had sent PO previously */
          AND (oh.status = 'A'
               OR (oh.status = 'C' AND soe.last_extract_rev_no IS NOT NULL))
          AND ohr2.rev_no > soe.last_extract_rev_no
          /* do not pull orders that already have receipts */
          AND NOT EXISTS (select 'Y' from ordloc l
                           where l.order_no = oh.order_no and l.qty_received > 0)
            /*do not pull order if ASN exists * /
            AND NOT EXISTS (select 'Y' from shipment sh     
                           where sh.order_no = oh.order_no) 
            /*do not pull order if received shipment exists */
            AND NOT EXISTS (select 'Y' 
                              from shipment sh, 
                                   shipsku sk     
                             where sh.shipment = sk.shipment
                               and sh.order_no is not null
                               and sh.order_no = oh.order_no
                               and nvl(sk.qty_received,0) > 0) 
          /* cannot extract if no location specified on header for PO - sometimes
             order created incorrectly from allocation that is problem             */
          AND oh.location is not null
          /* no DSW POs */
          AND oh.dept not in (592)
          AND oh.supplier = s.supplier
          AND oh.buyer = b.buyer(+)
          AND oh.terms = t.terms
          AND oh.promotion = p.promo_id(+)
          AND oh.order_no = d.order_no
          AND oh.order_no = f.order_no(+)
          AND oh.dept = d.dept
          AND d.buyer = b1.buyer         
          /* restart recovery */
          and v.driver_value = oh.supplier 
          and v.num_threads = TO_NUMBER(:restartNumThreads)
          and v.thread_val = TO_NUMBER(:restartThreadVal)
      ORDER BY 2;

   EXEC SQL DECLARE c_lock_po CURSOR FOR
   SELECT 'x'
     FROM ordhead
    WHERE rowid = CHARTOROWID(:ps_rowid)
      FOR update nowait;

   EXEC SQL DECLARE cursorHbOrder CURSOR FOR
        SELECT to_char(count(*))
          FROM ordhead o,
               wh_attributes w
         WHERE o.order_no = TO_NUMBER(:orderNo)
       and w.wh = o.location
       and wh_type_code = 'PA'; /* put away */

   #ifdef DEBUG
   printf("Open cursorPOInfo next\n");
   #endif

   EXEC SQL OPEN cursorPOInfo;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorPOInfo");
      strcpy(table, "ordhead,ordhead_rev,sups,v_restart_supplier");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


   #ifdef DEBUG
   printf("Loop through fetches of cursorPOInfo next\n");
   #endif

   while (1)
   {
      EXEC SQL FETCH cursorPOInfo INTO  :ps_rowid,
                                        :orderNo,
                                        :orderStatus,
                                        :supplier,
                                        :originalApproveDate,
                                        :orderDept:orderDeptInd,
                                        :buyer:buyerInd,
                                        :newNotBeforeDate,
                                        :newNotAfterDate,
                                        :orderChangeDate,
                                        :preMarkInd,
                                        :buyerName:buyerInd,
                                        :buyerPhone:buyerPhoneInd,
                                        :termsCode,
                                        :promoStartDate:promoStartDateInd,
                                        :orderLocation:orderLocationInd,
                                        :orderTotalQty,
                                        :orderEDIPOInd,
                                        :orderAckRecvdInd,
                                        :poHeaderComments:poHeaderCommentsInd,
                                        :oldPoHeaderComments:oldPoHeaderCommentsInd,
                                        :lastSentRevNo:lastSentRevNoInd,
                                        :poFullAlloc,
                                        :maxRevNo,
                                        :orderQCInd,
                                        :woChange:woChangeInd,
                                        :edi850relInd; 

      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorPOInfo");
         strcpy(table, "ordhead,ordhead_rev,sups,v_restart_supplier");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

      ps_hdr_record_id = 0;

      #ifdef DEBUG
      printf("Lock PO next\n");
      #endif

      EXEC SQL OPEN c_lock_po;
      if SQL_ERROR_FOUND
      {
         if (SQLCODE == -1*RECORD_LOCKED)
            continue;
         else
         {
            strcpy(err_data, "CURSOR OPEN: cursor=c_lock_po");
            strcpy(table, "ordhead");
            WRITE_ERROR(SQLCODE,function_name,table,err_data);
            return(FATAL);
         }
      }


      /* update record descriptions appropriately for 860 */
      strcpy(recTypeDescH1,"S860H1");
      strcpy(recTypeDescH2,"S860H2");
      strcpy(recTypeDescH3,"S860H3");
      strcpy(recTypeDescH4,"S860H4");
      strcpy(recTypeDescD1,"S860D1");
      strcpy(recTypeDescD2,"S860D2");
      strcpy(recTypeDescD3,"S860D3");
      strcpy(recTypeDescD4,"S860D4");
      strcpy(recTypeDescVP,"S860VN");

      EXEC SQL OPEN cursorGetStdAloneSDC;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR OPEN: cursor=cursorGetStdAloneSDC, order_no=%s", orderNo);
         strcpy(table, "v_smr_stand_alone_wh");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorGetStdAloneSDC INTO :poStandAloneSDC;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR FETCH: cursor=cursorGetStdAloneSDC, order_no=%s", orderNo);
         strcpy(table, "v_smr_stand_alone_wh");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorGetStdAloneSDC;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorGetStdAloneSDC, order_no=%s", orderNo);
         strcpy(table, "v_smr_stand_alone_wh");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      
      EXEC SQL OPEN cursorHbOrder;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorHbOrder");
         strcpy(table, "ordhead,wh_attributes");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }

      EXEC SQL FETCH cursorHbOrder INTO :hbOrder;

      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorHbOrder");
         strcpy(table, "ordhead,wh_attributes");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }

      #ifdef DEBUG
      printf("hbOrder is %s next\n", hbOrder);
      printf("determine PO type \n");
      #endif

      
      /* determine PO type - bulk, stand alone, or alloc/release */
      if ((strcmp(poStandAloneSDC,"0") != 0) && (strlen(orderNo) < LEN_SMR_PO_NMBR))
         strcpy(poType,SMR_STANDALONE_PO_TYPE);
      else if (strcmp(poFullAlloc,"Y") == 0)
         strcpy(poType,SMR_ALLOC_PO_TYPE);
      else
         /*Only send bulk if release has not been sent*/
         if (strcmp(edi850relInd,"N") == 0)
         {
            strcpy(poType,SMR_BULK_PO_TYPE);
         }
         else
         {
	        /*Is a release change of a not fully allocated or cancelled order*/
	        continue;
         }

      #ifdef DEBUG
         printf("PO type is %s\n", poType);
      #endif
      strcpy( UOM_D3, "EA" ); /* default D3 to eaches */

      if (validatePO() == OK)
      {

         #ifdef DEBUG
         printf("RMS order <%s>\n", orderNo);
         printf("order location <%s>\n",orderLocation);
         #endif

         #ifdef DEBUG
         printf("File pointer is <%ld>\n",ftell(ediFilePtr));
         #endif


         /* figure out how to process the PO transaction */
         if (strcmp(poType,SMR_BULK_PO_TYPE) == 0 || strcmp(poType,SMR_STANDALONE_PO_TYPE) == 0)
         {

            if (processBulk() < OK)
               return(FATAL);
         }
         else if (strcmp(poType,SMR_ALLOC_PO_TYPE) == 0)
         {
            if (processAlloc() < OK)
               return(FATAL);
         }

      }
      else
      /* found problem with data;  write error and continue with processing other records */
      {
         return(FATAL);
      }

      #ifdef DEBUG
      printf("File pointer is <%ld>\n",ftell(ediFilePtr));
      #endif


      if (strcmp(orderEDIPOInd,"Y")==0)
      {
         /* update for EDI orders */
         EXEC SQL UPDATE ordhead
                     SET po_ack_recvd_ind = 'N',
                         edi_sent_ind = 'Y',
                         last_sent_rev_no = :maxRevNo
                   WHERE rowid = CHARTOROWID(:ps_rowid);

         if (SQL_ERROR_FOUND || NO_DATA_FOUND)
         {
            sprintf(err_data, "UPDATE: po_ack_recvd_ind='N' & edi_sent_ind='Y' for order no %s",
                    orderNo);
            strcpy(table, "ordhead");
            WRITE_ERROR(SQLCODE,function_name,table,err_data);
            return(-1);
         }
      }


      #ifdef DEBUG
      printf("%s -  update smr_ord_extract for bulk or stand alone order\n", function_name);
      #endif
/******************************************************************/
      /* update smr_ord_extract for bulk or stand alone order     */
          EXEC SQL UPDATE smr_ord_extract
                      SET last_extract_rev_no = :maxRevNo,
                          wo_860_update_ind = DECODE(:woChange,'Y','N',NULL),
                          last_update_id = user,
                          last_update_datetime = sysdate
                    WHERE order_no = TO_NUMBER(:orderNo);

          if (SQL_ERROR_FOUND || NO_DATA_FOUND)
          {
             sprintf(err_data, "UPDATE: last_extract_rev_no for order no %s", orderNo);
             strcpy(table, "smr_ord_extract");
             WRITE_ERROR(SQLCODE,function_name,table,err_data);
             return(FATAL);
          }

/************ Don't update for testing....................................*/
                           

      #ifdef DEBUG
      printf("process - before retek_force_commit for poNumber <%s>\n",poNumber);
      #endif

      #ifdef DEBUG
      printf("File pointer is <%ld>\n",ftell(ediFilePtr));
      #endif

      if (retek_force_commit(1, poNumber) < 0)
         return(FATAL);

   } /* end of po loop */

    return(OK);

} /* end process */

/**********************************************************************************/
/* processBulk() -
/* Do all of the steps to process a new bulk PO and create the output records */
/**********************************************************************************/
int processBulk()
{
   char *function_name = "processBulk";

   EXEC SQL DECLARE orderTotalQtyH1 CURSOR FOR
   select nvl(sum(new_ordered),0) from (
   select sum(or1.qty_ordered) new_ordered
     from v_ord_860_rev_dtl_smr or1,
          v_ord_860_rev_dtl_smr or2
    where or1.order_no = TO_NUMBER(:orderNo)
      and or1.order_no = or2.order_no
      and or1.location = or2.location
      and or1.item     = or2.item
      and or1.location not in (9521,9531,9541) 
      and or1.loc_type != 'S'
      and or1.rev_no = TO_NUMBER(:maxRevNo)
      and or2.rev_no =  TO_NUMBER(:lastSentRevNo)
      and or1.qty_ordered != or2.qty_ordered
    group by or1.order_no
    union all
   select sum(or1.qty_ordered) new_ordered
     from v_ord_860_rev_dtl_smr or1
    where or1.order_no = TO_NUMBER(:orderNo)
      and or1.location not in (9521,9531,9541) 
      and or1.loc_type != 'S'
      and or1.rev_no =  TO_NUMBER(:maxRevNo)
      and not exists (select 'x'
                        from v_ord_860_rev_dtl_smr or2
                       where or1.order_no = or2.order_no
                         and or1.location = or2.location
                         and or1.item     = or2.item
                         and or2.rev_no   = TO_NUMBER(:lastSentRevNo))
    UNION ALL
    select sum(or1.qty_ordered) new_ordered
      from v_ord_860_rev_dtl_smr or1,
           v_ord_860_rev_dtl_smr or2
           --
           ,ordcustom_rev         old_o
           ,ordcustom_rev         new_o
           --
     where or1.order_no = TO_NUMBER(:orderNo)
       and or1.order_no = or2.order_no
       and or1.location = or2.location
       and or1.item     = or2.item
       and or1.location not in (9521,9531,9541) 
       and or1.loc_type != 'S'
       and or1.rev_no = TO_NUMBER(:maxRevNo)
       and or2.rev_no =  TO_NUMBER(:lastSentRevNo)
       and or1.qty_ordered = or2.qty_ordered
       --
       and old_o.order_no = or1.order_no
       AND old_o.item     = or1.item
       AND old_o.order_no = new_o.order_no
       AND old_o.item     = new_o.item
       AND old_o.rev_no   = TO_NUMBER(:lastSentRevNo)
       AND new_o.rev_no   = TO_NUMBER(:maxRevNo)
       AND (NVL(old_o.VPN,'custom_860') != NVL(new_o.VPN,'custom_860')
            OR
            NVL(old_o.UPC,'custom_860') != NVL(new_o.UPC,'custom_860')
            OR
            NVL(old_o.diff_color,'custom_860') != NVL(new_o.diff_color,'custom_860')
            OR
            NVL(old_o.diff_size,'custom_860') != NVL(new_o.diff_size,'custom_860')
           )
    );

   EXEC SQL OPEN orderTotalQtyH1;
   if SQL_ERROR_FOUND
   {
     strcpy(err_data, "CURSOR OPEN: cursor=orderTotalQtyH1");
     strcpy(table, "ordhead,ordhead_item_master,v_ord_extract_dtl_smr");
     WRITE_ERROR(SQLCODE,function_name,table,err_data);
     return(FATAL);
   }

   EXEC SQL FETCH orderTotalQtyH1 INTO :orderTotalQtyH1;

   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR FETCH: cursor=orderTotalQtyH1");
      strcpy(table, "ordhead,ordhead_item_master,v_ord_extract_dtl_smr");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("orderTotalQtyH1 <%s> \n",orderTotalQtyH1);
   #endif

   EXEC SQL CLOSE orderTotalQtyH1;
   if SQL_ERROR_FOUND
   {
     strcpy(err_data, "CURSOR OPEN: cursor=orderTotalQtyH1");
     strcpy(table, "ordhead,ordhead_item_master,v_ord_extract_dtl_smr");
     WRITE_ERROR(SQLCODE,function_name,table,err_data);
     return(FATAL);
   }

   /* figure out DC Store Number field */
   if (strlen(orderLocation) > 3)
      strncpy(dcStoreNumber,orderLocation,3);
   else
      sprintf(dcStoreNumber,"%03d",atoi(orderLocation));

   /* store number for H4 record is same as dcStoreNumber always */
   strcpy(h4StoreNumber, dcStoreNumber);

   /* populate master po number - null/empty for bulk*/
   strcpy(masterPONumber,"");

   strcpy(shipToMarkFor,"ST");

   #ifdef DEBUG
   printf("write rec fields for H1 next\n");
   #endif

   recSequence = 1;

   /* create SMR EDI PO number cancatinate with first 3 digits of location */
   sprintf(poNumber,"%d%3s",atoi(orderNo), dcStoreNumber);

   #ifdef DEBUG
   printf("orderTotalQty <%s> \n",orderTotalQty);
   #endif

   /* Create PO purpose code for if PO quantity is 0 then PO purpose code
      will be 01 if PO quantity is greater than 0 PO purpose code will be 04
      for 860 files*/
   if(atoi(orderTotalQty)>0)
      strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_CHANGE);
   else
      strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_CANCEL);

   strcpy(orderTotalQty,orderTotalQtyH1);

   #ifdef DEBUG
   printf("poPurposeCode <%s> \n",poPurposeCode);
   printf("orderTotalQty <%s> \n",orderTotalQty);
   printf("orderTotalQtyH1 <%s> \n",orderTotalQtyH1);
   #endif

   /* BULK ORDERS H1 */
   /* write header records */
   if (writeH1(ediFilePtr) < OK)
      return(FATAL);
   recSequence++;

   /* if PO purpose code is for change process detail otherwise cancel
      and everything else is not necessary                             */
   if (strcmp(poPurposeCode,SMR_PO_PURPOSE_CD_CHANGE) == 0)
   {
      /* if work order change indicator is not null and yes send H2 recs */
      if (woChangeInd != -1 && strcmp(woChange, "Y") == 0)
      {
         if (processH2(ediFilePtr) < OK)
            return(FATAL);
      }

   /* Write H3 for All POs witht standard message  */
   /*   if (writeH3_All_POs(ediFilePtr) < OK)      */
   /*       return(FATAL);                         */

   /* Write H3 record with standard message if QC_IND on the order head is Y   */
   /* if (strcmp(orderQCInd,"Y")==0)                                           */
   /*   {                                                                      */
   /*   if (writeH3_QCInd(ediFilePtr) < OK)                                    */
   /*      return(FATAL);                                                      */
   /*   }                                                                      */

      #ifdef DEBUG
      printf("poHeaderCommentsInd is %d\n", poHeaderCommentsInd);
      #endif

      /* if header comments different                                          */
      /* if (strcmp(oldPoHeaderComments,poHeaderComments))                     */
      /*{                                                                      */
      /* if (writeH3(ediFilePtr) < OK)                                         */
      /*      return(FATAL);                                                   */
      /*   recSequence++;                                                      */
      /*}                                                                      */

      /* only output H4 records for stand alone orders */
      /* H4 record not needed for changes to stand alone order */

      recSequence = 0;

      if (processBulkDetail() < OK)
         return(FATAL);
   }

   return(OK);
}


/**********************************************************************************/
/* processAlloc() -                                                               */
/* Do all of the steps to process a alloc PO and create the output records        */
/**********************************************************************************/
int processAlloc()
{
   char *function_name = "processAlloc";

   char currentStore[NULL_LOC] = "";

   /* track current item so can increment d1RecSequence correctly */
   char currentItem[NULL_ITEM] = "";

   #ifdef DEBUG
   printf("processAlloc - starting processing of Allocation\n");
   #endif

   recSequence = 1;

   /* gets detail for SMR release order type;  uses a view
      v_ord_alloc_extract_dtl_860 that has embedded logic for getting correct
      unit cost and ref item for buyer packs which are exploded to pack item
      detail;  this simplifies query here and allows me to use subquery in
      select fields                                                             */
   /* second part of query after union is to get allocation/release po info
      no longer on current allocation                                           */
   EXEC SQL DECLARE cursorAlloc CURSOR FOR
      SELECT distinct v.item,
             h.item old_item,
             v.wh,
             h.wh old_wh,
--             v.to_loc,
--             h.alc_to_loc old_to_loc,
--             substr(st.store_name,1,25),
--             st.default_wh,
             to_char(sum(v.qty_allocated)),
             to_char(sum(h.qty_allocated)),
--             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N') newstore,
             substr(sp.vpn,1,15),
             to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,
             to_char(v.unit_cost*10000) unit_cost,
             to_char(r.unit_cost*10000) old_unit_cost,
             CASE WHEN v.ref_item is not NULL
                  THEN LPAD(SUBSTR(NVL(v.ref_item,u.item),1,15),15,'0')
                  ELSE DECODE(u.item_number_type,'SMRBC','               ', LPAD(nvl(u.item,'               '),15,'0'))  
             END upc,
             v.pack_type,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(im.mfg_rec_retail*10000) mfg_rec_retail
             ,substr(ordcustom_rev.vpn,1,15)
             ,nvl(lpad(substr(ordcustom_rev.upc,1,15),15,'0'),'               ')
             ,substr(ordcustom_rev.diff_color,1,15)
             ,substr(ordcustom_rev.diff_size,1,15)
        from v_ord_alloc_extract_dtl_860 v,
--             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds,
             smr_edi_ord_extract_hist h,
             v_ord_860_rev_dtl_smr r
            ,(select order_no, item, vpn, upc, diff_color, diff_size
                from ordcustom_rev
               where order_no = TO_NUMBER(:orderNo)
                 and rev_no = TO_NUMBER(:lastSentRevNo)) ordcustom_rev
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
--             and v.to_loc = st.store
             and v.item = sp.item
             and v.item = il.item
--             and v.to_loc = il.loc
               and il.loc = v.wh
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier 
             and oh.order_no = v.order_no 
             and v.order_no = h.order_no(+)
             and v.item = h.item(+)
--             and v.to_loc = h.alc_to_loc(+)
             and h.rev_no(+) = TO_NUMBER(:lastSentRevNo)
             and v.order_no = r.order_no(+)
             and v.item = r.item(+)
             and v.wh = r.location(+)
             and r.rev_no(+) = TO_NUMBER(:lastSentRevNo)
/*** do not include new store on alloc - should go through 850 
             and exists (select 'y' from smr_edi_ord_extract_hist x
                          where x.order_no = v.order_no and x.alc_to_loc = v.to_loc)
***/                          
             and v.item = ordcustom_rev.item         (+)
             and v.item = ordcustom_rev.item         (+)
    GROUP BY v.item, v.ref_item, u.item_number_type, u.item, h.item, v.wh, h.wh, 
--              v.to_loc, h.alc_to_loc, substr(st.store_name,1,25), st.default_wh, 
 --             to_char(h.qty_allocated),
--              DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N'),
             substr(sp.vpn,1,15),  /*OLR v1.19 Updated*/
             to_char(NVL(il.unit_retail,0.000001)*10000), to_char(v.unit_cost*10000),
             to_char(r.unit_cost*10000), nvl(v.ref_item,u.item), v.pack_type,
             substr(dc.diff_desc,1,15), substr(ds.diff_desc,1,15),
             to_char(im.mfg_rec_retail*10000)
             ,substr(ordcustom_rev.vpn,1,15)
             ,nvl(lpad(substr(ordcustom_rev.upc,1,15),15,'0'),'               ')
             ,ordcustom_rev.diff_color
             ,ordcustom_rev.diff_size
      HAVING sum(v.qty_allocated) + nvl(sum(h.qty_allocated),0) > 0
    UNION
    /* Get deleted items ...*/
    SELECT distinct NULL,
           h.item,
           NULL,
           h.wh,
--           h.alc_to_loc,
--           h.alc_to_loc,
--           substr(st.store_name,1,25) store_name,
--           st.default_wh,
             NULL,
            to_char(sum(h.qty_allocated)) qty_allocated,
--           NULL,
           substr(isp.vpn,1,15) vpn,
           to_char(NVL(il.unit_retail,0.000001)*10000) unit_retail,
           to_char(nvl(ol.unit_cost, ils.unit_cost) * 10000) unit_cost,
           NULL old_unit_cost,
           nvl(lpad(nvl(os.ref_item,im2.item),15,'0'),'               ') upc,
           NULL pack_type,
           substr(dc.diff_desc,1,15) color_desc,
           substr(ds.diff_desc,1,15) size_desc,
           to_char(im.mfg_rec_retail*10000) mfg_rec_retail,
           substr(oc_r.vpn,1,15)                     vpn,
           nvl(lpad(oc_r.upc,15,'0'),'               ')        upc,
           substr(oc_r.DIFF_COLOR,1,15) color_desc,
           substr(oc_r.DIFF_SIZE ,1,15) size_desc
      FROM smr_edi_ord_extract_hist h,
           ordhead                  oh,
           item_supplier            isp,
--           store                    st,
           item_loc_soh             ils,
           item_loc                 il,
           (select item, decode(unit_cost,0,null, unit_cost) unit_cost from ordloc where order_no = TO_NUMBER(:orderNo)) ol,
           (select item, ref_item ref_item from ordsku where order_no = TO_NUMBER(:orderNo)) os,
           item_master im,
           (select item, item_parent
              from item_master
             where primary_ref_item_ind = 'Y'
               and item_number_type != 'SMRBC') im2,
            (select i.item, c.diff_desc
               from item_master i, diff_ids c
              where c.diff_type = 'C'
                and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                     or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
            (select i.item, s.diff_desc
               from item_master i, diff_ids s
              where s.diff_type = 'S'
                and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                     or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds,
            (select order_no, item, vpn, upc, diff_color, diff_size from ordcustom_rev where order_no = TO_NUMBER(:orderNo) and rev_no =  TO_NUMBER(:lastSentRevNo)) oc_r
     WHERE h.order_no = TO_NUMBER(:orderNo)
       and h.order_no = oh.order_no
       and h.order_no = oc_r.order_no (+)
       and h.item     = oc_r.item (+)
       and oh.supplier = isp.supplier
       and h.item = isp.item
       and h.item = ils.item
--       and st.store = ils.loc
         and ils.loc = h.wh
       and h.item = ol.item (+)
       and h.item = os.item (+)
       and im.item = h.item
       and im.item = dc.item (+)
       and im.item = ds.item (+)
       and ils.item = il.item
       and ils.loc  = il.loc
       and im.item = im2.item_parent (+)
       --
       and h.rev_no = TO_NUMBER(:lastSentRevNo)
/* move below to loc cur */
       and not exists (select 'y' from v_ord_alloc_extract_dtl_860 vs
                        where vs.order_no = h.order_no 
                          and vs.to_loc = h.alc_to_loc 
                          and vs.item = h.item)
/********
       and h.alc_to_loc = st.store
       and nvl(h.qty_allocated,0) > 0 
*********/       
GROUP BY h.item,
           h.wh,
           substr(isp.vpn,1,15) ,
           to_char(NVL(il.unit_retail,0.000001)*10000) ,
           to_char(nvl(ol.unit_cost, ils.unit_cost) * 10000) ,
           nvl(lpad(nvl(os.ref_item,im2.item),15,'0'),'               ') ,
           substr(dc.diff_desc,1,15) ,
           substr(ds.diff_desc,1,15) ,
           to_char(im.mfg_rec_retail*10000) ,
           substr(oc_r.vpn,1,15)                     ,
           nvl(lpad(oc_r.upc,15,'0'),'               ')        ,
           substr(oc_r.DIFF_COLOR,1,15) ,
           substr(oc_r.DIFF_SIZE ,1,15) 
      HAVING nvl(sum(h.qty_allocated),0) > 0           
      ORDER BY 1;

/*    ORDER BY 5,6,1; /* order by to location and item -
                      needed to create new PO 850 trans for each to loc and
                      to reset d1RecSequence correctly for each item on order */

   /* did a seperate query to pull total allocation quantity for H1 rec */
   EXEC SQL DECLARE cursorAllocPOTotal CURSOR FOR
     --SELECT nvl(qty_allocated_diff ,0) FROM (      
     SELECT sum(nvl(qty_allocated_diff ,0)) FROM (   
        select sum(current_val.qty_allocated) qty_allocated_diff
         from
              (
              select item,
                     sum(qty_allocated) qty_allocated
                from smr_edi_ord_extract_hist
                where order_no = TO_NUMBER(:orderNo)
--                  and alc_to_loc = TO_NUMBER(:allocRec.allocStore)
                  and rev_no = TO_NUMBER(:lastSentRevNo)
                  group by item
               ) hist,
              (
              select nvl(pb.item, ah.item) item, sum(ar.qty_allocated * nvl(pb.pack_item_qty,1)) qty_allocated
                from alloc_header ah,
                     alloc_rev ar,
                     (select pb.pack_no, pb.item, pb.pack_item_qty
                        from item_master im,
                             packitem_breakout pb
                       where im.item = pb.pack_no
                         and im.pack_type = 'B') pb
               where ah.order_no = TO_NUMBER(:orderNo)
                 and ah.alloc_no = ar.alloc_no
--                 and ar.location = TO_NUMBER(:allocRec.allocStore)
                 and ar.rev_no = TO_NUMBER(:maxRevNo)
              and ah.item = pb.pack_no (+)
               group by nvl(pb.item, ah.item)
               ) current_val
         where current_val.item = hist.item (+)
           and nvl(current_val.qty_allocated,0) != 0 /* ignore deleted */
           and nvl(current_val.qty_allocated,0) != nvl(hist.qty_allocated,0) /*must be changed */
       UNION ALL
        select sum(current_val.qty_allocated) qty_allocated_diff
         from
              (
              select item,
                     sum(qty_allocated) qty_allocated
                from smr_edi_ord_extract_hist
                where order_no = TO_NUMBER(:orderNo)
--                  and alc_to_loc = TO_NUMBER(:allocRec.allocStore)
                  and rev_no = TO_NUMBER(:lastSentRevNo)
                  group by item
               ) hist,
              (
              select nvl(pb.item, ah.item) item, sum(ar.qty_allocated * nvl(pb.pack_item_qty,1)) qty_allocated
                from alloc_header ah,
                     alloc_rev ar,
                     (select pb.pack_no, pb.item, pb.pack_item_qty
                        from item_master im,
                             packitem_breakout pb
                       where im.item = pb.pack_no
                         and im.pack_type = 'B') pb
               where ah.order_no = TO_NUMBER(:orderNo)
                 and ah.alloc_no = ar.alloc_no
--                 and ar.location = TO_NUMBER(:allocRec.allocStore)
                 and ar.rev_no = TO_NUMBER(:maxRevNo)
              and ah.item = pb.pack_no (+)
               group by nvl(pb.item, ah.item)
               ) current_val
               --
               ,ordcustom_rev         old_o
               ,ordcustom_rev         new_o
               --               
         where current_val.item = hist.item 
           and nvl(current_val.qty_allocated,0) != 0 /* ignore deleted */
           and nvl(current_val.qty_allocated,0) = nvl(hist.qty_allocated,0) /*must NOT be changed */
           --
           and old_o.order_no = TO_NUMBER(:orderNo)
           AND old_o.item     = hist.item
           AND old_o.order_no = new_o.order_no
           AND old_o.item     = new_o.item
           AND old_o.rev_no   = TO_NUMBER(:lastSentRevNo)
           AND new_o.rev_no   = TO_NUMBER(:maxRevNo)
           AND (NVL(old_o.VPN,'custom_860') != NVL(new_o.VPN,'custom_860')
                OR                                
                NVL(old_o.UPC,'custom_860') != NVL(new_o.UPC,'custom_860')
                OR  
                NVL(old_o.diff_color,'custom_860') != NVL(new_o.diff_color,'custom_860')
                OR                                       
                NVL(old_o.diff_size,'custom_860') != NVL(new_o.diff_size,'custom_860')
               )             
       ); 

      /* Query to pull total allocation quantity cancelled for H1 rec */
      EXEC SQL DECLARE cursorAllocPOTotal_cancelled CURSOR FOR
     SELECT nvl(qty_allocated_diff ,0) FROM (
        SELECT ABS( sum(current_val.qty_allocated) ) qty_allocated_diff
          FROM
              (
              SELECT nvl(pb.item, ah.item) item, sum(ar.qty_allocated * nvl(pb.pack_item_qty,1)) qty_allocated
                FROM alloc_header ah,
                     alloc_rev ar,
                     (SELECT pb.pack_no, pb.item, pb.pack_item_qty
                        FROM item_master im,
                             packitem_breakout pb
                       WHERE im.item = pb.pack_no
                         AND im.pack_type = 'B') pb
               WHERE ah.order_no = TO_NUMBER(:orderNo)
                 AND ah.alloc_no = ar.alloc_no
--                 AND ar.location = TO_NUMBER(:allocRec.allocStore)
                 AND ar.rev_no = TO_NUMBER(:maxRevNo)
                 AND ah.item = pb.pack_no (+)
               GROUP BY nvl(pb.item, ah.item)
               ) current_val);

   /* returns Y if order has changed */
   EXEC SQL DECLARE cursor_Order_Header_Changed CURSOR FOR
   SELECT decode(count(*),0,'N','Y')
     FROM ordhead_rev ohr,  --current revision
          ordhead_rev ohr2, --max revision
          smr_ord_extract soe
    WHERE ohr.order_no = ohr2.order_no
      AND ohr.order_no = soe.order_no
      AND ohr.order_no = TO_NUMBER(:orderNo)
      AND ohr.rev_no   = TO_NUMBER(:lastSentRevNo)
      AND ohr2.rev_no  > 0
      AND ohr2.rev_no  = TO_NUMBER(:maxRevNo)
      AND (
             (     nvl(ohr.NOT_BEFORE_DATE  ,to_date('01-Jan-1900','DD-Mon-YYYY')           )  !=  nvl(ohr2.NOT_BEFORE_DATE ,to_date('01-Jan-1900','DD-Mon-YYYY'))
               or  nvl(ohr.NOT_AFTER_DATE   ,to_date('01-Jan-1900','DD-Mon-YYYY')           )  !=  nvl(ohr2.NOT_AFTER_DATE  ,to_date('01-Jan-1900','DD-Mon-YYYY'))
               --the reason I set min revision = to the max revision if the min revision is null is SMR create order revision 0 with null values
               or  nvl(ohr.DEPT             ,nvl(ohr2.DEPT      ,-1) )  !=  nvl(ohr2.DEPT            ,-1)
               or  nvl(ohr.BUYER            ,nvl(ohr2.BUYER     ,-1) )  !=  nvl(ohr2.BUYER           ,-1)
               or  nvl(ohr.SUPPLIER         ,nvl(ohr2.SUPPLIER  ,-1) )  !=  nvl(ohr2.SUPPLIER        ,-1)
               or  nvl(ohr.LOCATION         ,nvl(ohr2.LOCATION  ,-1) )  !=  nvl(ohr2.LOCATION        ,-1)
               or  nvl(ohr.PROMOTION        ,nvl(ohr2.PROMOTION ,-1) )  !=  nvl(ohr2.PROMOTION       ,-1)
               or      ohr.TERMS                                        !=      ohr2.TERMS
               -- will be Y for any work order change
               or  nvl(soe.wo_860_update_ind,'N') = 'Y'
             )
          )
       and rownum < 2;


   #ifdef DEBUG
   printf("processAlloc - cursor open next\n");
   #endif

   EXEC SQL OPEN cursorAlloc;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorAlloc");
      strcpy(table, "alloc_header,alloc_detail,store");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorAlloc next\n");
   printf("  order number is <%s>\n", orderNo);
   printf("  supplier is <%s>\n", supplier);
   #endif

   /* populate master po number - RMS order number for full alloc PO */
/**   sprintf(masterPONumber,"%06d000",atoi(orderNo)); **/
   masterPONumber[LEN_BULK_ORDER_PO]='\0';
   strncpy(masterPONumber,orderNo,LEN_BULK_ORDER_PO);
   sprintf(masterPONumber,"%d000",atoi(masterPONumber));

   #ifdef DEBUG
   printf("masterPONumber   is <%s>\n", masterPONumber);
   #endif

   /* Reset item sequence number for each PO */
   d1RecSequence=0;

   while (1)
   {

      strcpy(ordItemLocChangeCode, "");

/*********
      EXEC SQL FETCH cursorAlloc INTO :allocRec.allocItem:allocRec.allocItemInd,
                                      :allocRec.oldAllocItem:allocRec.oldAllocItemInd,
                                      :allocRec.allocWh:allocRec.allocWhInd,
                                      :allocRec.oldAllocWh:allocRec.oldAllocWhInd,
*                                      :allocRec.allocStore:allocRec.allocStoreInd,
*                                      :allocRec.oldAllocStore:allocRec.oldAllocStoreInd,
*                                      :allocRec.allocStoreName,
*                                      :allocRec.storeDefaultWh:storeDefaultWhInd,
*                                      :allocRec.qtyAlloc:allocRec.qtyAllocInd,
*                                      :allocRec.oldQtyAlloc:allocRec.oldQtyAllocInd,
*                                      :allocRec.newStore:allocRec.newStoreInd,
                                      :allocRec.supVPN:allocRec.supVPNInd,
                                      :allocRec.itemUnitRetail:allocRec.itemUnitRetailInd,
                                      :allocRec.itemUnitCost:allocRec.itemUnitCostInd,
                                      :allocRec.oldItemUnitCost:allocRec.oldItemUnitCostInd,
                                      :allocRec.itemUPC:allocRec.itemUPCInd,
                                      :allocRec.itemPackType:allocRec.itemPackTypeInd,
                                      :allocRec.itemColorDesc:allocRec.itemColorDescInd,
                                      :allocRec.itemSizeDesc:allocRec.itemSizeDescInd,
                                      :allocRec.itemMfgRecRetail:allocRec.itemMfgRecRetailInd
                                     ,:allocRec.oldSupVPN:allocRec.oldSupVPNInd
                                     ,:allocRec.oldItemUPC:allocRec.oldItemUPCInd
                                     ,:allocRec.oldItemColorDesc:allocRec.oldItemColorDescInd
                                     ,:allocRec.oldItemSizeDesc:allocRec.oldItemSizeDescInd
                                      ;
**********/                   

      EXEC SQL FETCH cursorAlloc INTO :allocRec.allocItem:allocRec.allocItemInd,
                                      :allocRec.oldAllocItem:allocRec.oldAllocItemInd,
                                      :allocRec.allocWh:allocRec.allocWhInd,
                                      :allocRec.oldAllocWh:allocRec.oldAllocWhInd,
                                      :allocRec.qtyAlloc:allocRec.qtyAllocInd,
                                      :allocRec.oldQtyAlloc:allocRec.oldQtyAllocInd,
                                      :allocRec.supVPN:allocRec.supVPNInd,
                                      :allocRec.itemUnitRetail:allocRec.itemUnitRetailInd,
                                      :allocRec.itemUnitCost:allocRec.itemUnitCostInd,
                                      :allocRec.oldItemUnitCost:allocRec.oldItemUnitCostInd,
                                      :allocRec.itemUPC:allocRec.itemUPCInd,
                                      :allocRec.itemPackType:allocRec.itemPackTypeInd,
                                      :allocRec.itemColorDesc:allocRec.itemColorDescInd,
                                      :allocRec.itemSizeDesc:allocRec.itemSizeDescInd,
                                      :allocRec.itemMfgRecRetail:allocRec.itemMfgRecRetailInd,
                                      :allocRec.oldSupVPN:allocRec.oldSupVPNInd,
                                      :allocRec.oldItemUPC:allocRec.oldItemUPCInd,
                                      :allocRec.oldItemColorDesc:allocRec.oldItemColorDescInd,
                                      :allocRec.oldItemSizeDesc:allocRec.oldItemSizeDescInd;

      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorAlloc");
         strcpy(table, "alloc_header,alloc_detail,store");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

      /* for all recs */
      if (strcmp(orderLocation,"9402") == 0)
      {
         strcpy(dcStoreNumber,allocRec.allocStore);
      }
      else
      {
         strncpy(dcStoreNumber,allocRec.storeDefaultWh,3);
      }

 #ifdef DEBUG
 printf("create SMR EDI PO number\n");
 #endif
      /* create SMR EDI PO number */
/**      sprintf(poNumber,"%d%03d",atoi(orderNo), atoi(allocRec.allocStore)); **/
         strcpy(poNumber,orderNo);

      /* for H2 record */
      if (allocRec.newStoreInd != -1 && strcmp(allocRec.newStore,"Y") == 0)
         strcpy(newStoreRushOrder,"OHNS");
      else
         strcpy(newStoreRushOrder,"");

      /* default H1 record PO purpose code to default 0 */
      /* strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_00);  no longer need defaults below */


 #ifdef DEBUG
 printf("populate H1 record PO total quantity\n");
 #endif
      /* populate H1 record PO total quantity */
      EXEC SQL OPEN cursorAllocPOTotal;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorAllocPOTotal");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

 #ifdef DEBUG
 printf("populate H1 record PO total cancelled quantity\n");
 #endif
      /* populate H1 record PO total cancelled quantity */
      EXEC SQL OPEN cursorAllocPOTotal_cancelled;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorAllocPOTotal_cancelled");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorAllocPOTotal INTO :totalQtyAlloc;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorAllocPOTotal");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
   #ifdef DEBUG
   printf("  totalQtyAlloc is <%s>\n", totalQtyAlloc);
   #endif

      EXEC SQL FETCH cursorAllocPOTotal_cancelled INTO :totalQtyCancelledAlloc;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorAllocPOTotal_cancelled");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

   #ifdef DEBUG
   printf("  totalQtyAlloc is <%s>\n", totalQtyCancelledAlloc);
   #endif

      EXEC SQL CLOSE cursorAllocPOTotal_cancelled;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorAllocPOTotal_cancelled, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }


      EXEC SQL CLOSE cursorAllocPOTotal;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorAllocPOTotal, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      strcpy(orderTotalQty, totalQtyAlloc);

      strcpy(orderTotalQtyCancelled, totalQtyCancelledAlloc);


      #ifdef DEBUG
         printf("1-orderTotalQty - <%s> totalQtyAlloc <%s>\n", orderTotalQty, totalQtyAlloc);
	
         printf("processAlloc - current store is <%s> alloc store is <%s> old alloc store is <%s>\n",
                  currentStore, allocRec.allocStore, allocRec.oldAllocStore);
      #endif

      /*Check if order header changed - would require us to print an H1 record even if no detail change*/
      EXEC SQL OPEN cursor_Order_Header_Changed;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursor_Order_Header_Changed");
         strcpy(table, "ordhead_rev,smr_ord_extract");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursor_Order_Header_Changed INTO :orderHeaderChanged_char;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursor_Order_Header_Changed");
         strcpy(table, "ordhead_rev,smr_ord_extract");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursor_Order_Header_Changed;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursor_Order_Header_Changed, order_no=%s", orderNo);
         strcpy(table, "ordhead_rev,smr_ord_extract");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      /*Done checking if order header changed*/


      /* check if same store - could be multiple items for store/PO */
      /* only want header recs once for each PO - store/PO combination */
/***      
      if (strcmp(currentStore, allocRec.allocStore) != 0)
      {
***/      
         /* since treat each new po/store combination as new PO will need to reset sequence */
         recSequence = 1;
         d1RecSequence=0;

         /* Create PO purpose code for if PO quantity is 0 then PO purpose code
            will be 01 if PO quantity is greater than 0 PO purpose code will be 04
            for 860 files*/

         if ( atoi(orderTotalQtyCancelled) == 0 )
         {
            strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_CANCEL);
            strcpy(orderTotalQty, orderTotalQtyCancelled);
         }
         else
            strcpy(poPurposeCode,SMR_PO_PURPOSE_CD_CHANGE);

         #ifdef DEBUG
         printf("orderTotalQty <%s> \n",orderTotalQty);
         #endif

      /*Only wrote a H1 if there has been some change to the item.
        For now this includes item deletes although that may have to change in the future
        Logic below is :  If add
                          or add (increase from 0)
                          or delete
                          or delete (decrease to 0)
                          or qty change
                          or cost change
                          or whole store allocation has been cancelled
                          or work order has changed
                          or VPN/UPC/color/size has changed then
      */
      
      if (   allocRec.oldQtyAllocInd == -1
          || ( atoi(allocRec.qtyAlloc) > 0 && atoi(allocRec.oldQtyAlloc) == 0)
          ||  allocRec.qtyAllocInd == -1
          || ( atoi(allocRec.qtyAlloc) == 0 && atoi(allocRec.oldQtyAlloc) > 0)
          || ( atoi(allocRec.qtyAlloc) > 0 && atoi(allocRec.oldQtyAlloc) > 0 && atoi(allocRec.qtyAlloc) != atoi(allocRec.oldQtyAlloc) )
          || ( atoi(allocRec.itemUnitCost) != atoi(allocRec.oldItemUnitCost) )
          || ( strcmp(poPurposeCode,SMR_PO_PURPOSE_CD_CANCEL) == 0 )
          || ((strcmp(poPurposeCode,SMR_PO_PURPOSE_CD_CHANGE) == 0) && (woChangeInd != -1 && strcmp(woChange, "Y") == 0))
          || ( strcmp(orderHeaderChanged_char, "Y") == 0)
          ||(    (allocRec.oldSupVPNInd         != -1 && allocRec.supVPNInd        != -1 && strcmp(allocRec.oldSupVPN        , allocRec.supVPN )        != 0)
              || (allocRec.oldSupVPNInd         != -1 && allocRec.supVPNInd        == -1 )
              || (allocRec.oldSupVPNInd         == -1 && allocRec.supVPNInd        != -1 ))

          ||(    (allocRec.oldItemUPCInd        != -1 && allocRec.itemUPCInd       != -1 && strcmp(allocRec.oldItemUPC       , allocRec.itemUPC )       != 0)
              || (allocRec.oldItemUPCInd        != -1 && allocRec.itemUPCInd       == -1 )
              || (allocRec.oldItemUPCInd        == -1 && allocRec.itemUPCInd       != -1 ))

          ||(    (allocRec.oldItemColorDescInd  != -1 && allocRec.itemColorDescInd != -1 && strcmp(allocRec.oldItemColorDesc , allocRec.itemColorDesc ) != 0)
              || (allocRec.oldItemColorDescInd  != -1 && allocRec.itemColorDescInd == -1 )
              || (allocRec.oldItemColorDescInd  == -1 && allocRec.itemColorDescInd != -1 ))

          ||(    (allocRec.oldItemSizeDescInd   != -1 && allocRec.itemSizeDescInd  != -1 && strcmp(allocRec.oldItemSizeDesc   , allocRec.itemSizeDesc ) != 0)
              || (allocRec.oldItemSizeDescInd   != -1 && allocRec.itemSizeDescInd  == -1 )
              || (allocRec.oldItemSizeDescInd   == -1 && allocRec.itemSizeDescInd  != -1 ))
            )
         {

            /* ALLOCATION ORDERS H1 */
            /* write header records */

            if (writeH1(ediFilePtr) < OK)
               return(FATAL);
            recSequence++;

            /* if PO purpose code is for change process detail otherwise cancel
               and everything else is not necessary                             */
            if (strcmp(poPurposeCode,SMR_PO_PURPOSE_CD_CHANGE) == 0)
            {
               /* if work order change indicator is not null and yes send H2 recs */
               if (woChangeInd != -1 && strcmp(woChange, "Y") == 0)
               {
                  if (processH2(ediFilePtr) < OK)
                     return(FATAL);
               }

               /* only write H3 record if comments changed               */
               /* if (strcmp(oldPoHeaderComments,poHeaderComments))      */
               /*{                                                       */
               /*   if (writeH3(ediFilePtr) < OK)                        */
               /*      return(FATAL);                                    */
               /*   recSequence++;                                       */
               /*}                                                       */
            }

            /*moved this inside the if/else for writing the header, so we only reset the current store after writing the header */
/****           strcpy(currentStore, allocRec.allocStore); 

         } 
****/

      } 
      ps_old_item = 0;
      strcpy(item, allocRec.allocItem);

   #ifdef DEBUG
   printf("  item is: <%s>\n", item);
   #endif

   #ifdef DEBUG
   printf("  poPurposeCode: <%s>\n", poPurposeCode);
   #endif

/****/
      if (strcmp(poPurposeCode,SMR_PO_PURPOSE_CD_CHANGE) == 0)
      {
/*****/      
         recSequence = 1;

         /* populate item field for writeD1 rec */
         if (allocRec.allocItemInd == -1)
         {
             strcpy(item,allocRec.oldAllocItem);
             ps_old_item = 1;
         }
         else
             strcpy(item, allocRec.allocItem);

   #ifdef DEBUG
   printf("Now item is: <%s>\n", item);
   #endif

         /* check if need to increment d1RecSequence for new item -
                                                  increment if does not match */
         if (strcmp(currentItem, item))
         {
            /* reset to 1 for each new item */
            strcpy(currentItem, item);
            d1RecSequence=1;
         }

         else
            d1RecSequence++;

         #ifdef DEBUG
            printf("Logic for detail change type next\n");
         #endif

         /* determine what to populate in D1 rec field for quantity_left_to_receive  */
         /* if qty change and change time is increase or decrease populate with diff */
         if (atoi(allocRec.qtyAlloc) != atoi(allocRec.oldQtyAlloc)
             && (!strcmp(ordItemLocChangeCode,SMR_D1_CHANGE_CODE_QTY_DECREASE)
             || !strcmp(ordItemLocChangeCode,SMR_D1_CHANGE_CODE_QTY_INCREASE)))
            qtyDiffOrdered = fabs(atoi(allocRec.oldQtyAlloc) - atoi(allocRec.qtyAlloc));
         else
            qtyDiffOrdered = 0;

         strcpy(qtyOrdered,allocRec.qtyAlloc);
         strcpy(oldQtyOrdered,allocRec.oldQtyAlloc);

         /* populate D1 rec change code */
         memset(ordItemLocChangeCode,0,sizeof(ordItemLocChangeCode));

         /*must have been and still be some allocated quantity, otherwise is a regular add/delete*/

/**********/
         if ((allocRec.oldQtyAllocInd != -1 && allocRec.qtyAllocInd != -1 && atoi(allocRec.oldQtyAlloc) != 0 && atoi(allocRec.qtyAlloc) != 0 )
          && (
                   (    (allocRec.oldSupVPNInd         != -1 && allocRec.supVPNInd        != -1 && strcmp(allocRec.oldSupVPN        , allocRec.supVPN )        != 0)
                     || (allocRec.oldSupVPNInd         != -1 && allocRec.supVPNInd        == -1 )
                     || (allocRec.oldSupVPNInd         == -1 && allocRec.supVPNInd        != -1 ))

                 ||(    (allocRec.oldItemUPCInd        != -1 && allocRec.itemUPCInd       != -1 && strcmp(allocRec.oldItemUPC       , allocRec.itemUPC )       != 0)
                     || (allocRec.oldItemUPCInd        != -1 && allocRec.itemUPCInd       == -1 )
                     || (allocRec.oldItemUPCInd        == -1 && allocRec.itemUPCInd       != -1 ))

                 ||(    (allocRec.oldItemColorDescInd  != -1 && allocRec.itemColorDescInd != -1 && strcmp(allocRec.oldItemColorDesc , allocRec.itemColorDesc ) != 0)
                     || (allocRec.oldItemColorDescInd  != -1 && allocRec.itemColorDescInd == -1 )
                     || (allocRec.oldItemColorDescInd  == -1 && allocRec.itemColorDescInd != -1 ))

                 ||(    (allocRec.oldItemSizeDescInd   != -1 && allocRec.itemSizeDescInd  != -1 && strcmp(allocRec.oldItemSizeDesc   , allocRec.itemSizeDesc ) != 0)
                     || (allocRec.oldItemSizeDescInd   != -1 && allocRec.itemSizeDescInd  == -1 )
                     || (allocRec.oldItemSizeDescInd   == -1 && allocRec.itemSizeDescInd  != -1 ))
             )
            )
         {

         #ifdef DEBUG
             printf(" allocRec.supVPN           <%s>\n", allocRec.supVPN           );
             printf(" allocRec.oldSupVPN        <%s>\n", allocRec.oldSupVPN        );
             printf(" allocRec.itemUPC          <%s>\n", allocRec.itemUPC          );
             printf(" allocRec.oldItemUPC       <%s>\n", allocRec.oldItemUPC       );
             printf(" allocRec.itemColorDesc    <%s>\n", allocRec.itemColorDesc    );
             printf(" allocRec.oldItemColorDesc <%s>\n", allocRec.oldItemColorDesc );
             printf(" allocRec.itemSizeDesc     <%s>\n", allocRec.itemSizeDesc     );
             printf(" allocRec.oldItemSizeDesc  <%s>\n", allocRec.oldItemSizeDesc  );
         #endif
/***********/

            strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_DELETE_ITEM);
            qtyOrderedWork = 0;  /* set 0 to delete item */
            qtyDiffOrdered = 0;

            if (processRLD1rec() < OK)
              return(FATAL);

            strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_ADD_ITEM);
            qtyDiffOrdered = fabs(atoi(allocRec.oldQtyAlloc) - atoi(allocRec.qtyAlloc));
            qtyOrderedWork = atoi(oldQtyOrdered);

            qtyDiffOrdered = atoi(allocRec.qtyAlloc);
            strcpy(qtyOrdered,"0");
            qtyOrderedWork = 0;

         #ifdef DEBUG
            printf("*************************qtyOrdered is <%s>\n",qtyOrdered);
            printf("*************************qtyDiffOrdered is <%i>\n",qtyDiffOrdered);
         #endif

            if (processRLD1rec() < OK)
              return(FATAL);

            /* log release alloc version information for this PO extracted */
            if (insertPOAllocRevInfo() < OK)
               return(FATAL);

            continue;
/******/

         }
/*******/
         if (allocRec.oldQtyAllocInd == -1   /* new item */
             || ( atoi(allocRec.qtyAlloc) > 0 && atoi(allocRec.oldQtyAlloc) == 0)) /* OLR V1.18 Insert - send add if ol quantity was 0*/
         {
            #ifdef DEBUG
            printf("In AI %s\n", item);
            #endif

            strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_ADD_ITEM);
            qtyDiffOrdered = fabs(atoi(allocRec.oldQtyAlloc) - atoi(allocRec.qtyAlloc));
            qtyOrderedWork = atoi(oldQtyOrdered);

            if (processRLD1rec() < OK)
              return(FATAL);

         }
         else if (allocRec.qtyAllocInd == -1)   /* delete item */
         {
            #ifdef DEBUG
            printf("In first DI %d\n", allocRec.qtyAllocInd);
            #endif

            strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_DELETE_ITEM);
            qtyOrderedWork = 0;  /* set 0 to delete item */
            qtyDiffOrdered = 0;

            if (processRLD1rec() < OK)
              return(FATAL);

            /* log release alloc version information for this PO extracted */
            if (insertPOAllocRevInfo() < OK)
               return(FATAL);

            continue;

         }
         else if (atoi(allocRec.qtyAlloc) == 0 && atoi(allocRec.oldQtyAlloc) > 0) /* qty decrease to 0 = delete*/
         {
         #ifdef DEBUG
            printf("In second DI %s %s\n", allocRec.qtyAlloc, allocRec.oldQtyAlloc);
         #endif

            strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_DELETE_ITEM);
            qtyOrderedWork = 0;  /* set 0 to delete item */
            qtyDiffOrdered = 0;

            if (processRLD1rec() < OK)
            return(FATAL);

            /* log release alloc version information for this PO extracted */
            if (insertPOAllocRevInfo() < OK)
               return(FATAL);

            continue;

         }

         if (!strcmp(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_ADD_ITEM)== 0)
         {
         #ifdef DEBUG
            printf("In not AI item: %s allocRec.qtyAlloc=%s allocRec.oldQtyAlloc=%s\n", item,allocRec.qtyAlloc,allocRec.oldQtyAlloc);
         #endif

               if (atoi(allocRec.qtyAlloc) > atoi(allocRec.oldQtyAlloc)) /* qty increase */
               {
                  strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_QTY_INCREASE);
                  qtyOrderedWork = atoi(oldQtyOrdered);
                  qtyDiffOrdered = fabs(atoi(allocRec.oldQtyAlloc) - atoi(allocRec.qtyAlloc));

                  if (processRLD1rec() < OK)
                  return(FATAL);

               }
               else if (atoi(allocRec.qtyAlloc) < atoi(allocRec.oldQtyAlloc)) /* qty decrease */
               {
                  strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_QTY_DECREASE);
                  qtyDiffOrdered = fabs(atoi(allocRec.oldQtyAlloc) - atoi(allocRec.qtyAlloc));
                  qtyOrderedWork = atoi(oldQtyOrdered);

                  if (processRLD1rec() < OK)
                  return(FATAL);

               }

               /*OLR V1.18 Delete else */
               if (atoi(allocRec.itemUnitCost) != atoi(allocRec.oldItemUnitCost)) /* unit cost chg */
               {
                  strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_PRICE_CHANGE);
                  qtyOrderedWork = 0;  /* set 0 to price change */
                  qtyDiffOrdered = 0;

                  if (processRLD1rec() < OK)
                  return(FATAL);

               }
         }
/*******/
      } /* SMR_PO_PURPOSE_CD_CHANGE */
/*******/

      /* log release alloc version information for this PO extracted */
      if (insertPOAllocRevInfo() < OK)
         return(FATAL);

   } /* end while for fetch */

   return(OK);
}

/*------------------------------------------------------*\
* function validatePO()                                 *
\*------------------------------------------------------*/
int validatePO(void)
{
   char *function_name = "validatePO";

   /* validate purchase order number */
/*********   
   if (strlen(orderNo) > 6)
   {
      sprintf(err_data,"RMS PO number is greater than 6 digits for PO number <%s>",
              orderNo);
      WRITE_ERROR(RET_FUNCTION_ERR, function_name, "", err_data);
      return(NON_FATAL);
   }
**********/

   /* validate location */
   if (orderLocationInd == -1)
   {
      sprintf(err_data,"RMS PO location is null on PO header record for PO number <%s>",
              orderNo);
      WRITE_ERROR(RET_FUNCTION_ERR, function_name, "", err_data);
      return(NON_FATAL);
   }

   return(OK);
}

/*-----------------------------------------------------------------------------------*\
* function insertPOAllocRevInfo()                                                    *
* Need to do custom revision logging of PO extract info for extract at PO/store/item *
\*-----------------------------------------------------------------------------------*/
int insertPOAllocRevInfo(void)
{
   char *function_name = "insertPOAllocRevInfo";

   char myStore[NULL_LOC] = "";
   char myItem[NULL_ITEM];
   char myAllocWh[NULL_LOC];
   char myQtyOrdered[NULL_QTY];

   #ifdef DEBUG
   printf("insertPOAllocRevInfo\n" );
   #endif

   /* if store/item combination deleted  */
   if (allocRec.allocItemInd == -1)
   {
      #ifdef DEBUG
      printf("insertPOAllocRevInfo - delete\n" );
      #endif
      strcpy(myStore, allocRec.oldAllocStore);
      strcpy(myItem, allocRec.oldAllocItem);
      strcpy(myAllocWh, allocRec.oldAllocWh);
      strcpy(myQtyOrdered, "0");
   }
   /* add or modify */
   else
   {
      #ifdef DEBUG
      printf("insertPOAllocRevInfo - add or modify \n" );
      #endif
      strcpy(myStore, allocRec.allocStore);
      strcpy(myItem, allocRec.allocItem);
      strcpy(myAllocWh, allocRec.allocWh);
      strcpy(myQtyOrdered, qtyOrdered);
   }

   #ifdef DEBUG
   printf("insertPOAllocRevInfo - insert order no <%s> store <%s> item <%s> wh <%s> rev <%d> qty <%s> \n",
              orderNo, myStore, myItem, myAllocWh, maxRevNo,myQtyOrdered );
   #endif


/*** not until store info...***/
   EXEC SQL INSERT INTO smr_edi_ord_extract_hist
                        (order_no,
                         alc_to_loc,
                         item,
                         rev_no,
                         wh,
                         loc_type,
                         qty_allocated,
                         last_extract_date)
                  SELECT :orderNo,
                         NVL(:allocRec.allocStore,NVL(:allocRec.oldAllocStore,1)),
                         NVL(:allocRec.allocItem,:allocRec.oldAllocItem),      
                         :maxRevNo,
                         NVL(:allocRec.allocWh,:allocRec.oldAllocWh),
                         'W',
                         NVL(:allocRec.qtyAlloc,'0'),                          
                         sysdate
                    from DUAL
                  where not exists (select 1 from smr_edi_ord_extract_hist
                                      where order_no = :orderNo
                                        and rev_no = :maxRevNo
                                        and item = NVL(:allocRec.allocItem,:allocRec.oldAllocItem)
                                        and alc_to_loc = NVL(:allocRec.allocStore,NVL(:allocRec.oldAllocStore,1)));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "INSERT: for order no <%s> store <%s> item <%s> rev <%d>",
              orderNo, myStore, myItem, maxRevNo);
      strcpy(table, "smr_edi_ord_extract_hist");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

/****/
   return(OK);
}

/*------------------------------------------------------*\
* function writeH1()                                 *
\*------------------------------------------------------*/
int writeH1(FILE *outRtkFilePtr)
{
   char *function_name = "writeH1";

   #ifdef DEBUG
   printf("writeH1 - main write next\n");
   #endif

   /* if no promo start date initialize promo start date to all zeroes */
   if (promoStartDateInd == -1)
   {
      strcpy(promoQualifier,"");
      strcpy(promoStartDate,"00000000");
   }
   else
      strcpy(promoQualifier,"015");

   #ifdef DEBUG
   printf("originalApproveDate=<%s>\n",originalApproveDate);
   printf("orderChangeDate=<%s>\n",orderChangeDate);
   printf("newNotBeforeDate=<%s>\n",newNotBeforeDate);
   printf("newNotAfterDate=<%s>\n",newNotAfterDate);
   printf("\n");
   #endif

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,           		
   				  rec_type2,           		
   				  rec_seq,             		
   				  supplier_nmbr,       		
   				  company_id,          		
   				  po_type,             		
   				  po_nmbr,             		
   				  po_purpose_code,     		
   				  dc_store_nmbr,       		
   				  master_po_nmbr,             	
   				  vendor_nmbr_ref,     		
   				  vendor_nmbr,         		
   				  dept_nmbr_ref,       		
   				  dept_nmbr,           		
   				  buyer_nmbr_ref,      		
   				  buyer_nmbr,          		
   				  delivery_instruct,  
   				  discount_desc,
   				  total_qty_po,    		
   				  po_approve_date,
   				  po_change_date,
   				  po_requested_ship,   		
   				  po_ship_date,        		
   				  po_cancel_after,     		
   				  po_cancel_date) values ( 
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.nextval),10,'0'),
				  :ps_hdr_record_id,
   				  :recTypeDescH1,				
   				  'H',				
   				  :recSequence,				
   				  to_number(:supplier),				/*atoi*/
   				  1,				
   				  :poType,				
   				  to_number(:poNumber),				/*atoi*/
   				  :poPurposeCode,				
   				  to_number(:dcStoreNumber),			/*atoi*/
   				  :masterPONumber,				
   				  'IA',				
   				  to_number(:supplier),				/*atoi*/
   				  'DP',				
   				  to_number(:orderDept),			/*atoi*/	
   				  'BD',
   				  to_number(:buyer),				/*atoi*/
   				  '',
   				  :termsCode,
   				  to_number(:orderTotalQty),			/*atoi*/
   				  :originalApproveDate,
   				  :orderChangeDate,
   				  '010',
   				  :newNotBeforeDate,
   				  '001',
   				  :newNotAfterDate);
   
   
   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }




   if (fprintf(outRtkFilePtr, h1String860,
      LEN_SMR_REC_TYPE1,            recTypeDescH1,
      LEN_SMR_REC_TYPE2,            "H",
      LEN_SMR_REC_SEQ,              recSequence,
      LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
      LEN_SMR_COMPANY_ID,           1,
      LEN_SMR_PO_TYPE,              poType,
      LEN_SMR_PO_NMBR,              atoi(poNumber),
      LEN_SMR_PO_PURPOSE_CODE,      poPurposeCode,
      LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
      LEN_SMR_PO_NMBR,              masterPONumber,
      LEN_SMR_VENDOR_NMBR_REF,      "IA",
      LEN_SMR_VENDOR_NMBR,          atoi(supplier),
      LEN_SMR_DEPT_NMBR_REF,        "DP",
      LEN_SMR_DEPT_NMBR,            atoi(orderDept),
      LEN_SMR_BUYER_NMBR_REF,       "BY",
      LEN_SMR_BUYER_NMBR,           atoi(buyer),
      LEN_SMR_DELIVERY_INSTRUCT,    "",
      LEN_SMR_DISCOUNT_DESC,        termsCode,
      LEN_SMR_860_TOTAL_QTY_PO,     atoi(orderTotalQty),
      LEN_SMR_PO_DATE,              originalApproveDate,
      LEN_SMR_PO_CHANGE_DATE,       orderChangeDate,
      LEN_SMR_PO_REQUESTED_SHIP,    "010",
      LEN_SMR_PO_SHIP_DATE,         newNotBeforeDate,
      LEN_SMR_PO_CANCEL_AFTER,      "001",
      LEN_SMR_PO_CANCEL_DATE,       newNotAfterDate) < OK)
      return(FATAL);

    return(OK);

}

/*------------------------------------------------------*\
* function processH2() - Write allowance/charge 850     *
*                      h2 header record.  Format of H2  *
*                      different on 850 and 860.        *
\*------------------------------------------------------*/
int processH2(FILE *outRtkFilePtr)
{
   char *function_name = "processH2";

   char sacCode[NULL_SMR_NEW_STORE_RUSH];
   char sacDesc[NULL_SMR_SAC_DESC];

   EXEC SQL DECLARE cursorWorkOrders CURSOR FOR
      SELECT DISTINCT s.sac_code, s.sac_desc
        FROM wo_head wh,
             wo_detail wd,
             smr_sac_codes s
      WHERE wh.wo_id = wd.wo_id
            and wd.wip_code = s.wip_code
            and wh.order_no = TO_NUMBER(:orderNo)
      UNION
      SELECT s.sac_code, s.sac_desc
        FROM smr_sac_codes s
       WHERE s.sac_code = 'HAY'
             and not exists (select 'Y' from wo_head wh, wo_detail wd
                              where wh.wo_id = wd.wo_id
                                    and wd.wip_code in ('HANGEX','NOHANG','SEED')
                                    and wh.order_no = TO_NUMBER(:orderNo))
      UNION
      SELECT s.sac_code, s.sac_desc
        FROM smr_sac_codes s
       WHERE s.sac_code = 'TCY' /* add ticketing service if no TICKEX NOTICK */
             and not exists (select 'Y' from wo_head wh, wo_detail wd
                              where wh.wo_id = wd.wo_id
                                    and wd.wip_code in ('TICKEX','NOTICK')
                                    and wh.order_no = TO_NUMBER(:orderNo));

   #ifdef DEBUG
   printf("%s - main write next\n", function_name);
   #endif

   /* if new store rush order write that record */
   if (strlen(newStoreRushOrder) > 0)
   {
      #ifdef DEBUG
      printf("%s - write H2 rec for new store rush order\n", function_name);
      #endif

      if (writeH2(outRtkFilePtr, newStoreRushOrder, "New Store Order") < OK)
         return(FATAL);
      recSequence++;
   }

   EXEC SQL OPEN cursorWorkOrders;
   if (SQL_ERROR_FOUND)
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorWorkOrders");
      strcpy(table, "wo_head,wo_detail,smr_sac_codes");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   /* process for work orders that PO has */
   while (1)
   {
      #ifdef DEBUG
      printf("%s - fetch work order info next\n", function_name);
      #endif

      EXEC SQL FETCH cursorWorkOrders INTO :sacCode,
                                           :sacDesc;

      #ifdef DEBUG
      printf("%s - after fetch work order info\n", function_name);
      #endif

      if (SQL_ERROR_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorWorkOrders");
         strcpy(table, "wo_head,wo_detail");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("%s - write H2 rec for work order sacCode is <%s>\n", function_name, sacCode);
      #endif

      if (writeH2(outRtkFilePtr, sacCode, sacDesc) < OK)
         return(FATAL);
      recSequence++;
   }

   return(OK);
}

/*------------------------------------------------------*\
* function writeH2() - Write allowance/charge 860       *
*                      h2 header record. Format same    *
*                      on 850 and 860.                  *
\*------------------------------------------------------*/
int writeH2(FILE *outRtkFilePtr, char *sacCode, char *sacDesc)
{
   char *function_name = "writeH2";


   #ifdef DEBUG
   printf("writeH2 - main write next\n");
   #endif

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  charge_ind,
      				  vics,
      				  new_store_rush,
      				  sac_desc) values (
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,      				  
   				  :recTypeDescH2,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  'N',
   				  'VI',
   				  :sacCode,
   				  :sacDesc);

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H2 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   if (fprintf(outRtkFilePtr, h2String,
               LEN_SMR_REC_TYPE1,            recTypeDescH2,
               LEN_SMR_REC_TYPE2,             "H",
               LEN_SMR_REC_SEQ,              recSequence,
               LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
               LEN_SMR_COMPANY_ID,           1,
               LEN_SMR_PO_NMBR,              atoi(poNumber),
               LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
               LEN_SMR_CHARGE_IND,           "N",
               LEN_SMR_VICS,                 "VI",
               LEN_SMR_NEW_STORE_RUSH,       sacCode,
               LEN_SMR_SAC_DESC,             sacDesc) < OK)
        return(FATAL);

    return(OK);
}

     /*------------------------------------------------------*\
     * function writeH3()                                 *
     \*------------------------------------------------------*/
/*     int writeH3(FILE *outRtkFilePtr)                                                                                       */
/*     {                                                                                                                      */
/*        char *function_name = "writeH3";                                                                                    */
/*                                                                                                                            */
/*        #ifdef DEBUG                                                                                                        */
/*        printf("writeH3 - main write next\n");                                                                              */
/*        #endif                                                                                                              */
/*                                                                                                                            */
/*        if (fprintf(outRtkFilePtr, h3String,                                                                                */
/*                             LEN_SMR_REC_TYPE1,            recTypeDescH3,                                                   */
/*                             LEN_SMR_REC_TYPE2,             "H",                                                            */
/*                             LEN_SMR_REC_SEQ,              recSequence,                                                     */
/*                             LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),                                                */
/*                             LEN_SMR_COMPANY_ID,           1,                                                               */
/*                             LEN_SMR_PO_NMBR,              atoi(poNumber),                                                  */
/*                             LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),                                             */
/*                             LEN_SMR_DESC_TYPE,            "F",                                                             */
/*                             LEN_SMR_COMMENTS,             poHeaderComments) < 0)                                           */
/*           return(FATAL);                                                                                                   */
/*                                                                                                                            */
/*         return(OK);                                                                                                        */
/*                                                                                                                            */
/*     }                                                                                                                      */
/*                                                                                                                            */
     /*------------------------------------------------------*\
     * function writeH3_All_POs()                            *
     \*------------------------------------------------------*/
/*     int writeH3_All_POs(FILE *outRtkFilePtr)                                                                               */
/*     {                                                                                                                      */
/*        char *function_name = "writeH3_All_POs";                                                                            */
/*                                                                                                                            */
/*        #ifdef DEBUG                                                                                                        */
/*        printf("writeH3_All_POs - main write next\n");                                                                      */
/*        #endif                                                                                                              */
/*                                                                                                                            */
/*        if (fprintf(outRtkFilePtr, h3String,                                                                                */
/*                             LEN_SMR_REC_TYPE1,            recTypeDescH3,                                                   */
/*                             LEN_SMR_REC_TYPE2,             "H",                                                            */
/*                             LEN_SMR_REC_SEQ,              recSequence++,                                                   */
/*                             LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),                                                */
/*                             LEN_SMR_COMPANY_ID,           1,                                                               */
/*                             LEN_SMR_PO_NMBR,              atoi(poNumber),                                                  */
/*                             LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),                                             */
/*                             LEN_SMR_DESC_TYPE,            "F",                                                             */
/*                             LEN_SMR_COMMENTS,             "If not shipped complete within the time window, St") < 0)       */
/*           return(FATAL);                                                                                                   */
/*                                                                                                                            */
/*         if (fprintf(outRtkFilePtr, h3String,                                                                               */
/*                             LEN_SMR_REC_TYPE1,            recTypeDescH3,                                                   */
/*                             LEN_SMR_REC_TYPE2,             "H",                                                            */
/*                             LEN_SMR_REC_SEQ,              recSequence++,                                                   */
/*                             LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),                                                */
/*                             LEN_SMR_COMPANY_ID,           1,                                                               */
/*                             LEN_SMR_PO_NMBR,              atoi(poNumber),                                                  */
/*                             LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),                                             */
/*                             LEN_SMR_DESC_TYPE,            "F",                                                             */
/*                             LEN_SMR_COMMENTS,             "ein Mart may assess charges or reject all or part") < 0)        */
/*           return(FATAL);                                                                                                   */
/*                                                                                                                            */
/*           if (fprintf(outRtkFilePtr, h3String,                                                                             */
/*                             LEN_SMR_REC_TYPE1,            recTypeDescH3,                                                   */
/*                             LEN_SMR_REC_TYPE2,             "H",                                                            */
/*                             LEN_SMR_REC_SEQ,              recSequence++,                                                   */
/*                             LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),                                                */
/*                             LEN_SMR_COMPANY_ID,           1,                                                               */
/*                             LEN_SMR_PO_NMBR,              atoi(poNumber),                                                  */
/*                             LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),                                             */
/*                             LEN_SMR_DESC_TYPE,            "F",                                                             */
/*                             LEN_SMR_COMMENTS,             "of the shipment.") < 0)                                         */
/*           return(FATAL);                                                                                                   */
/*                                                                                                                            */
/*         return(0);                                                                                                         */
/*                                                                                                                            */
/*     }                                                                                                                      */
/*                                                                                                                            */
     /*------------------------------------------------------*\
     * function writeH3_QCInd()                              *
     \*------------------------------------------------------*/
/*     int writeH3_QCInd(FILE *outRtkFilePtr)                                                                                 */
/*     {                                                                                                                      */
/*        char *function_name = "writeH3_QCInd";                                                                              */
/*                                                                                                                            */
/*        #ifdef DEBUG                                                                                                        */
/*        printf("writeH3_QCInd - main write next\n");                                                                        */
/*        #endif                                                                                                              */
/*                                                                                                                            */
/*        if (fprintf(outRtkFilePtr, h3String,                                                                                */
/*                             LEN_SMR_REC_TYPE1,            recTypeDescH3,                                                   */
/*                             LEN_SMR_REC_TYPE2,             "H",                                                            */
/*                             LEN_SMR_REC_SEQ,              recSequence++,                                                   */
/*                             LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),                                                */
/*                             LEN_SMR_COMPANY_ID,           1,                                                               */
/*                             LEN_SMR_PO_NMBR,              atoi(poNumber),                                                  */
/*                             LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),                                             */
/*                             LEN_SMR_DESC_TYPE,            "F",                                                             */
/*                             LEN_SMR_COMMENTS,             "Pending Approval of TOP Sample") < 0)                           */
/*           return(FATAL);                                                                                                   */
/*                                                                                                                            */
/*         return(0);                                                                                                         */
/*                                                                                                                            */
/*     }                                                                                                                      */

/*------------------------------------------------------*\
* function writeH4()                                 *
\*------------------------------------------------------*/
int writeH4(FILE *outRtkFilePtr)
{
   char *function_name = "writeH4";

   #ifdef DEBUG
   printf("writeH4 - main write next\n");
   #endif

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_HDR_EXP( group_id,
                                  record_id,
                                  rec_type1,
      				  rec_type2,
      				  rec_seq,
      				  supplier_nmbr,
      				  company_id,
      				  po_nmbr,
      				  dc_store_nmbr,
      				  ship_to_mark_for,
      				  address1,
      				  address2,
      				  city,    
      				  state,
      				  zip,
      				  country,
      				  wh_desc) values (
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescH4,
   				  'H',
   				  :recSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  :shipToMarkFor,
   				  null,
   				  null,
   				  null,    
   				  null,   
   				  null,     
   				  null, 
   				  null);

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_HDR_EXP H4 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_HDR_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   fprintf(outRtkFilePtr, h4String860,
      LEN_SMR_REC_TYPE1,            recTypeDescH4,
      LEN_SMR_REC_TYPE2,             "H",
      LEN_SMR_REC_SEQ,              recSequence,
      LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
      LEN_SMR_COMPANY_ID,           1,
      LEN_SMR_PO_NMBR,              atoi(poNumber),
      LEN_SMR_DC_STORE_NMBR,        atoi(h4StoreNumber),
      LEN_SMR_SHIP_TO_MARK_FOR,     shipToMarkFor,
      LEN_SMR_ADDRESS,              "",
      LEN_SMR_ADDRESS,              "",
      LEN_SMR_CITY,                 "",
      LEN_SMR_STATE,                "",
      LEN_SMR_ZIP,                  "",
      LEN_SMR_COUNTRY,              "",
      LEN_SMR_WH_DESC,              "");

   return(OK);
}


/*------------------------------------------------------*\
* function oldwriteD1()                                 *
\*------------------------------------------------------*/
int oldwriteD1(FILE *outRtkFilePtr)
{
   char *function_name = "writeD1";

   int i = 0;

   #ifdef DEBUG
   printf("%s - main write next\n",function_name);
   #endif

   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,            
      				  REC_TYPE2,            
      				  REC_SEQ,              
      				  SUPPLIER_NMBR,          
      				  COMPANY_ID,           
      				  PO_NMBR,              
      				  DC_STORE_NMBR,        
      				  ITEM_SKU_NMBR,        
      				  DETAIL_REC_SUB_SEL, 
      				  PO_CHANGE_CODE,
      				  VPN,                  
      				  ITEM_QTY,
                                  QTY_LEFT_TO_RECEIVE,
      				  UNIT_COST,            
      				  UPC,                  
      				  BUYER_COLOR_QUALIFIER,
      				  BUYER_COLOR_DESC,     
      				  BUYER_SIZE_QUALIFIER, 
      				  BUYER_SIZE_DESC,      
      				  COMPARE_TO_PRICE_ID,  
      				  COMPARE_TO_PRICE    
      				  ) values (
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescD1,
   				  'D',
   				  :d1RecSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber),
   				  to_number(:dcStoreNumber),
   				  to_number(:item),
   				  1,
   				  :ordItemLocChangeCode,
   				  :itemSupVPN,   				  
   				  to_number(:orderTotalQty),
                                  :qtyDiffOrdered,   				  
   				  to_number(:orderUnitCost),
   				  :upc,
   				  'BO',
   				  :itemColorDesc,
   				  'IZ',
   				  :itemSizeDesc,
   				  'MSR',
   				  to_number(:itemMfgRecRetail));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }



   /* use format for 860 since order change type is not new */
   fprintf(outRtkFilePtr, d1String860,
           LEN_SMR_REC_TYPE1,             recTypeDescD1,
           LEN_SMR_REC_TYPE2,             "D",
           LEN_SMR_REC_SEQ,               d1RecSequence,
           LEN_SMR_SUPPLIER_NMBR,         atoi(supplier),
           LEN_SMR_COMPANY_ID,            1,
           LEN_SMR_PO_NMBR,               atoi(poNumber),
           LEN_SMR_DC_STORE_NMBR,         atoi(dcStoreNumber),
           LEN_SMR_ITEM_SKU_NMBR,         atol(item),
           LEN_SMR_DETAIL_REC_SUB_SEL,    1,
           LEN_SMR_PO_CHANGE_CODE,        ordItemLocChangeCode,
           LEN_SMR_VPN,                   itemSupVPN,
           LEN_SMR_ITEM_QTY,              atoi(orderTotalQty),
           LEN_QTY_LEFT_TO_RECEIVE,       qtyDiffOrdered,
           LEN_SMR_UNIT_COST,             atol(orderUnitCost),
           LEN_SMR_UPC,                   upc,
           LEN_SMR_BUYER_COLOR_QUALIFIER, "BO",
           LEN_SMR_BUYER_COLOR_DESC,      itemColorDesc,
           LEN_SMR_BUYER_SIZE_QUALIFIER,  "IZ",
           LEN_SMR_BUYER_SIZE_DESC,       itemSizeDesc,
           LEN_SMR_COMPARE_TO_PRICE_ID,   "MSR",
           LEN_SMR_COMPARE_TO_PRICE,      atol(itemMfgRecRetail));

    return(OK);
}

/*------------------------------------------------------*\
 * function writeD1()                                   *
\*------------------------------------------------------*/
int writeD1(FILE *outRtkFilePtr)
{
   char *function_name = "writeD1";

   int i = 0;

   EXEC SQL DECLARE cursorD1Qty CURSOR FOR
     SELECT sum(v.qty_allocated) item_qty
       from v_ord_alloc_extract_dtl_860 v
      where v.order_no = TO_NUMBER(:orderNo)
        and ((v.item = :item) or (v.item in (select item from packitem where pack_no = :item)))
/*** not until DD implemented         
        and ((v.order_no in (select order_no from ordhead where location in     (select wh from wh_attributes where wh_type_code = 'DD') and v.to_loc = :allocRec.allocStore))
          or (v.order_no in (select order_no from ordhead where location not in (select wh from wh_attributes where wh_type_code = 'DD'))))
***/
        and qty_allocated > 0;
        
   EXEC SQL DECLARE cursorD4Qty CURSOR FOR
       SELECT pack_qty
        from packitem p
       where p.item = :item
         and p.pack_no in (select item from ordloc where order_no = TO_NUMBER(:orderNo)) ;
      
   EXEC SQL DECLARE cursorOldItemQty CURSOR FOR
       SELECT sum(qty_allocated)
        from smr_edi_ord_extract_hist h
       where h.order_no = TO_NUMBER(:orderNo)
         and h.item = :item;         
            
   #ifdef DEBUG
   printf("writeD1 - poType=%s\n",poType);
   #endif

   #ifdef DEBUG
   printf("totalD1Qty order_no=%s, item=%s, totalD1Qty=%s\n", orderNo, item, totalD1Qty);
   #endif

   if (strcmp(poType,SMR_ALLOC_PO_TYPE) == 0)
   {
    if (strcmp(recTypeDescD1, recTypeDescD4) == 0) /* then Vendor Pack D4 */
    {
      EXEC SQL OPEN cursorD4Qty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorD4Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorD4Qty INTO :totalD1Qty;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorD4Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorD4Qty;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorD4Qty, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      #ifdef DEBUG
      printf("cursorD4Qty totalD1Qty order_no=%s, item=%s, totalD1Qty=%s\n", orderNo, item, totalD1Qty);
      #endif

    }
    else if (ps_old_item)
    {
      EXEC SQL OPEN cursorOldItemQty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorOldItemQty");
         strcpy(table, "smr_edi_ord_extract_hist");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorOldItemQty INTO :totalD1Qty;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorOldItemQty");
         strcpy(table, "smr_edi_ord_extract_hist");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorOldItemQty;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorOldItemQty, order_no=%s", orderNo);
         strcpy(table, "smr_edi_ord_extract_hist");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      #ifdef DEBUG
      printf("cursorOldItemQty totalD1Qty order_no=%s, item=%s, totalD1Qty=%s\n", orderNo, item, totalD1Qty);
      #endif
    }    
    else
    {
      EXEC SQL OPEN cursorD1Qty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorD1Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL FETCH cursorD1Qty INTO :totalD1Qty;

      if (SQL_ERROR_FOUND || NO_DATA_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorD1Qty");
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      EXEC SQL CLOSE cursorD1Qty;
      if (SQL_ERROR_FOUND)
      {
         sprintf(err_data, "CURSOR CLOSE: cursor=cursorD1Qty, order_no=%s", orderNo);
         strcpy(table, "alloc_header,alloc_detail,store,item_master,packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      #ifdef DEBUG
      printf("cursorD1Qty totalD1Qty order_no=%s, item=%s, totalD1Qty=%s\n", orderNo, item, totalD1Qty);
      #endif
    }
   }
   else /* not RL */
      strcpy(totalD1Qty, qtyOrdered);

   ps_hdr_record_id++;

   #ifdef DEBUG
   printf("totalD1Qty=%s\n", totalD1Qty);
   #endif

   printf("qtyDiffOrdered=%d\n", qtyDiffOrdered);
   printf("orderUnitCost=%s\n", orderUnitCost);
   printf("upc=%s\n", upc);
   printf("itemColorDesc=%s\n", itemColorDesc);
   printf("itemSizeDesc=%s\n", itemSizeDesc);
   printf("itemMfgRecRetail=%s\n", itemMfgRecRetail);


   EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,            
      				  REC_TYPE2,            
      				  REC_SEQ,              
      				  SUPPLIER_NMBR,          
      				  COMPANY_ID,           
      				  PO_NMBR,              
      				  DC_STORE_NMBR,        
      				  ITEM_SKU_NMBR,        
      				  DETAIL_REC_SUB_SEL, 
      				  PO_CHANGE_CODE,
      				  VPN,                  
      				  ITEM_QTY,
                                  QTY_LEFT_TO_RECEIVE,
      				  UNIT_COST,            
      				  UPC,                  
      				  BUYER_COLOR_QUALIFIER,
      				  BUYER_COLOR_DESC,     
      				  BUYER_SIZE_QUALIFIER, 
      				  BUYER_SIZE_DESC,      
      				  COMPARE_TO_PRICE_ID,  
      				  COMPARE_TO_PRICE    
      				  ) values (
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
   				  :recTypeDescD1,
   				  'D',
   				  :d1RecSequence,
   				  to_number(:supplier),
   				  1,
   				  to_number(:poNumber), 
   				  to_number(:dcStoreNumber),
   				  to_number(:item),
   				  1,
   				  :ordItemLocChangeCode,
   				  :itemSupVPN,   				  
   				  to_number(:totalD1Qty),
                                  :qtyDiffOrdered,   				  
   				  to_number(:orderUnitCost),
   				  :upc,
   				  'BO',
   				  :itemColorDesc,
   				  'IZ',
   				  :itemSizeDesc,
   				  'MSR',
   				  to_number(:itemMfgRecRetail));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


   /* use format for 860 since order change type is not new */
   fprintf(outRtkFilePtr, d1String860,
           LEN_SMR_REC_TYPE1,             recTypeDescD1,
           LEN_SMR_REC_TYPE2,             "D",
           LEN_SMR_REC_SEQ,               d1RecSequence,
           LEN_SMR_SUPPLIER_NMBR,         atoi(supplier),
           LEN_SMR_COMPANY_ID,            1,
           LEN_SMR_PO_NMBR,               atoi(poNumber),
           LEN_SMR_DC_STORE_NMBR,         atoi(dcStoreNumber),
           LEN_SMR_ITEM_SKU_NMBR,         atol(item),
           LEN_SMR_DETAIL_REC_SUB_SEL,    1,
           LEN_SMR_PO_CHANGE_CODE,        ordItemLocChangeCode,
           LEN_SMR_VPN,                   itemSupVPN,
           LEN_SMR_ITEM_QTY,              atoi(totalD1Qty),
           LEN_QTY_LEFT_TO_RECEIVE,       qtyDiffOrdered,
           LEN_SMR_UNIT_COST,             atol(orderUnitCost),
           LEN_SMR_UPC,                   upc,
           LEN_SMR_BUYER_COLOR_QUALIFIER, "BO",
           LEN_SMR_BUYER_COLOR_DESC,      itemColorDesc,
           LEN_SMR_BUYER_SIZE_QUALIFIER,  "IZ",
           LEN_SMR_BUYER_SIZE_DESC,       itemSizeDesc,
           LEN_SMR_COMPARE_TO_PRICE_ID,   "MSR",
           LEN_SMR_COMPARE_TO_PRICE,      atol(itemMfgRecRetail));

    return(0);
}

int processBulkDetail(void)
{
   char *function_name = "processBulkDetail";

   /* track current item so can increment d1RecSequence correctly */
   char currentItem[NULL_ITEM] = "";

   EXEC SQL DECLARE cursorDetail CURSOR FOR
   select order_values.item,
          substr(vpn,1,15),     
          substr(old_vpn,1,15), 
          sum(nvl(current_qty_ord,0)),
          sum(old_qty_ord),
          current_unit_retail,
          old_unit_retail,
          current_unit_cost,
          old_unit_cost,
          CASE WHEN ref_item is not NULL
               THEN LPAD(SUBSTR(NVL(ref_item,im2.item),1,15),15,'0')
               ELSE DECODE (im2.item_number_type,'SMRBC','               ', nvl(LPAD(im2.item,15,'0'),'               '))    /*OLR v1.19 Updated*/
          END upc,
          nvl(lpad(old_ref_item,15,'0'),'               '), 
          color,
          size_desc,
          substr(old_color,1,15), 
          substr(old_size,1,15),  
          order_values.mfg_rec_retail,
          order_values.pack_type
     from item_master im2,
          (
           /* added */
           select ord_dtl.item,
                  substr(isp.vpn,1,15)                 vpn,
                  substr(ordcustom_rev.vpn,1,15)       old_vpn,                       
                  NVL(ord_dtl.qty_ordered,0)           current_qty_ord,
                  null                                 old_qty_ord    ,
                  to_char(ord_dtl.unit_retail * 10000) current_unit_retail,
                  null                                 old_unit_retail,
                  to_char(ord_dtl.unit_cost   * 10000) current_unit_cost,
                  null                                 old_unit_cost,
                  ord_dtl.ref_item                     ref_item,
                  ordcustom_rev.upc                    old_ref_item,                  
                  substr(dc.diff_desc,1,15)            color,
                  substr(ds.diff_desc,1,15)            size_desc,
                  ordcustom_rev.diff_color             old_color,                     
                  ordcustom_rev.diff_size              old_size,                      
                  to_char(im.mfg_rec_retail   * 10000) mfg_rec_retail,
                  im.pack_type                         pack_type
             from v_ord_extract_dtl_smr ord_dtl,
                  item_master im,
                  item_supplier isp,
                  ordhead oh,
                 (select i.item, c.diff_desc
                    from item_master i, diff_ids c
                   where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
                  (select i.item, s.diff_desc
                     from item_master i, diff_ids s
                    where s.diff_type = 'S'
                      and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                           or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
                 ,(select order_no, item, vpn, upc, diff_color, diff_size
                     from ordcustom_rev
                    where order_no = TO_NUMBER(:orderNo)
                      and rev_no = TO_NUMBER(:lastSentRevNo)) ordcustom_rev
            where ord_dtl.order_no = TO_NUMBER(:orderNo)
              and ord_dtl.item     = im.item
              and ord_dtl.order_no = oh.order_no
              and ord_dtl.item     = isp.item
              and oh.supplier      = isp.supplier
              and ord_dtl.item     = dc.item (+)
              and ord_dtl.item     = ds.item (+)
              and not exists (select 'x'
                                from v_ord_860_rev_dtl_smr
                               where order_no = ord_dtl.order_no
                                 and item     = ord_dtl.item
                                 and location = ord_dtl.location
                                 and rev_no   =  TO_NUMBER(:lastSentRevNo))  /* last sent revision must have been not there or a delete */
              and NVL(ord_dtl.qty_ordered,0) != 0                            /* don't send out an add for a 0 quantity */
              and ord_dtl.order_no = ordcustom_rev.order_no (+)
              and ord_dtl.item = ordcustom_rev.item (+)
           union all
           /* removed */
           select r.item,
                  substr(isp.vpn,1,15)                 vpn,
                  substr(ordcustom_rev.vpn,1,15)       old_vpn,                 
                  null                                 current_qty_ord,
                  NVL(r.qty_ordered,0)                 old_qty_ord    ,
                  null                                 current_unit_retail,
                  to_char(r.unit_retail     * 10000)   old_unit_retail,
                  null                                 current_unit_cost,
                  to_char(r.unit_cost       * 10000)   old_unit_cost,
                  r.ref_item                           ref_item,
                  ordcustom_rev.upc                    old_ref_item,            
                  substr(dc.diff_desc,1,15)            color,
                  substr(ds.diff_desc,1,15)            size_desc,
                  ordcustom_rev.diff_color             old_color,               
                  ordcustom_rev.diff_size              old_size,                
                  to_char(im.mfg_rec_retail * 10000)   mfg_rec_retail,
                  im.pack_type                         pack_type
             from v_ord_860_rev_dtl_smr r,
                  item_master im,
                  ordhead oh,
                  item_supplier isp,
                 (select i.item, c.diff_desc
                    from item_master i, diff_ids c
                   where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
                  (select i.item, s.diff_desc
                     from item_master i, diff_ids s
                    where s.diff_type = 'S'
                      and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                           or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
                 ,(select order_no, item, vpn, upc, diff_color, diff_size
                     from ordcustom_rev
                    where order_no = TO_NUMBER(:orderNo)
                      and rev_no = TO_NUMBER(:lastSentRevNo)) ordcustom_rev
            where r.order_no   = TO_NUMBER(:orderNo)
              and r.item       = im.item
              and r.order_no   = oh.order_no
              and r.rev_no     =  TO_NUMBER(:lastSentRevNo)
              and r.item       = isp.item
              and oh.supplier  = isp.supplier
              and r.item       = dc.item (+)
              and r.item       = ds.item (+)
              and not exists (select 'x'
                                from v_ord_extract_dtl_smr
                               where order_no = r.order_no
                                 and item     = r.item
                                 and location = r.location)
              and NVL(r.qty_ordered,0) != 0 /* current details must not exist and last revision must not have been a delete */
              and r.order_no = ordcustom_rev.order_no (+)
              and r.item = ordcustom_rev.item (+)
          union all
          /* existing */
          /* if last sent was 0, treat this as an add by setting old qty ordered from 0 to null*/
           select ord_dtl.item,
                  substr(isp.vpn,1,15),
                  substr(ordcustom_rev.vpn,1,15)       old_vpn,              
                  NVL(ord_dtl.qty_ordered,0)           current_qty_ord,
                  case when nvl(r.qty_ordered,0) = 0 then null
                       else r.qty_ordered
                   end old_qty_ord,
                  to_char(ord_dtl.unit_retail * 10000) current_unit_retail,
                  case when nvl(r.qty_ordered,0) = 0 then null
                       else to_char(r.unit_retail       * 10000)
                   end old_unit_retail,
                  to_char(ord_dtl.unit_cost   * 10000) current_unit_cost,
                  case when nvl(r.qty_ordered,0) = 0 then null
                       else to_char(r.unit_cost       * 10000)
                   end old_unit_cost,
                  ord_dtl.ref_item                     ref_item,
                  ordcustom_rev.upc                    old_ref_item,         
                  substr(dc.diff_desc,1,15)            color,
                  substr(ds.diff_desc,1,15)            size_desc,
                  ordcustom_rev.diff_color             old_color,            
                  ordcustom_rev.diff_size              old_size,             
                  to_char(im.mfg_rec_retail   * 10000) mfg_rec_retail,
                  im.pack_type                         pack_type
             from (select ORDER_NO,
                          ITEM,
                          LOCATION,
                          LOC_TYPE,
                          max(REF_ITEM)    REF_ITEM,
                          sum(QTY_ORDERED) QTY_ORDERED,
                          max(UNIT_COST  ) UNIT_COST,
                          max(UNIT_RETAIL) UNIT_RETAIL
                     from v_ord_extract_dtl_smr
                    where order_no = TO_NUMBER(:orderNo)
                    group by ORDER_NO,
                             ITEM ,
                             LOCATION,
                             LOC_TYPE ) ord_dtl,
                  v_ord_860_rev_dtl_smr r,
                  item_master im,
                  ordhead oh,
                  item_supplier isp,
                 (select i.item, c.diff_desc
                    from item_master i, diff_ids c
                   where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
                  (select i.item, s.diff_desc
                     from item_master i, diff_ids s
                    where s.diff_type = 'S'
                      and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                           or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
                  ,(select order_no, item, vpn, upc, diff_color, diff_size
                      from ordcustom_rev
                     where order_no = TO_NUMBER(:orderNo)
                       and rev_no = TO_NUMBER(:lastSentRevNo)) ordcustom_rev
            where ord_dtl.order_no  = TO_NUMBER(:orderNo)
              and ord_dtl.order_no  = oh.order_no
              and ord_dtl.order_no  = r.order_no
              and ord_dtl.item      = r.item
              and ord_dtl.location  = r.location
              and ord_dtl.item      = im.item
              and r.rev_no          = TO_NUMBER(:lastSentRevNo)
              and ord_dtl.item      = isp.item
              and oh.supplier       = isp.supplier
              and ord_dtl.item      = dc.item (+)
              and ord_dtl.item      = ds.item (+)
              and not ( nvl(r.qty_ordered,0) = 0 and NVL(ord_dtl.qty_ordered,0) = 0)
              and ord_dtl.order_no = ordcustom_rev.order_no (+)
              and ord_dtl.item = ordcustom_rev.item (+)
          ) order_values
   where order_values.item = im2.item_parent(+)
            and im2.primary_ref_item_ind(+) = 'Y'
   group by order_values.item,ref_item,im2.item_number_type,im2.item,
            substr(vpn,1,15),                           
            substr(old_vpn,1,15),                       
            current_unit_retail,
            old_unit_retail,
            current_unit_cost,
            old_unit_cost,
            nvl(ref_item, im2.item),
            nvl(lpad(old_ref_item,15,'0'),'               '), 
            color,
            size_desc,
            old_color,                     
            old_size,                      
            order_values.mfg_rec_retail,
            order_values.pack_type;

   #ifdef DEBUG
   printf("processBulkDetail - cursor open next\n");
   #endif

   EXEC SQL OPEN cursorDetail;
   if (SQL_ERROR_FOUND)
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDetail");
      strcpy(table, "ordhead,ordsku,ordloc,item_supplier,item_master,diff_ids");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorDetail next\n");
   #endif

   while (1)
   {

      strcpy(ordItemLocChangeCode, "");

      EXEC SQL FETCH cursorDetail INTO :orderItem,
                                       :itemSupVPN:itemSupVPNInd,
                                       :oldItemSupVPN:oldItemSupVPNInd,                 
                                       :qtyOrdered,
                                       :oldQtyOrdered:oldQtyOrderedInd,
                                       :orderUnitRetail:orderUnitRetailInd,
                                       :oldOrderUnitRetail:oldOrderUnitRetailInd,
                                       :orderUnitCost,
                                       :oldOrderUnitCost:oldOrderUnitCostInd,
                                       :upc:upcInd,
                                       :oldUPC:oldUPCInd,                               
                                       :itemColorDesc:itemColorDescInd,
                                       :itemSizeDesc:itemSizeDescInd,
                                       :oldItemColorDesc:oldItemColorDescInd,           
                                       :oldItemSizeDesc:oldItemSizeDescInd,             
                                       :itemMfgRecRetail:itemMfgRecRetailInd,
                                       :itemPackType:itemPackTypeInd;

      if (SQL_ERROR_FOUND)
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDetail");
         strcpy(table, "ordhead,ordsku,ordloc,item_supplier,item_master,diff_ids");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("process bulk detail for item %s\n", orderItem);
      #endif

      /* validate that data fits into output format */

      if (oldItemSupVPNInd == -1)
         strcpy(oldItemSupVPN,SMR_15SPACES);  /* 15 SPACES */

      if (oldUPCInd == -1)
         strcpy(oldUPC,SMR_15SPACES);         /* 15 SPACES */

      if (oldItemColorDescInd == -1)
         strcpy(oldItemColorDesc,SMR_15SPACES);  /* 15 SPACES */

      if (oldItemSizeDescInd == -1)
         strcpy(oldItemSizeDesc,SMR_15SPACES);   /* 15 SPACES */

      /* handle any null values from query */
      if (itemSupVPNInd == -1)
         strcpy(itemSupVPN,SMR_15SPACES);     /* 15 SPACES */

      if (upcInd == -1)
         strcpy(upc,SMR_15SPACES);            /* 15 SPACES */

      if (itemColorDescInd == -1)
         strcpy(itemColorDesc,SMR_15SPACES);  /* 15 SPACES */

      if (itemSizeDescInd == -1)
         strcpy(itemSizeDesc,SMR_15SPACES);   /* 15 SPACES */

      if (itemMfgRecRetailInd == -1)
         strcpy(itemMfgRecRetail,"0");

      if ((oldQtyOrderedInd != -1 && atoi(qtyOrdered))
          && (strcmp(itemSupVPN,oldItemSupVPN) != 0
              ||
             (strcmp(upc,oldUPC) != 0)
              ||
             (strcmp(itemColorDesc,oldItemColorDesc) != 0)
              ||
             (strcmp(itemSizeDesc, oldItemSizeDesc) != 0)
             )
         )
      {
         recSequence++;

         /* populate item field for writeD1 rec */
         strcpy(item, orderItem);
         strcpy(recTypeDescD1,"S860D1");
         strcpy(recTypeDescD2,"S860D2");

         strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_DELETE_ITEM);
         qtyOrderedWork = 0;   /* set 0 to delete item */
         qtyDiffOrdered = 0;

         strcpy(holdItemSupVPN,itemSupVPN);
         strcpy(itemSupVPN,oldItemSupVPN);

         strcpy(holdUPC,upc);
         strcpy(upc,oldUPC);

         strcpy(holdItemColorDesc,itemColorDesc);
         strcpy(itemColorDesc,oldItemColorDesc);

         strcpy(holdItemSizeDesc,itemSizeDesc);
         strcpy(itemSizeDesc,oldItemSizeDesc);

         strcpy(holdQtyOrdered,qtyOrdered);

         if (processBKD1rec() < OK)
         return(FATAL);

         strcpy(qtyOrdered,holdQtyOrdered);

         recSequence++;

         strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_ADD_ITEM);
         qtyOrderedWork = 0;
         qtyDiffOrdered = atoi(qtyOrdered);
         strcpy(qtyOrdered,"0");

         strcpy(itemSupVPN,holdItemSupVPN);
         strcpy(upc,holdUPC);
         strcpy(itemColorDesc,holdItemColorDesc);
         strcpy(itemSizeDesc,holdItemSizeDesc);

         /* if pack type is not null and pack type is vendor write po vendor pack records */
         if (itemPackTypeInd != -1 && !strcmp(itemPackType,"V"))
         {
         
   #ifdef DEBUG
   printf("writePOVNDP dlfghxf\n");
   #endif

            if (writePOVNDP(ediFilePtr) < OK)
               return(FATAL);
         }
         else
         {
            if (processBKD1rec() < OK)
               return(FATAL);

            /* if work order change indicator is not null and yes and is not a Delete Item DI send D2 recs*/
            if (woChangeInd != -1 && strcmp(woChange, "Y") == 0 && !strcmp(ordItemLocChangeCode,SMR_D1_CHANGE_CODE_DELETE_ITEM) == 0)
            {
               if (writeD2(ediFilePtr) < OK)
                  return(FATAL);
            }

         }
/**         continue; **/
      }

      /* check  1 - if no previous quantity ordered (is null) for new item/location
                2 - if unit retail different
                3 - if unit cost different
         if true then write D1 record                                                   */
      /*Removed || strcmp(oldOrderUnitRetail, orderUnitRetail) from below - put back in when retail starts coming from MSRP */
      if (oldQtyOrderedInd == -1 || strcmp(oldQtyOrdered, qtyOrdered)
          || strcmp(oldOrderUnitCost, orderUnitCost))
      {
         recSequence++;


         /* populate item field for writeD1 rec */
         strcpy(item, orderItem);
         strcpy(recTypeDescD1,"S860D1");
         strcpy(recTypeDescD2,"S860D2");

         /* determine what to populate in D1 rec field for quantity_left_to_receive  */
         /* if qty change and change time is increase or decrease populate with diff */
         if (atoi(qtyOrdered) != atoi(oldQtyOrdered)
             && (!strcmp(ordItemLocChangeCode,SMR_D1_CHANGE_CODE_QTY_DECREASE)
             || !strcmp(ordItemLocChangeCode,SMR_D1_CHANGE_CODE_QTY_INCREASE)))
             qtyDiffOrdered = fabs(atoi(oldQtyOrdered) - atoi(qtyOrdered));
         else
             qtyDiffOrdered = 0;

         /* populate D1 rec change code */
         if (oldQtyOrderedInd == -1)   /* check for new item */
         {
            strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_ADD_ITEM);
            qtyOrderedWork = atoi(oldQtyOrdered);
            qtyDiffOrdered = fabs(atoi(oldQtyOrdered) - atoi(qtyOrdered));

            if (processBKD1rec() < OK)
              return(FATAL);

         }
         else if (atoi(qtyOrdered) == 0)  /* check for SMR delete item */
         {
            strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_DELETE_ITEM);
            qtyOrderedWork = 0;   /* set 0 to delete item */
            qtyDiffOrdered = 0;

            /*Show old values if any have changed, as this is a delete*/
            strcpy(itemSupVPN,oldItemSupVPN);
            strcpy(upc,oldUPC);
            strcpy(itemColorDesc,oldItemColorDesc);
            strcpy(itemSizeDesc,oldItemSizeDesc);

            if (processBKD1rec() < OK)
            return(FATAL);

            continue;

         }

   #ifdef DEBUG
   printf("Before QD %s %s %s %s\n", orderItem, qtyOrdered, oldQtyOrdered, ordItemLocChangeCode);
   #endif

         if (!strcmp(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_ADD_ITEM)== 0 )
            {
            if (atoi(qtyOrdered) < atoi(oldQtyOrdered))
               {
   #ifdef DEBUG
   printf("In QD %s\n", orderItem);
   #endif

               strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_QTY_DECREASE);
               qtyOrderedWork = atoi(oldQtyOrdered);
               qtyDiffOrdered = fabs(atoi(oldQtyOrdered) - atoi(qtyOrdered));

               if (processBKD1rec() < OK)
               return(FATAL);

               }
            else if (atoi(qtyOrdered) > atoi(oldQtyOrdered))
               {
               strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_QTY_INCREASE);
               qtyOrderedWork = atoi(oldQtyOrdered);
               qtyDiffOrdered = fabs(atoi(oldQtyOrdered) - atoi(qtyOrdered));

               if (processBKD1rec() < OK)
               return(FATAL);

               }

            if (atoi(orderUnitCost) != atoi(oldOrderUnitCost))
               {
               strcpy(ordItemLocChangeCode, SMR_D1_CHANGE_CODE_PRICE_CHANGE);
               qtyOrderedWork = 0;  /* set 0 to price change */
               qtyDiffOrdered = 0;

               if (processBKD1rec() < OK)
               return(FATAL);

   #ifdef DEBUG
   printf("In first AI again\n");
   #endif

               }
            }

         /* if work order change indicator is not null and yes and is not a Delete Item DI send D2 recs*/
            if (woChangeInd != -1 && strcmp(woChange, "Y") == 0 && !strcmp(ordItemLocChangeCode,SMR_D1_CHANGE_CODE_DELETE_ITEM) == 0)
            {
               if (writeD2(ediFilePtr) < OK)
                  return(FATAL);
            }


         /* if pack type is not null and pack type is vendor
                                              write po vendor pack records */
         if (itemPackTypeInd != -1 && !strcmp(itemPackType,"V"))
         {
   #ifdef DEBUG
   printf("writePOVNDP lkjbl\n");
   #endif

            if (writePOVNDP(ediFilePtr) < OK)
               return(FATAL);
         }
      }
   }

   return(OK);

}

/*------------------------------------------------------*\
 * function writeD2()                                   *
\*------------------------------------------------------*/
int writeD2(FILE *outRtkFilePtr)
{
   char *function_name = "writeD2";

   int i = 0;

   EXEC SQL DECLARE cursorDetail2 CURSOR FOR
        SELECT s.item,
             substr(s.vpn,1,15),                                                                  
             CASE WHEN sk.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(sk.ref_item,p.item),1,15),15,'0')  
                  ELSE DECODE (p.item_number_type,'SMRBC','               ', LPAD(p.item,15,'0')) 
             END upc,
             t.ticket_type_id,
             substr(th.ticket_type_desc,1,10),
             substr(uv.uda_value_desc,1,instr(uv.uda_value_desc,',',1)-1),
             trim(substr(uv.uda_value_desc,instr(uv.uda_value_desc,',',1)+1,instr(uv.uda_value_desc,',',1)+10))
        FROM item_supplier s,
             item_master p,
             item_ticket t,
             ticket_type_head th,
             uda_item_lov u,
             uda_values uv,
             ordhead o,
             ordsku sk
       WHERE s.item = :item
             and o.order_no = TO_NUMBER(:orderNo)
             and sk.item(+) = s.item
             and sk.order_no(+) = TO_NUMBER(:orderNo)
             and s.supplier = o.supplier
             and s.item = p.item_parent(+)
             and p.primary_ref_item_ind(+) = 'Y'
             and s.item = t.item
             and t.ticket_type_id = th.ticket_type_id
             and s.item = u.item
             and u.uda_id = 1
             and u.uda_id = uv.uda_id
             and u.uda_value = uv.uda_value;

   #ifdef DEBUG
   printf("writeD2 - cursor open next\n");
   printf("writeD2 - order number is %s\n", orderNo);
   printf("writeD2 - item is %s\n", item);
   #endif

   EXEC SQL OPEN cursorDetail2;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDetail2");
      strcpy(table, "ordhead,ordsku,item_supplier,item_master,item_ticket,ticket_type_head,uda_item_loc,uda_values");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorDetail2 next\n");
   #endif

   while (1)
   {
      EXEC SQL FETCH cursorDetail2 INTO :orderItem,
                                            :itemSupVPN:itemSupVPNInd,
                                            :upc:upcInd,
                                            :itemTicketTypeId:itemTicketTypeIdInd,
                                            :itemTicketTypeDesc:itemTicketTypeDescInd,
                                            :itemHangerCode:itemHangerCodeInd,
                                            :itemHangerCodeDesc:itemHangerCodeDescInd;

      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorDetail2");
         strcpy(table, "ordhead,ordsku,item_supplier,item_master,item_ticket,ticket_type_head,uda_item_loc,uda_values");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(-1);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("  item is %s\n", orderItem);
      #endif

      /* validate that data fits into output format */

      /* handle any null values from query */
      if (itemSupVPNInd == -1)
         strcpy(itemSupVPN,"               ");   /* 15 spaces */

      if (upcInd == -1)
         strcpy(upc,"               ");          /* 15 spaces */

      if (itemTicketTypeIdInd == -1)
         strcpy(itemTicketTypeId,"          ");  /* 10 spaces */

      if (itemTicketTypeDescInd == -1)
         strcpy(itemTicketTypeDesc,"          ");  /* 10 spaces */

      if (itemHangerCodeInd == -1)
         strcpy(itemHangerCode,"          ");      /* 10 spaces */

      if (itemHangerCodeDescInd == -1)
         strcpy(itemHangerCodeDesc,"          ");  /* 10 spaces */

      i++;
      recSequence++;

      #ifdef DEBUG
      printf("writeD2 - main write next\n");
      #endif


   ps_hdr_record_id++;
   EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
      				  REC_TYPE2,         
      				  REC_SEQ,           
      				  SUPPLIER_NMBR,       
      				  COMPANY_ID,        
      				  PO_NMBR,           
      				  DC_STORE_NMBR,     
      				  ITEM_SKU_NMBR,     
      				  UPC,               
      				  VPN,               
      				  DETAIL_REC_SUB_SEL,
      				  CHARGE_IND,        
      				  VICS,              
      				  TCKT_HANG_CODE,              
      				  TCKT_HANG_DESC,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
      				  :recTypeDescD2,
      				  'D',
      				  :d1RecSequence,
      				  to_number(:supplier),
      				  1,
      				  to_number(:poNumber),
      				  to_number(:dcStoreNumber),
      				  to_number(:orderItem),
      				  :upc,
      				  :itemSupVPN,
      				  1,
      				  'N',
      				  'VI',
      				  :itemTicketTypeId,
      				  :itemTicketTypeDesc,
      				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D2_1 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


      /* write for D2 with ticket type */
      fprintf(outRtkFilePtr, d2String,
                           LEN_SMR_REC_TYPE1,            recTypeDescD2,
                           LEN_SMR_REC_TYPE2,             "D",
                           LEN_SMR_REC_SEQ,              d1RecSequence,
                           LEN_SMR_SUPPLIER_NMBR,          atoi(supplier),
                           LEN_SMR_COMPANY_ID,           1,
                           LEN_SMR_PO_NMBR,              atoi(poNumber),
                           LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                           LEN_SMR_ITEM_SKU_NMBR,        atol(orderItem),
                           LEN_SMR_UPC,                  upc,
                           LEN_SMR_VPN,                  itemSupVPN,
                           LEN_SMR_DETAIL_REC_SUB_SEL,   1,
                           LEN_SMR_CHARGE_IND,           "N",
                           LEN_SMR_VICS,                 "VI",
                           LEN_SMR_CODE,                 itemTicketTypeId,
                           LEN_SMR_CODE_DESC,            itemTicketTypeDesc);

      recSequence++;
      d1RecSequence++; 
      ps_hdr_record_id++;
      EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
      				  REC_TYPE2,         
      				  REC_SEQ,           
      				  SUPPLIER_NMBR,       
      				  COMPANY_ID,        
      				  PO_NMBR,           
      				  DC_STORE_NMBR,     
      				  ITEM_SKU_NMBR,     
      				  UPC,               
      				  VPN,               
      				  DETAIL_REC_SUB_SEL,
      				  CHARGE_IND,        
      				  VICS,              
      				  TCKT_HANG_CODE,              
      				  TCKT_HANG_DESC,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
      				  :recTypeDescD2,
      				  'D',
      				  :d1RecSequence,
      				  to_number(:supplier),
      				  1,
      				  to_number(:poNumber),
      				  to_number(:dcStoreNumber),
      				  to_number(:orderItem),
      				  :upc,
      				  :itemSupVPN,
      				  1,
      				  'N',
      				  'VI',
      				  :itemHangerCode,
      				  :itemHangerCodeDesc,
      				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D2_2 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }



      /* write for D2 with hanger type */
      fprintf(outRtkFilePtr, d2String,
                           LEN_SMR_REC_TYPE1,            recTypeDescD2,
                           LEN_SMR_REC_TYPE2,            "D",
                           LEN_SMR_REC_SEQ,              d1RecSequence,
                           LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
                           LEN_SMR_COMPANY_ID,           1,
                           LEN_SMR_PO_NMBR,              atoi(poNumber),
                           LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                           LEN_SMR_ITEM_SKU_NMBR,        atol(orderItem),
                           LEN_SMR_UPC,                  upc,
                           LEN_SMR_VPN,                  itemSupVPN,
                           LEN_SMR_DETAIL_REC_SUB_SEL,   1,
                           LEN_SMR_CHARGE_IND,           "N",
                           LEN_SMR_VICS,                 "VI",
                           LEN_SMR_CODE,                 itemHangerCode,
                           LEN_SMR_CODE_DESC,            itemHangerCodeDesc);

/*      d1RecSequence++; */
   }

   return(0);
}

/*------------------------------------------------------*\
* function writeD3()                                    *
\*------------------------------------------------------*/
int writeD3(FILE *outRtkFilePtr)
{
   char *function_name = "writeD3";

   int  i = 0; 
   int  j = 0;
  
   EXEC SQL DECLARE cursorDetail3 CURSOR FOR
        SELECT s.item,
             substr(s.vpn,1,15),                                                                  
             CASE WHEN sk.ref_item is not NULL 
                  THEN LPAD(SUBSTR(NVL(sk.ref_item,p.item),1,15),15,'0')  
                  ELSE DECODE (p.item_number_type,'SMRBC','               ', LPAD(p.item,15,'0')) 
             END upc,
             to_char(v.qty_ordered)             
        FROM item_supplier s,
             item_master p,
             ordhead o,
             ordsku sk,
             v_ord_extract_dtl_smr v             
       WHERE v.order_no = TO_NUMBER(:orderNo)
             and v.order_no = o.order_no
             and s.item = :item
             and o.order_no = TO_NUMBER(:orderNo)
             and sk.item(+) = s.item
             and sk.order_no(+) = TO_NUMBER(:orderNo)
             and s.supplier = o.supplier
             and s.item = p.item_parent(+)
             and p.primary_ref_item_ind(+) = 'Y'
             and v.item = s.item;

    EXEC SQL DECLARE cursorAllocForNewLocSt CURSOR FOR
        SELECT v.to_loc,
             substr(st.store_name,1,25),
             st.default_wh,
             to_char(v.qty_allocated),
             DECODE(SIGN(st.store_open_date-sysdate),1,'Y','N') newstore
        from v_ord_alloc_extract_dtl_860 v,
             store st,
             item_supplier sp,
             item_loc il,
             item_master u,
             item_master im,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds
            ,ordhead oh 
       where v.order_no = TO_NUMBER(:orderNo)
             and ((oh.location     in (select wh from wh_attributes where wh_type_code = 'DD') and v.to_loc = :allocRec.allocStore)
               or (oh.location not in (select wh from wh_attributes where wh_type_code = 'DD')))
             and im.item = :allocRec.allocItem
             and v.to_loc = st.store
             and v.item = sp.item
             and v.item = il.item
             and v.to_loc = il.loc
             and v.item = im.item
             AND v.item = u.item_parent(+)
             AND u.primary_ref_item_ind(+) = 'Y'
             and v.item = dc.item(+)
             and v.item = ds.item(+)
             and sp.supplier = oh.supplier
             and oh.order_no = v.order_no
             and v.qty_allocated > 0 
      ORDER BY 1;


#ifdef DEBUG
printf("writeD3 - cursor open next\n");
printf("writeD3 - order number is %s\n", orderNo);
printf("writeD3 - item is %s\n", item);
printf("writeD3 - hbOrder is %s\n", hbOrder);
#endif

if ((strcmp(poType,SMR_STANDALONE_PO_TYPE) == 0) || (atoi(hbOrder)))
{
   /* ship to location */
   strcpy(d3StoreNumber, dcStoreNumber);

   EXEC SQL OPEN cursorDetail3;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorDetail3");
      strcpy(table, "ordhead,ordsku,item_supplier,item_master");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

   #ifdef DEBUG
   printf("Loop through fetches of cursorDetail3 next\n");
   #endif

   EXEC SQL FETCH cursorDetail3 INTO :orderItem,
                                     :itemSupVPN:itemSupVPNInd,
                                     :upc:upcInd,
                                     :qtyOrdered;


   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR FETCH: cursor=cursorDetail3");
      strcpy(table, "ordhead,ordsku,item_supplier,item_master");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(-1);
   }

   #ifdef DEBUG
   printf("  item is %s\n", orderItem);
   printf("qtyOrdered is %s\n", qtyOrdered);
   printf("d3StoreNumber is %s\n", d3StoreNumber);
   #endif

   /* validate that data fits into output format */
   /* handle any null values from query          */
   if (itemSupVPNInd == -1)
      strcpy(itemSupVPN,"               ");   /* 15 spaces */

   if (upcInd == -1)
      strcpy(upc,"               ");          /* 15 spaces */

   recSequence++;

   #ifdef DEBUG
   printf("writeD3 - main write next\n");
   #endif


   ps_hdr_record_id++;
   d1RecSequence++;
   EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
      				  REC_TYPE2,         
      				  REC_SEQ,           
      				  SUPPLIER_NMBR,       
      				  COMPANY_ID,        
      				  PO_NMBR,           
      				  DC_STORE_NMBR,     
      				  ITEM_SKU_NMBR,     
      				  UPC,               
      				  VPN,               
      				  SDQ_TEXT,
      				  UOM_IDENTIFIER,        
      				  STORE,
      				  STORE_QUANTITY,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
      				  :recTypeDescD3,
      				  'D',
      				  :d1RecSequence,
      				  to_number(:supplier),
      				  1,
      				  to_number(:poNumber),
      				  to_number(:dcStoreNumber),
      				  to_number(:orderItem),
      				  :upc,
      				  :itemSupVPN,
      				  'SDQ',
      				  :UOM_D3,
      				  :d3StoreNumber,
      				  to_number(:qtyOrdered),
      				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));

   if (SQL_ERROR_FOUND)
   {
      sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D3 INSERT: for order no <%s>",poNumber);
      strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

      /* write for D3 */
      fprintf(outRtkFilePtr, d3String,
                           LEN_SMR_REC_TYPE1,            recTypeDescD3,
                           LEN_SMR_REC_TYPE2,             "D",
                           LEN_SMR_REC_SEQ,              d1RecSequence,
                           LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
                           LEN_SMR_COMPANY_ID,           1,
                           LEN_SMR_PO_NMBR,              atoi(poNumber),
                           LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                           LEN_SMR_ITEM_SKU_NMBR,        atol(orderItem),
                           LEN_SMR_UPC,                  upc,
                           LEN_SMR_VPN,                  itemSupVPN,
                           LEN_SDQ_TEXT,                 "SDQ",
                           LEN_SMR_UOM_IDENTIFIER,       "EA",
                           LEN_SMR_DC_STORE_NMBR,        atoi(d3StoreNumber),
                           LEN_SMR_ITEM_QTY,             atoi(qtyOrdered),
                           LEN_SDQ_SA_FILL,              " 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 ");

      fprintf(outRtkFilePtr, "%s", "\n");
      recSequence++;
 }
 else if ((strcmp(poType,SMR_ALLOC_PO_TYPE) == 0) && !(atoi(hbOrder)))
 {
       #ifdef DEBUG
       printf("  item333 is <%s>\n", allocRec.allocItem);
       #endif
 
       /* validate that data fits into output format */
 
       /* handle any null values from query */
       if (itemSupVPNInd == -1)
          strcpy(itemSupVPN,"               ");   /* 15 spaces */
 
       if (upcInd == -1)
          strcpy(upc,"               ");          /* 15 spaces */
 
       #ifdef DEBUG
       printf("writeD3333 - main write next\n");
       #endif
 
      EXEC SQL OPEN cursorAllocForNewLocSt;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorAllocForNewLoc");
         strcpy(table, "alloc_header,alloc_detail,store");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }

      while( 1 )
      {            
	 EXEC SQL FETCH cursorAllocForNewLocSt INTO :allocRec.allocStore,
					      :allocRec.allocStoreName,
					      :allocRec.storeDefaultWh:storeDefaultWhInd,
					      :allocRec.qtyAlloc,
					      :allocRec.newStore;

	 if SQL_ERROR_FOUND
	 {
	   strcpy(err_data, "CURSOR FETCH: cursor=cursorAllocForNewLocSt");
	   strcpy(table, "alloc_header,alloc_detail,store");
	   WRITE_ERROR(SQLCODE,function_name,table,err_data);
	   return(FATAL);
	 }
	 if NO_DATA_FOUND break;

         #ifdef DEBUG
         printf("WhInd=<%d> as=<%s> asn=<%s> dw=<%s> qty=<%s> ns=<%s>\n", storeDefaultWhInd,allocRec.allocStore,allocRec.allocStoreName,allocRec.storeDefaultWh,allocRec.qtyAlloc,allocRec.newStore);
         #endif
       
    
         /* ship to location */
         strcpy(d3StoreNumber, allocRec.allocStore);

         if (strcmp(orderLocation, ps_dd_wh) == 0)
           strcpy(dcStoreNumber,allocRec.allocStore);
         else         
         {
           strncpy(dcStoreNumber,allocRec.storeDefaultWh,3);
           dcStoreNumber[3] = '\0';
         }
         strcpy(qtyOrdered,allocRec.qtyAlloc);

         #ifdef DEBUG
         printf("d3s=<%s> dcs=<%s> qty=<%s>\n", d3StoreNumber,dcStoreNumber,qtyOrdered);
         #endif
       
        
         if (SQL_ERROR_FOUND)
         {
            sprintf(err_data, "SMR_PO_EDI_850_860_DTL_EXP D333 INSERT: for order no <%s>",poNumber);
            strcpy(table, "SMR_PO_EDI_850_860_DTL_EXP");
            WRITE_ERROR(SQLCODE,function_name,table,err_data);
            return(FATAL);
         }
 
         i++;
         if ( i == 9 )
         {
            i = 1;
            fprintf(outRtkFilePtr, "%s", "\n");
         }

         #ifdef DEBUG
         printf("i=<%d> po=<%s> item=<%s> store=<%s> qty=<%s>\n", i,poNumber,allocRec.allocItem,d3StoreNumber,qtyOrdered);
         #endif
       
         if ( i == 1 ) 
         {
            recSequence++;
            d1RecSequence++;
            ps_hdr_record_id++;
            EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
       				  REC_TYPE2,         
       				  REC_SEQ,
       				  SUPPLIER_NMBR,       
       				  COMPANY_ID,        
       				  PO_NMBR,           
       				  DC_STORE_NMBR,     
       				  ITEM_SKU_NMBR,     
       				  UPC,               
       				  VPN,               
       				  SDQ_TEXT,
       				  UOM_IDENTIFIER,        
       				  SDQ1_STORE,
       				  SDQ1_STORE_QUANTITY,
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
       				  :recTypeDescD3,
       				  'D',
       				  :d1RecSequence,
       				  to_number(:supplier),
       				  1,
       				  to_number(:poNumber),
       				  to_number(:dcStoreNumber),
       				  to_number(:allocRec.allocItem),
       				  :upc,
       				  :itemSupVPN,
       				  'SDQ',
       				  :UOM_D3,
       				  :d3StoreNumber,
       				  to_number(:qtyOrdered),
       				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));


            /* write for D3 */
            fprintf(outRtkFilePtr, d3String,
                         LEN_SMR_REC_TYPE1,            recTypeDescD3,
                         LEN_SMR_REC_TYPE2,             "D",
                         LEN_SMR_REC_SEQ,              d1RecSequence,
                         LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),
                         LEN_SMR_COMPANY_ID,           1,
                         LEN_SMR_PO_NMBR,              atoi(poNumber),
                         LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),
                         LEN_SMR_ITEM_SKU_NMBR,        atol(allocRec.allocItem),
                         LEN_SMR_UPC,                  upc,
                         LEN_SMR_VPN,                  itemSupVPN,
                         LEN_SDQ_TEXT,                 "SDQ",
                         LEN_SMR_UOM_IDENTIFIER,       "EA",
                         LEN_SMR_DC_STORE_NMBR,        atoi(d3StoreNumber),
                         LEN_SMR_ITEM_QTY,             atoi(qtyOrdered),
                         1,                            " ");
            
         } 
         else 
         {
           if ( i == 2 )
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ2_STORE = :d3StoreNumber, SDQ2_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 3 )
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ3_STORE = :d3StoreNumber, SDQ3_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 4 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ4_STORE = :d3StoreNumber, SDQ4_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 5 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ5_STORE = :d3StoreNumber, SDQ5_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 6 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ6_STORE = :d3StoreNumber, SDQ6_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 7 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ7_STORE = :d3StoreNumber, SDQ7_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
           else if ( i == 8 ) 
             EXEC SQL UPDATE SMR_PO_EDI_850_860_DTL_EXP set SDQ8_STORE = :d3StoreNumber, SDQ8_STORE_QUANTITY = to_number(:qtyOrdered)
                       WHERE REC_TYPE1 = :recTypeDescD3 and PO_NMBR = to_number(:poNumber) and ITEM_SKU_NMBR = to_number(:allocRec.allocItem) and REC_SEQ = :d1RecSequence;
         
           fprintf(outRtkFilePtr, "%05d%07d%s",atoi(d3StoreNumber),atoi(qtyOrdered)," ");
         }
       
      } /* while */
  
      if ( i > 0 ) for (j = i; j < 8; j++) fprintf(outRtkFilePtr, "%s","000000000000 ");      
      fprintf(outRtkFilePtr, "%s", "\n");
      
      EXEC SQL CLOSE cursorAllocForNewLocSt;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR CLOSE: cursor=cursorAllocForNewLoc");
         strcpy(table, "alloc_header,alloc_detail,store");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
   }

   return(0);
}



/*------------------------------------------------------*\
* function writePOVNDP()                                *
\*------------------------------------------------------*/
int writePOVNDP(FILE *outRtkFilePtr)
{
   char *function_name = "writePOVNDP";

   char componentItem[LEN_SMR_ITEM_SKU_NMBR+1];
   char packQty[LEN_SMR_ITEM_QTY+1];
   
   char sublineQty[LEN_SMR_PACK_SUBLINE_QTY+1];

   EXEC SQL DECLARE cursorPackDetail CURSOR FOR
             SELECT pk.item,
             substr(s.vpn,1,15),                                                                    
             to_char(pk.pack_qty),
             to_char(il.unit_retail*10000),
             to_char(ils.unit_cost*10000),
             LPAD(p.item,15,'0') upc,
             substr(dc.diff_desc,1,15) color_desc,
             substr(ds.diff_desc,1,15) size_desc,
             to_char(i.mfg_rec_retail*10000)
        FROM ordhead oh,
             item_loc il,
             item_loc_soh ils,
             item_supplier s,
             item_master i,
             item_master p,
             (select i.item, c.diff_desc
                from item_master i, diff_ids c
               where c.diff_type = 'C'
                     and (i.diff_1 = c.diff_id or i.diff_2 = c.diff_id
                          or i.diff_3 = c.diff_id or i.diff_4 = c.diff_id)) dc,
             (select i.item, s.diff_desc
                from item_master i, diff_ids s
               where s.diff_type = 'S'
                     and (i.diff_1 = s.diff_id or i.diff_2 = s.diff_id
                          or i.diff_3 = s.diff_id or i.diff_4 = s.diff_id)) ds,
             packitem pk
       WHERE pk.pack_no = :item
             and oh.order_no = TO_NUMBER(:orderNo)
             and il.item = pk.item
             and il.loc = oh.location
             and ils.item = il.item
             and ils.loc = il.loc
             and i.item = pk.item
             and s.supplier = oh.supplier
             and s.item = pk.item
             and pk.item = p.item_parent(+)
             and p.primary_ref_item_ind(+) = 'Y'
             and i.item = dc.item(+)
             and i.item = ds.item(+)
    ORDER BY pk.item;

   EXEC SQL DECLARE cursorSubline CURSOR FOR
      SELECT to_char(sum(pack_qty))
        FROM packitem
       WHERE pack_no = :item
         and pack_no in (select item from ordloc where order_no = TO_NUMBER(:orderNo)) ;

   EXEC SQL DECLARE cursorVPItemQty CURSOR FOR
     SELECT sum(v.qty_allocated) item_qty
       from v_ord_alloc_extract_dtl_860 v
      where v.order_no = TO_NUMBER(:orderNo)
        and v.item = :item
        and qty_allocated > 0;
        

   EXEC SQL OPEN cursorSubline;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorSubline");
      strcpy(table, "packhtitem");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   EXEC SQL FETCH cursorSubline INTO :sublineQty;

   #ifdef DEBUG
   printf("cursorSubline is %s\n",sublineQty);
   #endif


   EXEC SQL CLOSE cursorSubline;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR CLOSE: cursor=cursorSubline");
      strcpy(table, "packitem");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }

   #ifdef DEBUG
   printf("hbOrder is %s\n",hbOrder);
   #endif

   if (( strcmp(poType, SMR_ALLOC_PO_TYPE) == 0) && !(atoi(hbOrder)))
   {
      EXEC SQL OPEN cursorVPItemQty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR OPEN: cursor=cursorVPItemQty");
         strcpy(table, "packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
   
      EXEC SQL FETCH cursorVPItemQty INTO :qtyVPItem;

      EXEC SQL CLOSE cursorVPItemQty;
      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR CLOSE: cursor=cursorVPItemQty");
         strcpy(table, "packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }      
   }
   else
      strcpy( qtyVPItem, qtyOrdered );

   #ifdef DEBUG
   printf("qtyVPItem is %s\n",qtyVPItem);
   #endif

   EXEC SQL OPEN cursorPackDetail;
   if SQL_ERROR_FOUND
   {
      strcpy(err_data, "CURSOR OPEN: cursor=cursorPackDetail");
      strcpy(table, "packitem");
      WRITE_ERROR(SQLCODE,function_name,table,err_data);
      return(FATAL);
   }


            recSequence++;
            d1RecSequence=1;
            ps_hdr_record_id++;
            EXEC SQL insert into SMR_PO_EDI_850_860_DTL_EXP( group_id,
                                  record_id,
                                  REC_TYPE1,         
       				  REC_TYPE2,         
       				  REC_SEQ,           
       				  SUPPLIER_NMBR,      
       				  COMPANY_ID,        
       				  PO_NMBR,           
       				  DC_STORE_NMBR,     
       				  PACK_SKU_NMBR,     
       				  DETAIL_REC_SUB_SEL,
       				  PO_CHANGE_CODE,
       				  VPN,               
                                  ITEM_QTY,
                                  QTY_LEFT_TO_RECEIVE,
       				  UOM_IDENTIFIER,       
      				  PACK_UNIT_COST,            
      				  PACK_UPC,
   				  TOTAL_SUBLINE_QTY,  
   				  create_datetime) values (  		
   				  :ps_interface_id||'-'||substr(:ps_vdate,1,8)||'-'||lpad(to_char(RMS13.RMS_SMR_EDI_850_860_SEQ.currval),10,'0'),
   				  :ps_hdr_record_id,
       				  :recTypeDescVP,
       				  'P',
       				  :d1RecSequence,
       				  to_number(:supplier),
       				  1,
       				  to_number(:poNumber),
       				  to_number(:dcStoreNumber),
       				  to_number(:item), /* pack sku!? */
       				  1,
   				  :ordItemLocChangeCode,
   				  :itemSupVPN,   				  
       				  to_number(:qtyVPItem), 
                                  :qtyDiffOrdered,   				  
       				  'AS',
       				  to_number(:orderUnitCost), 
       				  :upc, 
       				  to_number(:sublineQty),
       				  to_date(:ps_create_datetime,'YYYYMMDDHH24MISS'));


   /* write for POVNDP ...
   fprintf(outRtkFilePtr, poVndpString,
                        LEN_SMR_REC_TYPE1,            "POVNDP",
                        LEN_SMR_PO_NMBR,              atoi(poNumber),
                        LEN_SMR_ITEM_SKU_NMBR,        atol(item),
                        LEN_SMR_ITEM_SKU_NMBR,        atol(componentItem),
                        LEN_SMR_PACK_QTY,             atoi(packQty)); */
                        
   fprintf(outRtkFilePtr, poVndpString,
                        LEN_SMR_REC_TYPE1,            "SPOVND",	          /* RMS_Record_Type      */
                        LEN_SMR_REC_TYPE2,            "P",		  /* Record_Type          */
                        LEN_SMR_REC_SEQ,              d1RecSequence,	  /* Record_Sequence      */
                        LEN_SMR_SUPPLIER_NMBR,        atoi(supplier),	  /* Trading_Partner_Id   */
                        LEN_SMR_COMPANY_ID,           1,		  /* Company_Id           */
                        LEN_SMR_PO_NMBR,              atoi(poNumber),	  /* PO_Number            */
                        LEN_SMR_DC_STORE_NMBR,        atoi(dcStoreNumber),/* Store                */
                        LEN_SMR_ITEM_SKU_NMBR,        atol(item),	  /* Pack_Sku		  */
                        LEN_SMR_DETAIL_REC_SUB_SEL,   1,		  /* Detail_Record_Sub_Seq*/
                                                    /*ordItemLocChangeCode*/
                        LEN_SMR_VPN,                  itemSupVPN,	  /* Vendor_Model_Number  */
                        LEN_SMR_PACK_QTY,             atoi(qtyVPItem),	  /* Pack_Units		  */
                        LEN_SMR_UOM_IDENTIFIER,       "AS",		  /* UOM_Identifier	  */
                        LEN_SMR_UNIT_COST,            atol(orderUnitCost),/* Pack_Unit_Cost       */
                        LEN_SMR_UPC,                  upc,		  /* Pack_UPC		  */
                        LEN_SMR_PACK_SUBLINE_QTY,     atoi(sublineQty));  /* Total_Subline_QTY    */

   #ifdef DEBUG
   printf("poType is %s\n",poType);
   #endif

   if (strcmp(poType,"BK") != 0 )
   {
      strcpy( UOM_D3, "AS" );
      if (writeD3(ediFilePtr) < OK)
         return(FATAL);
      strcpy( UOM_D3, "EA" );
   }
         
   #ifdef DEBUG
   printf("Loop through fetches of cursorPackDetail next\n");
   #endif

   while (1)
   {
      EXEC SQL FETCH cursorPackDetail INTO :componentItem,
                                       :itemSupVPN:itemSupVPNInd,
                                       :packQty,
                                       :orderUnitRetail:orderUnitRetailInd,
                                       :orderUnitCost,
                                       :upc:upcInd,
                                       :itemColorDesc:itemColorDescInd,
                                       :itemSizeDesc:itemSizeDescInd,
                                       :itemMfgRecRetail:itemMfgRecRetailInd;


      if SQL_ERROR_FOUND
      {
         strcpy(err_data, "CURSOR FETCH: cursor=cursorPackDetail");
         strcpy(table, "packitem");
         WRITE_ERROR(SQLCODE,function_name,table,err_data);
         return(FATAL);
      }
      if NO_DATA_FOUND break;

      #ifdef DEBUG
      printf("  writing vendor D4,D2\n");
      #endif

      #ifdef DEBUG
      printf("  component item is %s\n", componentItem);
      #endif

      strcpy(item, componentItem);
      strcpy(recTypeDescD1, recTypeDescD4);
      strcpy(qtyOrdered, packQty);


      d1RecSequence++;
      if (writeD1(ediFilePtr) < OK)
         return(FATAL);

      d1RecSequence++;
      if (writeD2(ediFilePtr) < OK)
         return(FATAL);

      #ifdef DEBUG
      printf("  finished writing vendor D4,D2\n");
      #endif

   }

   return(OK);
}

/*------------------------------------------------------*\
* function final()                                       *
\*------------------------------------------------------*/

int final(void)
{
    int finalReturnInt = 0;
    char *function_name = "final";


    if (retek_close() < 0)
        finalReturnInt = -1;

    return(finalReturnInt);

} /* end final */


/**********************************************************************************/
/* processBKD1rec() -
/**********************************************************************************/
int processBKD1rec(void)
{
   char *function_name = "processBKD1rec";

         sprintf(qtyOrdered, "%i", qtyOrderedWork);

         /* Reset item sequence number for each PO/item */
         d1RecSequence=1;

         /* BULK ORDERS D1 */

         /*If there is a price change, then the QI and QD should show the old unit cost*/
         if ( strcmp(ordItemLocChangeCode, "QI") == 0 || strcmp(ordItemLocChangeCode, "QD") == 0 )
         {

             strcpy(holdOrderUnitCost,orderUnitCost);
             strcpy(orderUnitCost,oldOrderUnitCost);
         }

         /* write detail records */
         if (writeD1(ediFilePtr) < OK)
              return(FATAL);
         d1RecSequence++;

         /*If there is a price change, then the QI and QD should show the old unit cost
           copy held unit cost back into current unit cost */
         if ( strcmp(ordItemLocChangeCode, "QI") == 0 || strcmp(ordItemLocChangeCode, "QD") == 0 )
         {
             strcpy(orderUnitCost,holdOrderUnitCost);
         }


   return(OK);
}

/**********************************************************************************/
/* processRLD1rec() -
/**********************************************************************************/
int processRLD1rec(void)
{
         char *function_name = "processRLD1rec";

         sprintf(qtyOrdered, "%i", qtyOrderedWork);

         #ifdef DEBUG
            printf("Logic for check of detail change type next\n");
            printf("D1 change type is <%s> for item <%s>\n",ordItemLocChangeCode, item);
         #endif

         /* check if any change to process for detail - should be change code */
         if (strcmp(ordItemLocChangeCode,""))
         {
            /* vpn */
            if (allocRec.supVPNInd == -1)
               strcpy(itemSupVPN,SMR_15SPACES);   /* 15 SPACES */
            else
               strcpy(itemSupVPN,allocRec.supVPN);

            /* qty alloc/ordered, unit cost, unit retail */

            /*If there is a price change, then the QI and QD should show the old unit cost*/
            if ( strcmp(ordItemLocChangeCode, "QI") == 0 || strcmp(ordItemLocChangeCode, "QD") == 0 )
               strcpy(orderUnitCost,allocRec.oldItemUnitCost);
            else
               strcpy(orderUnitCost,allocRec.itemUnitCost);

            strcpy(orderUnitRetail,allocRec.itemUnitRetail);
            strcpy(itemMfgRecRetail,allocRec.itemMfgRecRetail);

            #ifdef DEBUG
            printf("Item unit cost is <%s>\n",orderUnitCost);
            #endif

            /* upc */
            if (allocRec.itemUPCInd == -1)
               strcpy(upc, SMR_15SPACES);                        /* 15 SPACES */
            else
               strcpy(upc, allocRec.itemUPC);

            /* color and size desc */
            if (allocRec.itemColorDescInd == -1)
               strcpy(itemColorDesc,SMR_15SPACES);               /* 15 SPACES */
            else
               strcpy(itemColorDesc,allocRec.itemColorDesc);

            if (allocRec.itemSizeDescInd == -1)
               strcpy(itemSizeDesc,SMR_15SPACES);                /* 15 SPACES */
            else
               strcpy(itemSizeDesc,allocRec.itemSizeDesc);

            #ifdef DEBUG
            printf("ordItemLocChangeCode is <%s>\n",ordItemLocChangeCode);
            #endif


            /*UPC/VPN/color/size copy old to new if delete*/            
            if (strcmp(ordItemLocChangeCode,"DI") == 0)
            {
               /* vpn */
               if (allocRec.oldSupVPNInd == -1)
                  strcpy(oldItemSupVPN,SMR_15SPACES);   /* 15 SPACES */
               else
                  strcpy(oldItemSupVPN,allocRec.oldSupVPN);

               /* upc */
               if (allocRec.oldItemUPCInd == -1)
                  strcpy(oldUPC,SMR_15SPACES);            /* 15 SPACES */
               else
                  strcpy(oldUPC, allocRec.oldItemUPC);

               /* color and size desc */
               if (allocRec.oldItemColorDescInd == -1)
                  strcpy(oldItemColorDesc,SMR_15SPACES);               /* 15 SPACES */
               else
                  strcpy(oldItemColorDesc,allocRec.oldItemColorDesc);

               if (allocRec.oldItemSizeDescInd == -1)
                  strcpy(oldItemSizeDesc,SMR_15SPACES);                /* 15 SPACES */
               else
                  strcpy(oldItemSizeDesc,allocRec.oldItemSizeDesc);

               strcpy(holdItemSupVPN,itemSupVPN);
               strcpy(holdUPC,upc);
               strcpy(holdItemColorDesc,itemColorDesc);
               strcpy(holdItemSizeDesc,itemSizeDesc);

               strcpy(upc,oldUPC);
               strcpy(itemSupVPN,oldItemSupVPN);
               strcpy(itemColorDesc,oldItemColorDesc);
               strcpy(itemSizeDesc,oldItemSizeDesc);

            }

            /* ALLOCATION ORDERS D1 */
            /* if pack type is not null and pack type is vendor write po vendor pack records */
            
            if (allocRec.itemPackTypeInd != -1 && !strcmp(allocRec.itemPackType,"V"))
            {
   #ifdef DEBUG
   printf("writePOVNDP ALLOCATION ORDERS\n");
   #endif
               if (writePOVNDP(ediFilePtr) < OK)
                  return(FATAL);
            }
            else /* write detail records */
            {
               if (writeD1(ediFilePtr) < OK)
                 return(FATAL);
                 
               d1RecSequence++;
            
               /*UPC/VPN/color/size copy new back from hold new if delete*/
               if (strcmp(ordItemLocChangeCode,"DI") == 0)
               {
                  strcpy(itemSupVPN,holdItemSupVPN);
                  strcpy(upc,holdUPC);
                  strcpy(itemColorDesc,holdItemColorDesc);
                  strcpy(holdItemSizeDesc,itemSizeDesc);
               }
 
               /* Is not a Delete Item DI.. send D2 recs*/
               if (woChangeInd != -1 && strcmp(woChange, "Y") == 0 && !strcmp(ordItemLocChangeCode,SMR_D1_CHANGE_CODE_DELETE_ITEM) == 0)         
                 if (writeD2(ediFilePtr) < OK)
                    return(FATAL);

               if (writeD3(ediFilePtr) < OK)
                 return(FATAL);
            }

         } /* end if for check of change exist */

   return(OK);
}


